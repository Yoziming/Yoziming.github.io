<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on yoziming&#39; Blog</title>
    <link>https://yoziming.github.io/post/</link>
    <description>Recent content in Posts on yoziming&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>yoziming</copyright>
    <lastBuildDate>Wed, 17 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://yoziming.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>尚硅谷JAVA基礎課-DAY02筆記</title>
      <link>https://yoziming.github.io/post/211117-%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A4%8E%E8%AA%B2-day02%E7%AD%86%E8%A8%98/</link>
      <pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A4%8E%E8%AA%B2-day02%E7%AD%86%E8%A8%98/</guid>
      <description>DAY02筆記 關鍵字  有特殊含意與用途，所有關鍵字都是小寫
 例如:if、new&amp;hellip;等等，後面都會一一接觸到
保留字  未來版本可能會用到而保留
 例如:goto、const
標識符(identifier)  可以自己命名的(類、變量、函數&amp;hellip;等)就叫標識符
   由字母、數字、_、$組成
  數字不可為開頭
  能包含關鍵字但不能純用關鍵字
  嚴格區分大小寫
  不能包含空格
命名規範  不強制但最好遵守
   包名:多單詞所有字母小寫aaabbbccc
  類名、接口名:大駝峰(首字母大寫)AaaBbbCcc
  變量名、方法名:開頭小寫後面首字母大寫(小駝峰)aaaBbbCcc
  常量名:全大寫，用下畫線相連AAA_BBB_CCC
  命名要有意義，見名知意
  變量(variable)  記憶體中的一個儲存區域，使用的基本單位
  必須先聲明，後使用 作用域在其定義所在的一對{}內，只在其作用域中有效 同一作用域中不可重複  內置數據類型  Java語言提供了八種基本類型。 六種數字類型（四個整數型，兩個浮點型），一種字符類型，還有一種布爾型。
 byte：
 byte數據類型是8位、有符號的，以二進制補碼表示的整數 最小值是-128（-2^7）最大值是127（2^7-1）默認值是0 byte類型用在大型數組中節約空間，主要代替整數，因為byte變量佔用的空間只有int類型的四分之一 例子：byte a = 100，byte b = -50。  short：</description>
    </item>
    
    <item>
      <title>LeetCodeEasy1-3</title>
      <link>https://yoziming.github.io/post/211116-leetcodeeasy1-3/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-leetcodeeasy1-3/</guid>
      <description>1. Two Sum
 求某數組中哪兩位數的和等於X
 // nums []int=傳入的數組；target=X func twoSum(nums []int, target int) []int { m := make(map[int]int, len(nums)) for i, num := range nums { if idx, ok := m[target-num]; ok { return []int{idx, i} } m[num] = i } return []int{0, 0} } 9. Palindrome Number
 判斷是否為迴文數字，例如121
 13. Roman to Integer
 羅馬字母轉成數字
 // s=傳入的羅馬字串 func romanToInt(s string) int { // 創一個map將所有羅馬字對應數值 	var romanMap = map[byte]int{&amp;#39;I&amp;#39;: 1, &amp;#39;V&amp;#39;: 5, &amp;#39;X&amp;#39;: 10, &amp;#39;L&amp;#39;: 50, &amp;#39;C&amp;#39;: 100, &amp;#39;D&amp;#39;: 500, &amp;#39;M&amp;#39;: 1000} var result = romanMap[s[len(s)-1]] // 先取最右邊的那1位羅馬字是多少  for i := len(s) - 2; i &amp;gt;= 0; i-- { // 從右2羅馬字開始往左數 	if romanMap[s[i]] &amp;lt; romanMap[s[i+1]] { // 如果羅馬字右邊&amp;gt;左邊，例如IV或IX這種情況，表示要減去左邊位 	result -= romanMap[s[i]] } else { result += romanMap[s[i]] // 否則相加 	} // 循環至i=0，也就是最左邊的羅馬字位也算完即是最終答案 	} return result } </description>
    </item>
    
    <item>
      <title>尚硅谷JAVA基礎課-DAY01筆記</title>
      <link>https://yoziming.github.io/post/211116-%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A4%8E%E8%AA%B2-day01%E7%AD%86%E8%A8%98/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A4%8E%E8%AA%B2-day01%E7%AD%86%E8%A8%98/</guid>
      <description>DAY01 常用DOS操作   cd=進入指定目錄
  cd..=回上層
  cd=回到根目錄
  變更硬碟目錄=直接輸入d:
  dir=列出當前目錄下的清單
  del=刪除檔案(對文件夾使用=刪除文件內所有檔案)
  md=創建目錄
  rd=刪除目錄
  exit=退出
  JAVA體系在不同平台的版本演化  JAVA SE，標準版，桌面級應用等，基礎API JAVA EE，企業版，主要用於Web開發，包含Servlet、JSP等技術 JAVA ME，小型版，古老的PDA、手機等，已過時 JAVA Card，面向小程序(Applets)，運行在小設備(如智能卡)等平台  JAVA語言特性  由繼承的脈絡可說JAVA是類C語言
  強制面向對象:先搞懂何謂&amp;quot;類&amp;quot;與&amp;quot;對象&amp;quot;  三大特性:封裝、繼承、多態   健壯性:強類型、異常處理、GC(垃圾回收)、丟棄指針等 跨平台:只要平台能跑JVM(虛擬機)就能跑JAVA  JAVA語言的環境  JDK&amp;gt;JRE&amp;gt;JVM
  JDK，JAVA Development Kit，開發工具包，給開發人員用的，包含了JRE以及編譯工具(javac.exe)、打包工具(jar.exe)&amp;hellip;等等。 JRE，JAVA Runtime Environment，運行環境，包含JVM虛擬機和運作需要的核心類庫等等，簡單說就是運行由JDK做好的東西。  JAVA環境配置   下載JDK 8u202版本，最後的商用免費版(若純個人使用不論版本都是免費的)</description>
    </item>
    
    <item>
      <title>修改css或js後瀏覽器快取不更新問題</title>
      <link>https://yoziming.github.io/post/211017-%E4%BF%AE%E6%94%B9css%E6%88%96js%E5%BE%8C%E7%80%8F%E8%A6%BD%E5%99%A8%E5%BF%AB%E5%8F%96%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211017-%E4%BF%AE%E6%94%B9css%E6%88%96js%E5%BE%8C%E7%80%8F%E8%A6%BD%E5%99%A8%E5%BF%AB%E5%8F%96%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%95%8F%E9%A1%8C/</guid>
      <description>修改css或js後瀏覽器快取不更新問題  當初我真的是被這個整到懷疑人生
 解決方式一：
​ 使用者按Ctrl + F5強制重新整理頁面或者手動清空了瀏覽器的快取。此時瀏覽器會重新向伺服器獲取CSS和JS檔案,新的檔案便會生效。
解決方式二：
​ 但是使用者量過大的時候總不能讓每個使用者一一清理快取吧，於是便從程式碼的角度著手解決這個問題。在js後面新增版本號，讓瀏覽器把這個JS檔案當做新的檔案重新向伺服器獲取資源。
加版本號前：
 &amp;lt;script type=&amp;#34;text/javascript&amp;#34; th:src=&amp;#34;@{/js/test/index.js}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  加版本號後：
 &amp;lt;script type=&amp;#34;text/javascript&amp;#34; th:src=&amp;#34;@{/js/test/index.js?v=1.0}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  參考 https://www.itread01.com/content/1548610940.html</description>
    </item>
    
    <item>
      <title>Docker &amp; Hyper-V占用port問題</title>
      <link>https://yoziming.github.io/post/211015-docker-hyper-v%E5%8D%A0%E7%94%A8port%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211015-docker-hyper-v%E5%8D%A0%E7%94%A8port%E5%95%8F%E9%A1%8C/</guid>
      <description>Docker &amp;amp; Hyper-V占用port問題 在window下用docker desktop有時候遇上port被莫名佔用 用指令netstat -ano | findstr xxx查詢xxx埠被誰佔用卻又顯示沒有
原來是因為在window下用docker需要依賴hyper-v技術， 而這個hyper-v每次都會隨機搶走一部分tcp埠，使用命令可以得知應避開的範圍:
# powershell / cmd netsh interface ipv4 show excludedportrange protocol=tcp 如果避不開就手動叫Hyper-V讓路   關閉hyper-v
# powershell / cmd dism.exe /Online /Disable-Feature:Microsoft-Hyper-V   配置ipv4動態埠 / 或者配置需要的埠不被佔用
# powershell / cmd 管理員許可權 # start 起始埠 num 表示可用埠數 按自己的需求來 netsh int ipv4 set dynamicport tcp start=30000 num=16383 // 叫他去用30000以後的阜 # 排除ipv4動態埠佔用 startport 起始埠 numberofports 埠數 netsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1 // 或是指定端口50051為要讓路的   重新啟動hyper-v</description>
    </item>
    
    <item>
      <title>ubuntu常用操作</title>
      <link>https://yoziming.github.io/post/211010-ubuntu%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211010-ubuntu%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>ubuntu常用操作  ubuntu 屋奔兔，算是最常見的Linux系統
 // 解壓縮XX檔案到/usr/local sudo tar -C /usr/local -xzvf go1.17.1.linux-amd64.tar.gz
// 文字編輯器 sudo gedit /home/yoziming/.config/go/env
// 檔案總管 sudo nautilus
// 啟用go mod go env -w GO111MODULE=on</description>
    </item>
    
    <item>
      <title>Kubernetes基礎認識</title>
      <link>https://yoziming.github.io/post/211006-k8s/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211006-k8s/</guid>
      <description>Kubernetes基礎認識  自動化地以容器的形式管理你的應用程式 To host your application in the form of containers in a automated fashion
 名詞解釋   Cluster:集群，計算、儲存資源的集合。一個Cluster通常包含一個Controller Plane和數個Node，視需求而定(也可能有Multi-Controller Plane 的集群)
 Controller Plane:(以前叫Mater)控制主節點，調度指揮所  APIserver:管理整個 K8s 所需 API 的接口(Endpoint)，提供HTTP Rest介面的關鍵服務處理程序，是集群中各個節點的溝通橋樑 etcd:存資料 Scheduler:資源調配，例如調度Pod運行在哪個Node Controller-manager:總經理，負責管理並運行 controller ，controller定義各種Pod的部屬特性(如最常用的Deployment)來滿足不同的業務場景   Node:節點，讓物件(resource-objects)運行的實體或虛擬機器  kubelet:對應api-server的接口，可以看成每個Node上的&amp;quot;實際執行者&amp;quot;或&amp;quot;操作者&amp;quot;，負責接收來自api-server的訊息，並做出相對應的動作，例如，負責Pod對應的容器的建立、啟動或停止等。 kube-proxy:維護網路規則(iptables)，這些規則允許從群集內部或外部的與Pod進行通訊。 Container Runtime:容器的運行引擎，預設是Docker，也支援其他滿足CRI標準的。  Pod:可被調度的最小單位，每個Pod包含一或多個容器，Pod內共享生命週期、資源、通信(使用同一個網路namespace，即相同的IP與port)、儲存空間。通常使用是一個Pod中放一個容器；當需要高度共享資源時才會用一個Pod內多個容器的形式      延伸觀念  Deployment:部屬，例如把Pod做橫向擴展，適用自動管理，或達成無停機系統升級 Service:服務，Deployment可以部屬多個Pod，每個Pod都有自己的IP，隨時都在生滅浮動，外界如何訪問? 答案就是透過Service，可以說Controller負責運行Pod，而Service負責訪問Pod。 Ingress:Service 中是將每個 Service 元件對外的 port number 跟 Node 上的 port number 做 mapping，這樣在我們的 Service 變多時，port number 以及分流規則的管理變得相當困難。而 Ingress 可以透過 HTTP/HTTPS，在我們眾多的 Service 前搭建一個 reverse-proxy。這樣 Ingress 可以幫助我們統一一個對外的 port number，並且根據 hostname 或是 pathname 決定封包要轉發到哪個 Service 上 Namespace:命名空間，假如有多個用戶使用同一個Cluster，想把他們創建的Controller、Pod等資源分開，就靠Namespace。Namespace將物理的Cluster從邏輯上切成多個虛擬Cluster，每一個虛擬Cluster就是一個Namespace，不同Namespace中的資源完全隔離。K8s默認創建2個Namespace:  default:如果不指定，資源就預設放這 kube-system:K8s自己創建的系統資源會放在這個Namespace中      </description>
    </item>
    
    <item>
      <title>MySQL常用語句 &amp; Workbench</title>
      <link>https://yoziming.github.io/post/211005-mysql-%E5%B8%B8%E7%94%A8%E8%AA%9E%E5%8F%A5/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211005-mysql-%E5%B8%B8%E7%94%A8%E8%AA%9E%E5%8F%A5/</guid>
      <description>MySQL 常用語句 資料庫database
create database XXX;show databases;use XXX;drop database XXX;資料表table
create table mytable(school char(5),name char(10),id int);show tables;describe mytable; // 顯示這表有哪些欄位跟屬性drop table mytable;select * from mytable; // 顯示mytable中所有資料insert into mytable(school, name, id) values (&#39;NCTU&#39;,&#39;Jerry&#39;,&#39;123&#39;);insert into mytable values (&#39;NCTU&#39;,&#39;Jerry&#39;,&#39;123&#39;);update mytable set name = &#39;HaHa&#39; where id = &#39;123&#39;;delete from mytable where name = &#39;HaHa&#39;;delete from 表格; // 把表格內資料都刪除(但格式宣告還在)select * from mytable where id = &#39;123&#39; order by name DESC; // 資料表查詢+條件+排序 (DESC 代表由大到小排序)load data local infile &amp;quot;c:\\data.</description>
    </item>
    
    <item>
      <title>Docker啟用Redis</title>
      <link>https://yoziming.github.io/post/211002-docker%E5%95%9F%E7%94%A8redis/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211002-docker%E5%95%9F%E7%94%A8redis/</guid>
      <description>Docker啟用Redis 抓映象檔 docker pull redis:6.0 拉一個6.0版本的redis  執行 Image docker run --name redis6 -p 6379:6379 -d redis:6.0 redis-server --appendonly yes –name redis6 ：將 Container 取名為 redis6 -p 6379:6379 ：將 Container 的 6379 Port 映射到主機的 6379 Port (前面代表主機，後面代表容器) -d :後台執行 Container ，並返回ID redis-server –appendonly yes : 在 Container 執行 redis-server 啟動命令，並打開redis持久化配置  進入 Container docker exec -it redis6 bash -i ：即使沒有附加也保持STDIN 打開 -t ：分配一個偽終端  資料庫測試 redis-cliset hello worldget hello</description>
    </item>
    
    <item>
      <title>Docker啟用Mysql</title>
      <link>https://yoziming.github.io/post/211001-docker%E5%95%9F%E7%94%A8mysql/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211001-docker%E5%95%9F%E7%94%A8mysql/</guid>
      <description>Docker啟用Mysql 抓映象檔 docker pull mysql/mysql-server:8.0 拉一個8.0版本的mysql  執行 Image docker run -d -it --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=mydb mysql:8 --default-authentication-plugin=mysql_native_password -d：同--detach，以背景模式執行。 -v ~/mysql-docker-data:/var/lib/mysql：同--volume，掛載host目錄到container目錄，也就是host的~/mysql-docker-data會保存container /var/lib/mysql的資料；windos docker app這樣做的話，資料是暫時的重開機後會不見。 -it：同--interactive加--tty，作用為運行container時可登入其bash操作。 --name mysql8，命名container名稱為mysql8。 -p：同--publish。作用為將container的3306 port對映到&amp;quot;主機(host)&amp;ldquo;的3306 port -e：同--env，設定環境變數。MYSQL_ROOT_PASSWORD設定MySQL root帳號的登入密碼為1234，MYSQL_DATABASE設定資料庫名稱為mydb。 mysql:8：mysql為image名稱，8為image tag。所以運行的是mysql:8的image。 --default-authentication-plugin=mysql_native_password：把儲存密碼的方式改為MySQL 5的mysql_native_password，因為MySQL 8的儲存方式預設為caching_sha2_password，但一些免費的MySQL client圖形工具如Sequel Pro，Navicat等會無法連線，所以設定此參數。  檢視運行中的容器 docker ps進入 Container docker exec mysql8 mysql -u root -p docker exec指令的作用為在運行的container執行指令，所以意思就是在mysql8這個container執行mysql -u root -p的指令。  docker container exec -it mysql8 /bin/bash 遇到權限問題用這個  進入Mysql mysql -uroot -p新增 1 個開放外部連線的帳號 CREATE USER &#39;user01&#39;@&#39;%&#39; IDENTIFIED BY &#39;1234&#39;;GRANT ALL ON your_database.</description>
    </item>
    
    <item>
      <title>Docker常用語句</title>
      <link>https://yoziming.github.io/post/210930-docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210930-docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>Docker常用語句 抓映象檔 docker pull xxx檢視運行中的容器 docker ps進入 Container docker exec -it &amp;lt;container_id&amp;gt; /bin/bash -i ：即使沒有附加也保持STDIN 打開 -t ：分配一個偽終端  查看字元編碼 locale臨時改成UTF8 export LANG=&amp;quot;en_US.UTF-8&amp;quot;  永久設置需在Dockerfile中設置環境字元集環境變數
ENV LANG=&amp;quot;en_US.UTF-8&amp;quot;  </description>
    </item>
    
    <item>
      <title>Docker啟用MinIO</title>
      <link>https://yoziming.github.io/post/210929-docker%E5%95%9F%E7%94%A8minio%E5%84%B2%E5%AD%98/</link>
      <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210929-docker%E5%95%9F%E7%94%A8minio%E5%84%B2%E5%AD%98/</guid>
      <description>Docker啟用MinIO儲存 執行 Image docker run -d --name minio -e &amp;quot;MINIO_ROOT_USER=root&amp;quot; -e &amp;quot;MINIO_ROOT_PASSWORD=root1234&amp;quot; -p 9000:9000 -p 9001:9001 minio/minio server /data --console-address &amp;quot;:9001&amp;quot;  --name minio，命名container名稱為minio。 -v /data/minio:/data/minio該命令將主機 /data/minio 目錄對映到容器中的 /data/minio 目錄中 MinIO 還提供了圖形管理介面，在瀏覽器輸入 ip:9001即可檢視 不管是圖形介面操作，還是客戶端操作，預設賬號密碼都為 minioadmin -e環境變數，這裡用了自定義賬號密碼，賬號不能小於 3 字元，密碼不能小於 8 字元  Go初始化 導入github.com/minio/minio-go/v7，注意這個後面的v7，在自動引包時可能會漏掉，導致使用到舊版的同名函數而報錯
func InitMinio() { ctx := context.Background() endpoint := &amp;#34;localhost:9000&amp;#34; accessKeyID := &amp;#34;root&amp;#34; secretAccessKey := &amp;#34;root1234&amp;#34; useSSL := false // Initialize minio client object. 	minioClient, err := minio.</description>
    </item>
    
    <item>
      <title>consul基礎使用練習</title>
      <link>https://yoziming.github.io/post/210928-consul%E4%BD%BF%E7%94%A8%E7%B7%B4%E7%BF%92/</link>
      <pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210928-consul%E4%BD%BF%E7%94%A8%E7%B7%B4%E7%BF%92/</guid>
      <description>consul基礎使用練習  想像去郵局辦事，consul類似於發號碼牌的那個機器
伺服端(櫃台人員)去找consul註冊服務，比如說櫃台1~3提供儲蓄，櫃台4~6提供郵寄服務
客戶進來透過服務發現，把要辦的事丟給consul，它查看哪個櫃台健康，幫你匹配對應的服務或叫號
(感覺這例子不太完善，就&amp;hellip;類似的理解啦，實際用了才會懂)
   下載
# 官網:https://www.consul.io/downloads# ubuntu shell: (下載&amp;gt;解壓縮&amp;gt;把二進位執行檔丟進去)wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zipunzip consul_1.10.3_linux_amd64.zipsudo mv consul /usr/local/bin/  測試
consul -h  啟動server
consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=192.168.234.128 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0這個IP=192.168.234.128=ubuntu的ip
*若/etc/consul.d/不存在要先自己創
  查看服務
http://192.168.234.128:8500/  註冊自訂的健康檢查服務，範例:
剛剛自訂的配置檔路徑/etc/consul.d/下新增一個web.json
{&amp;quot;service&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;web&amp;quot;,&amp;quot;tags&amp;quot;: [&amp;quot;extract&amp;quot;, &amp;quot;verify&amp;quot;, &amp;quot;compare&amp;quot;, &amp;quot;idcard&amp;quot;],&amp;quot;address&amp;quot;: &amp;quot;192.168.234.128&amp;quot;,&amp;quot;port&amp;quot;: 9000,&amp;quot;check&amp;quot;: {&amp;quot;id&amp;quot;: &amp;quot;api&amp;quot;,&amp;quot;name&amp;quot;: &amp;quot;HTTP API on port 9000&amp;quot;,&amp;quot;http&amp;quot;: &amp;quot;http://localhost:9000&amp;quot;,&amp;quot;interval&amp;quot;: &amp;quot;10s&amp;quot;,&amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;}}}  重啟server並查看服務</description>
    </item>
    
    <item>
      <title>Golang下透過grpc調用服務案例</title>
      <link>https://yoziming.github.io/post/210927-grpc/</link>
      <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210927-grpc/</guid>
      <description>Golang下透過grpc調用服務案例  grpc簡單說就是跨平台(跨語言)調用各種服務的通用轉接口
 對.proto文件使用轉譯指令:
protoc --go_out=plugins=grpc:. *.proto 案例:透過grpc遠程傳遞一個調用teacher資料類型的服務
 .proto:
syntax=&amp;quot;proto3&amp;quot;;option go_package=&amp;quot;/.;pb&amp;quot;;message Teacher{int32 age=1;string name=2;}service SayName{rpc SayHello(Teacher) returns(Teacher);}server:
type Children struct{}// 綁定類方法func (c *Children) SayHello(ctx context.Context, t *pb.Teacher) (*pb.Teacher, error) {t.Name += &amp;quot;is sleeping&amp;quot;return t, nil}func main() {// 初始一個grpc對象grpcServer := grpc.NewServer()// 註冊服務pb.RegisterSayNameServer(grpcServer, new(Children))// 監聽listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.</description>
    </item>
    
    <item>
      <title>Golang中使用ProtoBuf</title>
      <link>https://yoziming.github.io/post/210926-golang%E4%B8%8B%E4%BD%BF%E7%94%A8protobuf/</link>
      <pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210926-golang%E4%B8%8B%E4%BD%BF%E7%94%A8protobuf/</guid>
      <description>Golang中使用ProtoBuf  protobuf類似json，它體積更小效率更高，規範統一(沒有大小寫等困擾)。
缺點是改動協議就要重新生成、數據本身是二進位沒有可讀性
   下載，window系統選.exe，解壓縮放到$GOPATH/bin
https://github.com/protocolbuffers/protobuf/releases  安裝golang對應的庫跟插件
go get github.com/golang/protobuf/protogo get github.com/golang/protobuf/protoc-gen-go  測試
protoc -h 或 protoc --version沒報錯就是成功
  消息體舉例，xxx.proto
// 指定版本，不打3就會是2syntax=&amp;quot;proto3&amp;quot;;// 指定輸出位置&amp;amp;go包名，沒寫轉換不了// option go_package =&amp;quot;path;name&amp;quot;;option go_package =&amp;quot;/.&amp;quot;; // 放在同一目錄下包名為__(空)// 定義消息體，分配唯一編號 (不能用19000~19999)message Student{int32 age = 1; // 可以不從1開始，但不可重複string name = 2;People p=3;repeated int32 score=4; // 數組Week w=5;// 聯合體oneof data{string teacher=6;string class=7;}}// 消息體可以嵌套message People{int32 weight=1;}// 定義枚舉類型enum Week{Monday=0; // 必須從0開始Turesday=1;}  生成go文件</description>
    </item>
    
    <item>
      <title>GitHub&#43;Hugo自建簡單Blog流程</title>
      <link>https://yoziming.github.io/post/210926-bulidblogwithhugo/</link>
      <pubDate>Sun, 26 Sep 2021 02:01:58 +0530</pubDate>
      
      <guid>https://yoziming.github.io/post/210926-bulidblogwithhugo/</guid>
      <description>流程  看了很多教學各種語法不太會用、高級的自動部署、netlify後台等等，學半天卻老是在一些關鍵點卡住而進行不不了。我這個土路雖然又蠢又笨但確實能做出東西，同樣新手可以試試。
   安裝Chocolatey //程式安裝器，讓你從終端裝各種東西很方便
https://chocolatey.org/install到這個網址，官方提供很多方法安裝，非常簡單快速一行搞定安裝hugo，有些佈景主題要用到加強版(extended)
choco install hugo -confirmchoco install hugo-extended -confirm  hugo new site &amp;lt;資料夾名稱&amp;gt; //建立一個root，相當於你個人網站的原始資料母巢
  挑主題，到https://themes.gohugo.io/
  套用主題，範例
 cd &amp;lt;資料夾名稱&amp;gt;git initgit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary  依照主題的說明文件修改根目錄下的config.toml 注意，config.toml中的第一項baseURL網址不要有&amp;quot;https://www.ooxx&amp;quot;，否則會造成一些未知的BUG。正確網址應為&amp;quot;https://你的username.github.io/&amp;quot;
  到content/post/下開始寫一篇blog
  開啟本地預覽，指令hugo server -F //防止時差問題用-F
  隨意一個地方開啟網址http://localhost:1313/ 看看網站
  網站沒問題就打包，指令hugo，會在root資料夾下多出一個public資料夾，裡面就是一個完整的網站準備丟去網路上發布
  去gitHub建一個Repository(倉庫)，名稱強制為 你的username.github.io
  下載GitHub Desktop客戶端，可以把他理解成一個雲端，我要把本地public資料夾的內容透過它丟去gitHub上剛剛建的那個Repository(倉庫)裡，之後就能透過網站提供的gitPage功能實現個人網站的搭建</description>
    </item>
    
    <item>
      <title>圖片測試</title>
      <link>https://yoziming.github.io/post/210925-imagetest/</link>
      <pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210925-imagetest/</guid>
      <description> 圖片1 使用建立新資料夾後的相對路徑   圖片2 使用\static\images\之下的資源   圖片3  </description>
    </item>
    
    <item>
      <title>MVC &amp; Microservices</title>
      <link>https://yoziming.github.io/post/210910-mvc-microservices/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210910-mvc-microservices/</guid>
      <description>MVC架構 Model:模型，管理資料庫(增刪改查)、業務邏輯、物件結構定義
View:視圖，使用者實際在看、操作的介面(UI)，前端
Controller:控制，接收請求、回覆結果，決定工作流程，算是Model跟View的中間人
微服務架構（Microservices）  單一職責:把業務邏輯拆分成無數個小區塊(Blocks)，負責單一任務，服務之間透過管道來通訊。 輕量級通訊:使用不依賴語言或平台的格式，例如XML、JSON、protobuf。通常基於HTTP協議、符合REST風格來達成標準化、無狀態化。 獨立開發、測試、部屬:顧名思義，都拆開了就可以分開做，不像傳統架構牽一髮而動全身。 容器化:微服務既然能獨立作業了，就可以放到容器(Container)中，互相隔離互不干擾，達成快速部署、節省資源。Docker是目前最普遍的容器技術，Kubernetes(K8s)是常用來管理容器、協調整合的平台。  </description>
    </item>
    
    <item>
      <title>一次性隊列</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/</guid>
      <description>一次性隊列 //用結構體管理隊列type Queue struct {maxSize intarray [3]intfront int //隊列首(不包含)rear int //隊尾(含)}//添加數據val到隊列func (q *Queue) AddQueue(val int) (err error) {//先判斷是否已滿if q.rear == q.maxSize-1 {return errors.New(&amp;quot;queue full&amp;quot;)}q.rear++q.array[q.rear] = valreturn}//取出數據func (q *Queue) GetQueue() (val int, err error) {//先判斷是否為空if q.rear == q.front {return -1, errors.New(&amp;quot;queue empty&amp;quot;)}q.front++val = q.array[q.front]return val, err}//顯示隊列func (q *Queue) ShowQueue() {fmt.</description>
    </item>
    
    <item>
      <title>二分樹的3種遍歷</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/</guid>
      <description>二分樹的3種遍歷 package mainimport &amp;quot;fmt&amp;quot;type Hero struct {No intName stringLeft *HeroRight *Hero}//前序遍歷 先輸出root 再輸出左子樹 再輸出右子樹，會中左右一層層往下func PreOrder(node *Hero) {if node != nil {fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)PreOrder(node.Left)PreOrder(node.Right)}}//中序遍歷 左子樹 root 右子樹func InfixOrder(node *Hero) {if node != nil {InfixOrder(node.Left)fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)InfixOrder(node.Right)}}//後序遍歷 左子樹 右子樹 root，會一路到最左最下開始打func PostOrder(node *Hero) {if node !</description>
    </item>
    
    <item>
      <title>哈希表數據結構</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/</guid>
      <description>哈希表數據結構 package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;os&amp;quot;)type Emp struct {Id intName stringNext *Emp}func (e *Emp) ShowMe() {fmt.Printf(&amp;quot;链表%d 找到该雇员 %d\n&amp;quot;, e.Id%7, e.Id)}//不帶表頭，即第一個節點就放雇員資料type EmpLink struct {Head *Emp}func (e *EmpLink) FindByIdEmpLink(id int) *Emp {cur := e.Headfor {if cur != nil &amp;amp;&amp;amp; cur.Id == id {return cur} else if cur == nil {break}cur = cur.</description>
    </item>
    
    <item>
      <title>單向鏈表</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>單向鏈表 type HeroNode struct {no intname stringnext *HeroNode //表示指向下一個節點}//給鏈表插入節點func Insert(head *HeroNode, newHeroNode *HeroNode) {//先找到最後的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break}temp = temp.next //不斷往下找}//把newHeroNode加到屁股temp.next = newHeroNode}//根據No從小到大插入func InsertNo(head *HeroNode, newHeroNode *HeroNode) {//想找到適當的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break} else if temp.next.no &amp;gt; newHeroNode.no {//表示new要插到temp後break} else if temp.</description>
    </item>
    
    <item>
      <title>插入&amp;選擇&amp;快速排序</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E6%8F%92%E5%85%A5%E9%81%B8%E6%93%87%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E6%8F%92%E5%85%A5%E9%81%B8%E6%93%87%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>插入&amp;amp;選擇&amp;amp;快速排序 //選擇排序func SelectSort(array *[6]int) {for j := 0; j &amp;lt; len(array)-1; j++ {min := array[j]minIndex := j//尋找最小的下標for i := j + 1; i &amp;lt; len(array); i++ {if min &amp;gt; array[i] {min = array[i]minIndex = i}}if minIndex != j {array[j], array[minIndex] = array[minIndex], array[j]}fmt.Printf(&amp;quot;第%d次交換後 %v\n&amp;quot;, j+1, *array)}}//插入排序func InsertSort(arr *[6]int) {for j := 1; j &amp;lt; len(arr); j++ {//給第二個元素找位置insertVal := arr[j]insertIndex := j - 1 //下標//由大到小for insertIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[insertIndex] &amp;lt; insertVal {arr[insertIndex+1] = arr[insertIndex] //數據後移insertIndex--}//插入if insertIndex+1 !</description>
    </item>
    
    <item>
      <title>模擬棧&amp;四則運算</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E6%A8%A1%E6%93%AC%E6%A3%A7%E5%9B%9B%E5%89%87%E9%81%8B%E7%AE%97/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E6%A8%A1%E6%93%AC%E6%A3%A7%E5%9B%9B%E5%89%87%E9%81%8B%E7%AE%97/</guid>
      <description>模擬棧&amp;amp;四則運算 //模擬棧的使用type Stack struct {MaxTop int //最大可存個數Top int //頂arr [20]int}func (s *Stack) Push(val int) (err error) {//先判斷是否滿if s.Top == s.MaxTop-1 {fmt.Println(&amp;quot;stack full&amp;quot;)return errors.New(&amp;quot;stack full&amp;quot;)}//放入數據s.Top++s.arr[s.Top] = valreturn}func (s *Stack) Pop() (val int, err error) {//先判斷是否空if s.Top == -1 {fmt.Println(&amp;quot;stack empty&amp;quot;)return 0, errors.New(&amp;quot;stack empty&amp;quot;)}//彈出數據val = s.arr[s.Top]s.Top--return val, nil}//遍歷func (s *Stack) List() {//先判斷是否空if s.</description>
    </item>
    
    <item>
      <title>環形單向鏈表</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E7%92%B0%E5%BD%A2%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E7%92%B0%E5%BD%A2%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>環形單向鏈表 type CatNode struct {no intname stringnext *CatNode}func Insert(head *CatNode, newCatNode *CatNode) {//判斷是否第一隻貓if head.next == nil {head.no = newCatNode.nohead.name = newCatNode.namehead.next = head //構成環形fmt.Println(*newCatNode, &amp;quot;已初始化並加入環形鏈表&amp;quot;)return}//定義一個變量找到環形最後一個temp := headfor {if temp.next == head {break}temp = temp.next}temp.next = newCatNodefmt.Println(*newCatNode, &amp;quot;已加入環形鏈表&amp;quot;)newCatNode.next = head}func Del(head *CatNode, id int) *CatNode {temp := headhelper := headif temp.</description>
    </item>
    
    <item>
      <title>稀疏數組</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E7%A8%80%E7%96%8F%E6%95%B8%E7%B5%84/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E7%A8%80%E7%96%8F%E6%95%B8%E7%B5%84/</guid>
      <description>稀疏數組 type ValNode struct {row int //橫的col int //直的val int}func main() {//創建數組範例var chessMap [11][11]intchessMap[1][2] = 1chessMap[2][3] = 2//輸出看樣子for _, v := range chessMap {for _, v2 := range v {fmt.Printf(&amp;quot;%d\t&amp;quot;, v2)}fmt.Println()}//轉成稀疏數組，思路:遍歷他，創造一個結構體，發現有值就放進對應的切片var sparseArr []ValNode//紀錄規模跟預設值valNode0 := ValNode{row: 11,col: 11,val: 0,}sparseArr = append(sparseArr, valNode0)for i, v := range chessMap {for j, k := range v {if k !</description>
    </item>
    
    <item>
      <title>約瑟夫問題</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E7%B4%84%E7%91%9F%E5%A4%AB%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E7%B4%84%E7%91%9F%E5%A4%AB%E5%95%8F%E9%A1%8C/</guid>
      <description>約瑟夫問題 type Boy struct {No intNext *Boy //指向下一個小孩的指針}func addBoy(num int) *Boy {//num表示小孩的個數，*Boy返回第一個小孩的指針first := &amp;amp;Boy{}temp := &amp;amp;Boy{}if num &amp;lt; 1 {fmt.Println(&amp;quot;num值錯誤&amp;quot;)return first}for i := 1; i &amp;lt;= num; i++ {boy := &amp;amp;Boy{No: i,}if i == 1 {first = boy //不變temp = boytemp.Next = first} else {temp.Next = boytemp = boytemp.</description>
    </item>
    
    <item>
      <title>迷宮遞迴</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/</guid>
      <description>迷宮遞迴 func SetWay(myMap *[8][7]int, a int, b int) bool {//a,b 表示對地圖的那個點測試//找到出口if myMap[6][5] == 2 {return true} else {//繼續找if myMap[a][b] == 0 { //可探測的點myMap[a][b] = 2 //踩上去了，再探上下左右，但是我知道要往下往右探if SetWay(myMap, a+1, b) { //下return true} else if SetWay(myMap, a, b+1) { //右return true} else if SetWay(myMap, a-1, b) { //上return true} else if SetWay(myMap, a, b-1) { //左return true} else { //死路myMap[a][b] = 3return false}} else { //不可探測的點return false}}}func main() {//定義地圖 1=牆壁 0=沒走過的點 2=通路 3=走過的死路var myMap [8][7]int//四周設置圍牆for i := 0; i &amp;lt; 7; i++ {myMap[0][i] = 1myMap[7][i] = 1}for i := 0; i &amp;lt; 8; i++ {myMap[i][0] = 1myMap[i][6] = 1}myMap[3][1] = 1myMap[3][2] = 1//看樣子for i := 0; i &amp;lt; 8; i++ {for j := 0; j &amp;lt; 7; j++ {fmt.</description>
    </item>
    
    <item>
      <title>雙向鏈表</title>
      <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>雙向鏈表 type HeroNode struct {no intname stringpre *HeroNode //表示指向前一個節點next *HeroNode //表示指向下一個節點}//給鏈表插入節點func Insert(head *HeroNode, newHeroNode *HeroNode) {//先找到最後的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break}temp = temp.next //不斷往下找}//把newHeroNode加到屁股temp.next = newHeroNodenewHeroNode.pre = temp}//根據No從小到大插入func InsertNo(head *HeroNode, newHeroNode *HeroNode) {//想找到適當的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break} else if temp.</description>
    </item>
    
    <item>
      <title>channel通道</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-channel%E9%80%9A%E9%81%93/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-channel%E9%80%9A%E9%81%93/</guid>
      <description>channel通道 lock sync與chan基本認識 //階乘1-n 把各個數放到map中 用goroutine完成var (myMap = make(map[int]int, 10)//聲明一個全局的互斥鎖lock sync.Mutex//來點管道 記得要make初始化才能用intChan chan int = make(chan int, 3)//聲明類型為空接口可以接收任意類型allChan chan interface{} = make(chan interface{}, 5)//注意後面沒聲明容量則不給用)type Cat struct {Name stringAge int}func test(n int) {res := 1for i := 1; i &amp;lt;= n; i++ {res = res * i}//把res放進mayMap//加鎖lock.Lock()myMap[n] = res//解鎖lock.</description>
    </item>
    
    <item>
      <title>const常量</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-const%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-const%E5%B8%B8%E9%87%8F/</guid>
      <description>const常量  常量 聲明時必須賦值、不能修改、只能是bool、數值、string，賦值需是一個確定的值
 func main() {const tax int = 10const x = 9 / 3// const c = 9 / a //因為a可能是一個變量所以這樣不行// var a int = 3fmt.Println(tax, x)const (a = iota //表示a=0b //b=a+1c //c=b+1)fmt.Println(a, b, c)const (d = iotaef, g = iota, iota)fmt.Println(d, e, f, g)//其他程式語言常量會用全大寫，go中沒限制，且一樣用首字母大小來控制使用範圍}</description>
    </item>
    
    <item>
      <title>defer臨走前啟用</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-defer%E8%87%A8%E8%B5%B0%E5%89%8D%E5%95%9F%E7%94%A8/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-defer%E8%87%A8%E8%B5%B0%E5%89%8D%E5%95%9F%E7%94%A8/</guid>
      <description>defer臨走前啟用  退出函數前才執行
 func sum(n1, n2 int) int {defer fmt.Println(&amp;quot;ok1&amp;quot;, n1)defer fmt.Println(&amp;quot;ok2&amp;quot;, n2)//defer棧先入後出n1++n2++res := n1 + n2fmt.Println(&amp;quot;ok3 res=&amp;quot;, res)return res}func main() {res := sum(10, 20)fmt.Println(&amp;quot;res=&amp;quot;, res)}</description>
    </item>
    
    <item>
      <title>goroutine</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-goroutine%E4%B8%A6%E7%99%BC/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-goroutine%E4%B8%A6%E7%99%BC/</guid>
      <description>goroutine  進程=程序在操作系統中的一次進行過程
線程=執行實例的最小單位
  一個進程可以創建多個線程且併發執行 一個程序至少包含一個進程，一個進程至少包含一個線程 併發=多線程程序在單核上運行 併行=多線程程序在多核上運行  GO的主線程(可以理解為進程)，一個GO進程上可以起很多協程，協程可以理解為輕量級的線程，協程特點:
 有獨立的棧空間 共享程序堆空間 調度由用戶控制 為輕量級的線程  func test() {for i := 0; i &amp;lt; 10; i++ {fmt.Println(&amp;quot;test()Hello,world&amp;quot; + strconv.Itoa(i))time.Sleep(time.Second / 10)}}func main() {go test() //開啟一個協程//如果主線程退出了，即使協程還沒執行完，也會退出//協程可以自己先結束for i := 0; i &amp;lt; 10; i++ {fmt.Println(&amp;quot;main()Hello,go&amp;quot; + strconv.Itoa(i))time.Sleep(time.Second / 10)}go test() //開啟一個協程，主線程退出了，即使協程還沒執行完，也會退出//查邏輯CPU數量cpuNum := runtime.NumCPU()fmt.Println(cpuNum)//設置最大線程數量runtime.</description>
    </item>
    
    <item>
      <title>Go使用mysql與事務操作</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-go%E4%BD%BF%E7%94%A8mysql%E8%88%87%E4%BA%8B%E5%8B%99%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-go%E4%BD%BF%E7%94%A8mysql%E8%88%87%E4%BA%8B%E5%8B%99%E6%93%8D%E4%BD%9C/</guid>
      <description>Go使用mysql與事務操作 基本操作 import (&amp;quot;database/sql&amp;quot;&amp;quot;fmt&amp;quot;_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;)var db *sql.DB // 是一個連接池對象// user 接收數據type user struct {id intname stringage int}func initDB() (err error) {dsn := &amp;quot;root:root@tcp(127.0.0.1:3306)/sql_test&amp;quot;db, err = sql.Open(&amp;quot;mysql&amp;quot;, dsn) // 這個db要用全局的，重要!if err != nil {return}err = db.Ping()if err != nil {return} else {fmt.Println(&amp;quot;連接成功&amp;quot;)}return}// 查詢一個func find1() {var u1 usersqlStr := `select id, name, age from user where id=?</description>
    </item>
    
    <item>
      <title>JSON序列化</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-json%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-json%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>JSON序列化  JSON 格式 {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:&amp;ldquo;值2&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:[&amp;ldquo;值2數組&amp;rdquo;,值2數組]}
 type Monster struct {Name string `json:&amp;quot;name&amp;quot;` //反射機制Age int `json:&amp;quot;age&amp;quot;`Sal float64 `json:&amp;quot;sal&amp;quot;`}func test1() {monster1 := Monster{Name: &amp;quot;牛魔王&amp;quot;,Age: 50,Sal: 8000.0,}data, err := json.Marshal(&amp;amp;monster1)if err != nil {fmt.Println(err)}fmt.Println(string(data))}//把map序列化func testMap() {var mapA map[string]interface{} = make(map[string]interface{})mapA[&amp;quot;name&amp;quot;] = &amp;quot;紅孩兒&amp;quot;mapA[&amp;quot;age&amp;quot;] = 18data, err := json.Marshal(&amp;amp;mapA)if err !</description>
    </item>
    
    <item>
      <title>Map集合</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-map%E9%9B%86%E5%90%88/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-map%E9%9B%86%E5%90%88/</guid>
      <description>Map集合 func main() {// map[key類型] value類型var m1 map[int]int = make(map[int]int)//key類型通常是int or string//value 通常是數字 or string or map or struct//只聲明不會給內存，要make才初始化才能用(跟切片一樣)m1[1] = 100m1[2] = 200m1[3] = 300m1[1] = 1000//key不能重複，後賦予的頂掉前面fmt.Println(m1)var m2 = make(map[string]string)m2[&amp;quot;AV&amp;quot;] = &amp;quot;sss&amp;quot;fmt.Println(m2)//推薦寫法m3 := make(map[string]string)m3[&amp;quot;一號&amp;quot;] = &amp;quot;台北&amp;quot;m3[&amp;quot;二奧&amp;quot;] = &amp;quot;桃園&amp;quot;fmt.Println(m3)m4 := map[int]int{1: 10, 2: 20, 3: 30}fmt.Println(m4)//學生姓名+性別m5 := make(map[string](map[string]string))m5[&amp;quot;stu01&amp;quot;] = make(map[string]string) //不能少m5[&amp;quot;stu01&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;tom&amp;quot;m5[&amp;quot;stu01&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;男&amp;quot;m5[&amp;quot;stu02&amp;quot;] = make(map[string]string) //不能少m5[&amp;quot;stu02&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;mary&amp;quot;m5[&amp;quot;stu02&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;女&amp;quot;fmt.</description>
    </item>
    
    <item>
      <title>new與make的區別</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-new%E8%88%87make%E7%9A%84%E5%8D%80%E5%88%A5/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-new%E8%88%87make%E7%9A%84%E5%8D%80%E5%88%A5/</guid>
      <description>func main() {num1 := 100fmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num1, num1, &amp;amp;num1)num2 := new(int) //*intfmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num2, num2, &amp;amp;num2)//new用來分配類型//make用來分配內存}</description>
    </item>
    
    <item>
      <title>Redis基本操作</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-redis%E5%9F%BA%E7%A4%8E/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-redis%E5%9F%BA%E7%A4%8E/</guid>
      <description>Redis基本操作 0.啟動cmd&amp;gt;redis-cli
1.數據結構類似JSON都是Key-Value
2.五大數據類型String、Hash、List、Set、Zset
2-1.String:最基本的字串，value最大值=512M
指令:set(如果存在就相當於修改)、get、del (很多指令可以用tab協助完成)
setex(幾秒後自毀)
2-2.Hash:類似於Map
指令:hset key field value、hget、hdel
一次設多項(空格隔開)hmset、hmget
hlen:統計有幾個元素
hexists:看field是否存在
2-3.List:是個有序的鏈表，元素的值可以重複，可以把東西加在頭或尾
指令:lpush 從左往管子裡塞東西，一直推擠過去
lrange 0 end (最左是0 1 2 3&amp;hellip;，也可以用負數 -1表示最後一個 -2表示倒數第2
比如說lrange 0 -1 =從左開始全顯示
rpush 從右邊加東西 (就順序上來說比較習慣)
lpop / rpop 從左或右取出數據(彈走了)
del key 刪掉就沒了
lindex 按照索引下標獲得元素(從左到右0開始)
llen 長度
2-4.Set:String類型的無序集合(元素的值不能重複)
舉例 存放email不該重複 (重複加了無效)
指令saad
smembers 印出所有值
sismember 判斷值是否成員
srem 刪除指定值</description>
    </item>
    
    <item>
      <title>Reflect反射</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-reflect%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-reflect%E5%8F%8D%E5%B0%84/</guid>
      <description>reflect反射 func reflectTest01(b interface{}) {//通過反射獲取傳入的各種訊息//先拿reflect.TyperType := reflect.TypeOf(b)fmt.Println(&amp;quot;rType=&amp;quot;, rType)rVal := reflect.ValueOf(b)fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)// n1:=10+rVal //rVal他看起來是int但其實是type reflect.Valuen1 := 10 + rVal.Int() //用.Int()轉換後就可以了// n3 := rVal.Float()//像這樣也不行的，一定要確認類型fmt.Println(&amp;quot;n1=&amp;quot;, n1)// fmt.Println(&amp;quot;n3=&amp;quot;, n3)//把rVal轉回interface{}iV := rVal.Interface()n2 := iV.(int)fmt.Println(&amp;quot;n2=&amp;quot;, n2)}func reflectTest02(b interface{}) {//通過反射獲取傳入的各種訊息//先拿reflect.TyperType := reflect.TypeOf(b)fmt.Println(&amp;quot;rType=&amp;quot;, rType)rVal := reflect.ValueOf(b)fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)//把rVal轉回interface{}iV := rVal.Interface()//斷言回來n2, ok := iV.</description>
    </item>
    
    <item>
      <title>RPC</title>
      <link>https://yoziming.github.io/post/210927-rpc/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210927-rpc/</guid>
      <description>server / 用接口，讓服務端註冊RPC的時候，就能確保他合法type World struct{}func (w *World) HelloWorld(name string, resp *string) error {*resp = name + &amp;quot;你好&amp;quot;return nil// 如果這個return的返回值不為空，// 那無論傳出的參數是否有值，服務端都不會給東西// (就你給你error)}// 用接口，讓服務端註冊RPC的時候，就能確保他合法type MyInerface interface {HelloWorld(string *string) error}// 調用方法時，給i傳參，參數是實現HelloWorld方法的對象func RegsiterService(i MyInerface) {rpc.RegisterName(&amp;quot;hello&amp;quot;, i)}func main() {// 1.註冊RPC服務 綁定對象方法err := rpc.RegisterName(&amp;quot;hello&amp;quot;, new(World))if err != nil {fmt.Println(&amp;quot;註冊RPC服務失敗&amp;quot;, err)}// 2.開始監聽listener, err := net.</description>
    </item>
    
    <item>
      <title>Split切分字串</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-split%E5%88%87%E5%88%86%E5%AD%97%E4%B8%B2/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-split%E5%88%87%E5%88%86%E5%AD%97%E4%B8%B2/</guid>
      <description>Split切分字串 // abc,b=&amp;gt;[a c]func Split(str, sep string) []string {// str=&amp;quot;bsfcvjkhbafs&amp;quot; sep=&amp;quot;b&amp;quot;var ret = make([]string, 0, strings.Count(str, sep)+1)index := strings.Index(str, sep)for index &amp;gt;= 0 {ret = append(ret, str[:index])str = str[index+len(sep):]index = strings.Index(str, sep)}ret = append(ret, str)return ret}</description>
    </item>
    
    <item>
      <title>Test單元測試</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-test%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-test%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/</guid>
      <description>Test單元測試  單元測試目的是驗證程式碼(例如一個方法)本身的邏輯是否正確 單元測試應排除外部依賴（Database、File System IO） 單元測試應該是隨時隨地都要能正確執行 單元測試的標題需要具備好的可讀性、明確、標題與測試的內容精確吻合 例：「public void GetTest_帶入會員ID＿應回該ID搜尋到的會員資料DTO」，盡量符合：受測方法＿傳入參數意義＿期望得到的結果 一個測試只應該關注一件事情，如果受測目標有多種狀況，應該分成好幾個測試去涵蓋所有邏輯   3A原則
  Arrange = 準備受測物件、參數、預期結果 Act = 執行受測方法 Assert = 驗證執行結果與預測結果是否一致  cal.go func addUpper(n int) int {res := 0for i := 0; i &amp;lt;= n; i++ {res = +i}return res}func getSub(n1, n2 int) int {return n1 - n2}cal_test.go func TestAddUpper(t *testing.T) {//調用res := addUpper(10)if res !</description>
    </item>
    
    <item>
      <title>WaitGroup鎖</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-waitgroup%E9%8E%96/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-waitgroup%E9%8E%96/</guid>
      <description>WaitGroup鎖 讀寫鎖 var x = 0var wg sync.WaitGroupvar rwlock sync.RWMutexfunc write() {rwlock.Lock()x = x + 1time.Sleep(time.Millisecond * 10)rwlock.Unlock()wg.Done()}func read() {// lock.Lock()rwlock.RLock() //鎖讀time.Sleep(time.Millisecond)rwlock.RUnlock()// lock.Unlock()wg.Done()}func main() {start := time.Now()for i := 0; i &amp;lt; 10; i++ {wg.Add(1)go write()}for i := 0; i &amp;lt; 1000; i++ {wg.Add(1)go read()}wg.</description>
    </item>
    
    <item>
      <title>二維數組</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E4%BA%8C%E7%B6%AD%E6%95%B8%E7%B5%84/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E4%BA%8C%E7%B6%AD%E6%95%B8%E7%B5%84/</guid>
      <description>// 000000// 001000// 020300// 000000func main() {var arr [4][6]intarr[1][2] = 1arr[2][1] = 2arr[2][3] = 3//遍歷for i := 0; i &amp;lt; len(arr); i++ {for j := 0; j &amp;lt; len(arr[i]); j++ {fmt.Print(arr[i][j], &amp;quot; &amp;quot;)}fmt.Println()}//遍歷rangefor i, v := range arr {for j, v2 := range v {fmt.Printf(&amp;quot;arr[%v][%v]=%v \t&amp;quot;, i, j, v2)}fmt.</description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>冒泡排序 var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 6}func main() {s1 := arr1[:]bubbleSort(s1)fmt.Println(arr1)}func bubbleSort(x []int) {for j := 1; j &amp;lt; len(x); j++ {for i := 0; i &amp;lt; len(x)-1; i++ {if x[i] &amp;gt; x[i+1] {x[i], x[i+1] = x[i+1], x[i]}}}}</description>
    </item>
    
    <item>
      <title>函數封裝的金字塔</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%87%BD%E6%95%B8%E5%B0%81%E8%A3%9D%E7%9A%84%E9%87%91%E5%AD%97%E5%A1%94/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%87%BD%E6%95%B8%E5%B0%81%E8%A3%9D%E7%9A%84%E9%87%91%E5%AD%97%E5%A1%94/</guid>
      <description>package mainimport (&amp;quot;fmt&amp;quot;)var input intfunc jin(input int) {for i := 1; i &amp;lt;= input; i++ {for k := 1; k &amp;lt;= input-i; k++ {fmt.Print(&amp;quot; &amp;quot;)}for j := 1; j &amp;lt;= 2*i-1; j++ {if j == 1 || j == 2*i-1 || i == input {fmt.Print(&amp;quot;*&amp;quot;)} else {fmt.Print(&amp;quot; &amp;quot;)}}fmt.Println()}}func main() {fmt.</description>
    </item>
    
    <item>
      <title>函數綁定方法</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%87%BD%E6%95%B8%E7%B6%81%E5%AE%9A%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%87%BD%E6%95%B8%E7%B6%81%E5%AE%9A%E6%96%B9%E6%B3%95/</guid>
      <description>函數綁定方法  方法:結構體的行為，自訂義的結構都可以有方法，方法是作用在指定類型上(綁定的)
方法就是跟一種類型綁定的函數，因為綁定數據類型了就可以偷雞，具體表現在省指針
定義方法時候寫的是func(a ABC) //後面怎樣調用都是值拷貝
定義方法時候寫的是func(a *ABC)//後面怎樣調用都是真實地址
要調用方法，只能透過那種類型的的數據變量 例如a1.ABC
 package mainimport (&amp;quot;fmt&amp;quot;)type Person struct {Name string}//給Person類型綁定一個方法func (p Person) test() {p.Name = &amp;quot;jack&amp;quot;fmt.Println(&amp;quot;test()=&amp;quot;, p.Name)}//給Person類型添加一個speak方法，輸出xxx是好人func (p Person) speak() {fmt.Println(p.Name, &amp;quot;是一個好人&amp;quot;)}//添加一個計算方法算+1...+100func (p Person) count() {res := 0for i := 1; i &amp;lt;= 100; i++ {res += i}fmt.Println(p.Name, &amp;quot;計算的結果是&amp;quot;, res)}//添加一個計算方法算+1.</description>
    </item>
    
    <item>
      <title>切片</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%88%87%E7%89%87/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%88%87%E7%89%87/</guid>
      <description>func main() {//切片的類型是引用(傳遞的時候也是引用地址)//切片長度可變(不像數組)var arr1 = [5]int{1, 2, 3, 4, 5}s1 := arr1[1:3] //表示切arr的[1 2] 左開右閉(含左不含右)//var slice=arr[0:end]簡寫[:end]//[start:len(arr)]=[start:]//[0:len(arr)]=[:]fmt.Println(&amp;quot;s1內容是&amp;quot;, s1)fmt.Println(&amp;quot;s1長度是&amp;quot;, len(s1))fmt.Println(&amp;quot;s1容量是&amp;quot;, cap(s1))fmt.Printf(&amp;quot;s1第一個地址是%p\n&amp;quot;, &amp;amp;s1[0])fmt.Printf(&amp;quot;arr1[1]地址是%p\n&amp;quot;, &amp;amp;arr1[1])s1[0] = 33fmt.Println(&amp;quot;arr1內容是&amp;quot;, arr1)//var 切片名[]type=make([]type,len,cap)var s2 []float64 = make([]float64, 5, 10)fmt.Println(s2)//var 變量=make(類型)var s22 = make([]float64, 5, 10)fmt.Println(s22)var s3 []int = []int{1, 2, 3, 4, 5}fmt.Println(s3)//用append動態追加s3 = append(s3, 6, 7, 8, 9)fmt.</description>
    </item>
    
    <item>
      <title>匿名函數與閉包</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B8%E8%88%87%E9%96%89%E5%8C%85/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B8%E8%88%87%E9%96%89%E5%8C%85/</guid>
      <description>匿名函數 func main() {res := func(n1, n2 int) int {return n1 + n2}(10, 20)fmt.Println(res)a := func(n1, n2 int) int {return n1 - n2}res = a(10, 5)fmt.Println(res)}閉包 //累加器func Add() func(int) int { //Add是一個函數，返回的數據類型是func(int) intvar n int = 10 //返回的是一個匿名函數，那這個函數用到函數外的n，因此形成一個整體稱為閉包return func(x int) int {n = n + xreturn n//閉包是類，函數是操作，n是字段，函數+使用n構成閉包//n只初始化一次}}func main() {a := Add()fmt.</description>
    </item>
    
    <item>
      <title>命令行參數Args&amp;Flag</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%83%E6%95%B8argsflag/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%83%E6%95%B8argsflag/</guid>
      <description>命令行參數Args&amp;amp;Flag func main() {fmt.Println(&amp;quot;命令行參數有&amp;quot;, len(os.Args))//遍歷os.Args切片 得到所有輸入的參數值for i, v := range os.Args {fmt.Printf(&amp;quot;args[%v]=%v\n&amp;quot;, i, v)}fmt.Println(&amp;quot;=====================&amp;quot;)//flag方法 先定義幾個變量用於接收參數值var user stringvar pwd stringvar host stringvar port intflag.StringVar(&amp;amp;user, &amp;quot;u&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;帳號 預設為空&amp;quot;)flag.StringVar(&amp;amp;pwd, &amp;quot;pwd&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;密碼 預設為空&amp;quot;)flag.StringVar(&amp;amp;host, &amp;quot;h&amp;quot;, &amp;quot;localhost&amp;quot;, &amp;quot;主機 預設為localhost&amp;quot;)flag.IntVar(&amp;amp;port, &amp;quot;port&amp;quot;, 3306, &amp;quot;端口 預設為3306&amp;quot;)//前面有亂打的字就不行 比如...exe 12354 -u tom會調用預設flag.Parse() //這個一定要調用//輸出結果fmt.Printf(&amp;quot;user=%v pwd=%v host=%v port=%v&amp;quot;,user, pwd, host, port)}</description>
    </item>
    
    <item>
      <title>字串轉換常用函數</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AD%97%E4%B8%B2%E8%BD%89%E6%8F%9B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B8/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AD%97%E4%B8%B2%E8%BD%89%E6%8F%9B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B8/</guid>
      <description>字串轉換常用函數 var str string = &amp;quot;abc123中文&amp;quot;func main() {fmt.Println(&amp;quot;長度=&amp;quot;, len(str))r := []rune(str)for i := 0; i &amp;lt; len(r); i++ {fmt.Printf(&amp;quot;遍歷=%q\n&amp;quot;, r[i])}//轉成整數 Atoin, err := strconv.Atoi(&amp;quot;5421&amp;quot;)if err != nil {fmt.Println(&amp;quot;錯誤,err&amp;quot;)} else {fmt.Println(&amp;quot;轉換成&amp;quot;, n)//整數轉字串str2 := strconv.Itoa(654231)fmt.Printf(&amp;quot;類型是%T\n&amp;quot;, str2)//轉bytevar bytes = []byte(&amp;quot;hello&amp;quot;)fmt.Printf(&amp;quot;bytes=%v \n&amp;quot;, bytes)//byte轉回字串str3 := string([]byte{97, 98, 99})fmt.Printf(&amp;quot;str3=%v \n&amp;quot;, str3)//10進制轉2,8,16返回字串str4 := strconv.</description>
    </item>
    
    <item>
      <title>實作練習-ini解析器</title>
      <link>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</guid>
      <description>用來解析.ini文檔格式是否有問題
 package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;io/ioutil&amp;quot;&amp;quot;reflect&amp;quot;&amp;quot;strings&amp;quot;)type RedisConfig struct {Host string `ini:&amp;quot;host&amp;quot;`Port int `ini:&amp;quot;port&amp;quot;`Password string `ini:&amp;quot;password&amp;quot;`Database int `ini:&amp;quot;database&amp;quot;`}type MysqlConfig struct {Address string `ini:&amp;quot;address&amp;quot;`Port int `ini:&amp;quot;port&amp;quot;`Password string `ini:&amp;quot;password&amp;quot;`Username string `ini:&amp;quot;username&amp;quot;`}type Config struct {MysqlConfig `ini:&amp;quot;mysql&amp;quot;`RedisConfig `ini:&amp;quot;redis&amp;quot;`}func loadIni(fileName string, data interface{}) (err error) {// 0. 參數校驗// 0.1 傳來的data必須是結構體類型指針t := reflect.</description>
    </item>
    
    <item>
      <title>實作練習-txt文本批次取代器</title>
      <link>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/</guid>
      <description>實作練習-txt文本批次取代器  自己寫用來一次取代多個名詞，去除多餘空格或符號等等
 package mainimport (&amp;quot;bufio&amp;quot;&amp;quot;fmt&amp;quot;&amp;quot;io&amp;quot;&amp;quot;os&amp;quot;&amp;quot;strings&amp;quot;)var data []string = make([]string, 128)func main() {readByBufio()for _, v := range data {if v == &amp;quot;&amp;quot; {break}fmt.Print(v)}}func readByBufio() {file, err := os.Open(&amp;quot;C:/test.txt&amp;quot;)if err != nil {fmt.Printf(&amp;quot;os.Open err %s\n&amp;quot;, err)return}defer file.Close()reader := bufio.NewReader(file)for i := 0; ; i++ {line, err := reader.</description>
    </item>
    
    <item>
      <title>實作練習-多人聊天室</title>
      <link>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>實作練習-多人聊天室  本來很傻的檔案代碼一個一個貼，後來學了github的專案管理就放到那了
 https://github.com/yoziming/go-practice-chatroom</description>
    </item>
    
    <item>
      <title>實作練習-客戶名單管理系統</title>
      <link>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/</guid>
      <description>實作練習-客戶名單管理系統 model type Customer struct {Id intName stringGender stringAge intPhone stringEmail string}//使用工廠模式返回一個實例func NewCustomer(id int, name string, gender string,age int, phone string, email string) Customer {return Customer{Id: id,Name: name,Gender: gender,Age: age,Phone: phone,Email: email,}}//返回用戶訊息func (c Customer) GetInfo() string {info := fmt.Sprintf(&amp;quot;%v	%v	%v	%v	%v	%v&amp;quot;,c.Id, c.Name, c.Gender, c.Age, c.</description>
    </item>
    
    <item>
      <title>實作練習-家庭收支小app</title>
      <link>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/</guid>
      <description>實作練習-家庭收支小app type MyMoney struct {key string //鍵入值note string //收支說明balance float64 //餘額money float64 //收支flag bool //判斷是否有明細details string //詳細loop bool //循環}//綁定方法func (mm *MyMoney) MainMenu() {for {if !mm.loop {break}fmt.Println(&amp;quot;\n-----------------家庭收支记账软件-----------------&amp;quot;)fmt.Println(&amp;quot; 1 收支明细&amp;quot;)fmt.Println(&amp;quot; 2 登记收入&amp;quot;)fmt.Println(&amp;quot; 3 登记支出&amp;quot;)fmt.Println(&amp;quot; 4 退出软件&amp;quot;)fmt.Print(&amp;quot;請選擇(1-4)...&amp;quot;)fmt.Scanln(&amp;amp;mm.key)switch mm.key {case &amp;quot;1&amp;quot;:mm.showDetails()case &amp;quot;2&amp;quot;:mm.income()case &amp;quot;3&amp;quot;:mm.outcome()case &amp;quot;4&amp;quot;:mm.exit()default:fmt.</description>
    </item>
    
    <item>
      <title>實作練習-點對點聊天</title>
      <link>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%AF%A6%E4%BD%9C%E7%B7%B4%E7%BF%92-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/</guid>
      <description>實作練習-點對點聊天 server.go func main() {fmt.Println(&amp;quot;服務器開始監聽&amp;quot;)listen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;0.0.0.0:8888&amp;quot;) //0.0.0.0 寫4位ip v4 v6都能用if err != nil {fmt.Println(&amp;quot;監聽失敗&amp;quot;, err)return}defer listen.Close() //主程式退出後就關閉監聽// fmt.Printf(&amp;quot;listen succes=%v\n&amp;quot;, listen)for {//開啟監聽端口8888time.Sleep(time.Microsecond)fmt.Println(&amp;quot;等待連接中...&amp;quot;)conn, err := listen.Accept()if err != nil {fmt.Println(&amp;quot;Accept()err=&amp;quot;, err)} else {fmt.Printf(&amp;quot;conn suc con=%v 客戶端ip=%v\n&amp;quot;, conn, conn.RemoteAddr().String())}//準備啟動一個協程go process(conn)}}func process(conn net.Conn) {//循環接收客戶端送來的數據defer conn.Close()fmt.Printf(&amp;quot;服務器等待%s客戶端輸入...\n&amp;quot;, conn.</description>
    </item>
    
    <item>
      <title>對有序數列進行二分查找</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%9C%89%E5%BA%8F%E6%95%B8%E5%88%97%E9%80%B2%E8%A1%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%9C%89%E5%BA%8F%E6%95%B8%E5%88%97%E9%80%B2%E8%A1%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>//對有序數列進行二分查找var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 0}func bubble(x []int) {for j := 1; j &amp;lt; len(x); j++ {for i := 0; i &amp;lt; len(x)-1; i++ {if x[i] &amp;gt; x[i+1] {x[i], x[i+1] = x[i+1], x[i]}}}}func bi(x int, s []int, left int, right int) {middle := (right + left) / 2if left &amp;gt; right {fmt.</description>
    </item>
    
    <item>
      <title>工廠模式</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F/</guid>
      <description>//工廠模式// 假如有些要公用的東西又不想用大寫讓人隨意改了 例如結構體、結構體內的字段等等// 我就在那個包裏建一個方法，這個方法本身大寫，在方法中原地調用那些本來是大寫的玩意// 返回一個相同的值過來，相當於那在那個包里把該封裝的都封好，拿出來的就是產品import (&amp;quot;fmt&amp;quot;)type Student struct {Name stringAge intScore float64}func (s *Student) Say() string {infoStr := fmt.Sprintf(&amp;quot;信息 name=[%v] age=[%v] score=[%v]&amp;quot;,s.Name, s.Age, s.Score)return infoStr}func main() {var s1 = Student{Name: &amp;quot;tom&amp;quot;,Score: 98,Age: 18, //不依賴順序}res := s1.Say()fmt.Println(res)//其他創建結構變量同時指定值的方法:stu2 := Student{&amp;quot;Jack&amp;quot;, 20, 100} //項目順序都要有對應fmt.Println(stu2)//返回結構的指針var stu3 = &amp;amp;Student{&amp;quot;Mary&amp;quot;, 28, 5}fmt.</description>
    </item>
    
    <item>
      <title>拷貝檔案</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%8B%B7%E8%B2%9D%E6%AA%94%E6%A1%88/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%8B%B7%E8%B2%9D%E6%AA%94%E6%A1%88/</guid>
      <description>拷貝一個檔案 //定義一個函數接收2個路徑func CopyFile(dstFileName, srcFileName string) (written int64, err error) {srcFile, err := os.Open(srcFileName)if err != nil {fmt.Println(err)}defer srcFile.Close()//通過srcFile獲取到readerreader := bufio.NewReader(srcFile)//打開dstFileNamedstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666)if err != nil {fmt.Println(err)}//通過dstFile獲取到writerwriter := bufio.NewWriter(dstFile)defer dstFile.Close()return io.Copy(writer, reader)}func main() {src := &amp;quot;C:/01.mkv&amp;quot; //原始檔dst := &amp;quot;C:/food2.mkv&amp;quot;_, err := CopyFile(dst, src)if err == nil {fmt.</description>
    </item>
    
    <item>
      <title>接口interface</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%8E%A5%E5%8F%A3interface/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%8E%A5%E5%8F%A3interface/</guid>
      <description>接口interface  例如定義 只要滿足&amp;quot;會跑&amp;quot;且&amp;quot;會叫&amp;quot;的就是&amp;quot;動物&amp;quot;，
那不管你是啥玩意只要實現會跑跟會叫，我就當你是動物，就能用動物的接口去調用
 //接口內不能有變量，方法也不能實現type Usb interface {//聲明兩個沒實現的方法Start()Stop()}type Usb2 interface {//接口是不需要顯示聲明，只要能實現就都能調用Start()Stop()//假如我多聲明一個沒實現的方法在接口內就不能調用Test() //有方法沒實現，導致Usb2這個接口不能用}type Phone struct {}//讓Phone實現USB接口的方法func (p Phone) Start() {fmt.Println(&amp;quot;手機啟動&amp;quot;)}func (p Phone) Stop() {fmt.Println(&amp;quot;手機停止&amp;quot;)}type Camera struct {}func (c Camera) Start() {fmt.Println(&amp;quot;相機啟動~~&amp;quot;)}func (c Camera) Stop() {fmt.Println(&amp;quot;相機停止&amp;quot;)}//電腦type Computer struct {}func (c Computer) Working(usb Usb) { //接受一個Usb的接口類型//通過usb變量來調用Start等方法fmt.</description>
    </item>
    
    <item>
      <title>數組</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E7%B5%84/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%95%B8%E7%B5%84/</guid>
      <description>數組 func main() {var n1 [3]int = [3]int{1, 2, 3}var n2 = [3]int{4, 5, 6}//長度聲明後就不能變化var n3 = [...]int{7, 8, 9}//數組長度是類型的一部分 [3]int != [4]intvar n4 = [...]string{0: &amp;quot;李四&amp;quot;, 1: &amp;quot;張三&amp;quot;, 5: &amp;quot;王武&amp;quot;}n5 := []int{5, 5, 5, 5, 5}//[]int 這樣定義其實是切片fmt.Println(n1)fmt.Println(n2)fmt.Println(n3)fmt.Println(n4)fmt.Println(n5)n9 := fmt.Sprintf(&amp;quot;%.2f&amp;quot;, 9.888888)fmt.Println(n9)var score [5]float64for i := 0; i &amp;lt; len(score); i++ {fmt.Println(&amp;quot;輸入成績&amp;quot;)fmt.Scanln(&amp;amp;score[i])}for i := 0; i &amp;lt; len(score); i++ {fmt.</description>
    </item>
    
    <item>
      <title>文字檔案讀取寫入</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%96%87%E5%AD%97%E6%AA%94%E6%A1%88%E8%AE%80%E5%8F%96%E5%AF%AB%E5%85%A5/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%96%87%E5%AD%97%E6%AA%94%E6%A1%88%E8%AE%80%E5%8F%96%E5%AF%AB%E5%85%A5/</guid>
      <description>讀取 func main() {//打開一個文件file, err := os.Open(&amp;quot;c:/test.txt&amp;quot;)//有人叫file對象/指針/文件句柄if err != nil {fmt.Println(&amp;quot;open file err=&amp;quot;, err)}//看看文件是啥fmt.Printf(&amp;quot;file=%v\n&amp;quot;, file)//退出函數就關閉文件defer file.Close()//創建一個帶緩衝的reader，預設大小是4096reader := bufio.NewReader(file)for {str, err := reader.ReadString(&#39;\n&#39;) //讀到換行就結束fmt.Print(str)if err == io.EOF { //表示文件末尾break}}fmt.Println(&amp;quot;\n讀取結束&amp;quot;)//用ioutil.ReadFile一次讀完//這個包已經封裝了open跟close了，只適用在檔案大小不大的情境file2 := &amp;quot;c:/test.txt&amp;quot;str2, err2 := ioutil.ReadFile(file2)if err2 != nil {fmt.Println(err)}fmt.Printf(&amp;quot;%s&amp;quot;, str2) //原本輸出是[]byte,用%s轉//創建一個新檔案，寫入5句話filePath := &amp;quot;c:/abc.</description>
    </item>
    
    <item>
      <title>文檔字符統計</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%96%87%E6%AA%94%E5%AD%97%E7%AC%A6%E7%B5%B1%E8%A8%88/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%96%87%E6%AA%94%E5%AD%97%E7%AC%A6%E7%B5%B1%E8%A8%88/</guid>
      <description>文檔字符統計 //保存結果用type CharCount struct {ChCount int //英文字數NumCount int //SpaceCount intOtherCount int}func main() {//思路 打開一個文件 創一個reader每讀取一行就去統計，將結果保存到一個結構體fileName := &amp;quot;c:/abc.txt&amp;quot;file, err := os.Open(fileName)if err != nil {fmt.Println(err)return}defer file.Close()//來個實例var count CharCountreader := bufio.NewReader(file)//開始讀取for {str, err := reader.ReadString(&#39;\n&#39;)//這存在BUG 當行不換行做結尾就統計不到if err == io.EOF {break}for _, v := range str {switch {case v &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;z&#39;:fallthroughcase v &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;Z&#39;:count.</description>
    </item>
    
    <item>
      <title>日期時間</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%97%A5%E6%9C%9F%E6%99%82%E9%96%93/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E6%97%A5%E6%9C%9F%E6%99%82%E9%96%93/</guid>
      <description>日期時間 func main() {//1.獲取當前本地時間now := time.Now()fmt.Printf(&amp;quot;now=%v,type=%T&amp;quot;, now, now) //返回的類型是struct//2.通過now獲取各種詳細fmt.Printf(&amp;quot;年=%v,type=%T\n&amp;quot;, now.Year(), now.Year())fmt.Printf(&amp;quot;月=%v,type=%T\n&amp;quot;, now.Month(), now.Month())fmt.Printf(&amp;quot;月=%v,type=%T\n&amp;quot;, int(now.Month()), int(now.Month()))fmt.Printf(&amp;quot;日=%v,type=%T\n&amp;quot;, now.Day(), now.Day())fmt.Printf(&amp;quot;時=%v,type=%T\n&amp;quot;, now.Hour(), now.Hour())fmt.Printf(&amp;quot;分=%v,type=%T\n&amp;quot;, now.Minute(), now.Minute())fmt.Printf(&amp;quot;秒=%v,type=%T\n&amp;quot;, now.Second(), now.Second())fmt.Printf(&amp;quot;星期=%v,type=%T\n&amp;quot;, now.Weekday(), now.Weekday())fmt.Printf(&amp;quot;星期=%v\n&amp;quot;, int(now.Weekday()))//3.格式化日期時間dateStr := fmt.Sprintf(&amp;quot;年月日時分=%d-%d-%d %d:%d\n&amp;quot;, now.Year(), now.Month(),now.Day(), now.Minute(), now.Second())fmt.Println(dateStr)//4.蛋疼的指定格式fmt.Println(now.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;))fmt.Println(now.Format(&amp;quot;2006-01-02&amp;quot;))fmt.Println(now.Format(&amp;quot;06&amp;quot;))fmt.Println(now.Format(&amp;quot;01&amp;quot;))fmt.Println(now.Format(&amp;quot;03&amp;quot;))fmt.Println(now.Format(&amp;quot;01-02-06 03 04 05&amp;quot;))//123456=月日時分秒年//5.時間常量&amp;amp;休眠//每隔固定時間打印數字，打到100退出for i := 0; i &amp;lt;= 100; i++ {fmt.</description>
    </item>
    
    <item>
      <title>結構體</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E7%B5%90%E6%A7%8B%E9%AB%94/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E7%B5%90%E6%A7%8B%E9%AB%94/</guid>
      <description>結構體 type Cat struct {Name stringAge intColor string// S1 []int //可以是切片 但是預設值為nil(沒分配空間，一樣要先make後才能用)}//結構體是一個值類型，預設是值拷貝，比如cat1跟cat2是獨立存在兩個空間func main() {//創建Cat的變量var cat1 Catcat1.Name = &amp;quot;小花&amp;quot;cat1.Age = 18cat1.Color = &amp;quot;花&amp;quot;fmt.Println(&amp;quot;cat1=&amp;quot;, cat1)// cat1.S1 = make([]int, 10)// cat1.S1[0] = 100// fmt.Println(&amp;quot;cat1=&amp;quot;, cat1)//推薦方式cat2 := Cat{&amp;quot;小黑&amp;quot;, 5, &amp;quot;black&amp;quot;}fmt.Println(cat2)//方法3//var c *C=new(C)var cat3 *Cat = new(Cat)//因為cat3是一個指針(*cat3).Name = &amp;quot;小白&amp;quot;//語法糖 cat3.Age也可以 ，不建議cat3.</description>
    </item>
    
    <item>
      <title>繼承</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E7%B9%BC%E6%89%BF/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E7%B9%BC%E6%89%BF/</guid>
      <description>繼承 type Student struct {Name stringAge intScore int//共有的字段}type Pupil struct {Student //套入Covid19 bool}type College struct {Student //套入指針效率更好SexExp bool}func (stu *Student) ShowInfo() {fmt.Printf(&amp;quot;姓名=%v 年齡=%v 成績=%v\n&amp;quot;, stu.Name, stu.Age, stu.Score)}func (stu *Student) SetScore(s int) {stu.Score = s}func (p *Pupil) Test() {fmt.Println(&amp;quot;小學生考試&amp;quot;)}func main() {pupilA := &amp;amp;Pupil{}pupilA.Student.Name = &amp;quot;tome&amp;quot;pupilA.Student.Age = 8pupilA.</description>
    </item>
    
    <item>
      <title>錯誤處理</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86/</guid>
      <description>錯誤處理 func test() { //捕捉異常 	defer func() { //內置函數recover就是找是否異常 	if err := recover(); err != nil { //err不為空=有錯 	fmt.Println(&amp;#34;錯誤&amp;#34;, err) } }() n1 := 10 n2 := 0 res := n1 / n2 fmt.Println(res) } //讀取文件名稱，錯誤就報錯 func readConf(name string) (err error) { if name == &amp;#34;config.ini&amp;#34; { return nil } else { //返回自訂錯誤 	return errors.New(&amp;#34;文件錯誤&amp;#34;) } } func test02() { err := readConf(&amp;#34;config.in564&amp;#34;) if err != nil { panic(err) } fmt.</description>
    </item>
    
    <item>
      <title>順序查找</title>
      <link>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E9%A0%86%E5%BA%8F%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-%E5%B0%9A%E7%A1%85%E8%B0%B7go%E5%9F%BA%E7%A4%8E%E8%AA%B2-%E9%A0%86%E5%BA%8F%E6%9F%A5%E6%89%BE/</guid>
      <description>順序查找 func main() {names := [4]string{&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;}var input = &amp;quot;&amp;quot;fmt.Println(&amp;quot;輸入...&amp;quot;)fmt.Scanln(&amp;amp;input)//順序查找// for i := 0; i &amp;lt; len(names); i++ {// if input == names[i] {// fmt.Printf(&amp;quot;找到%v,下標=%v \n&amp;quot;, input, i)// break// } else if i == len(names)-1 {// fmt.Println(&amp;quot;比對失敗...&amp;quot;)// }//順序查找2index := -1for i := 0; i &amp;lt; len(names); i++ {if input == names[i] {index = ibreak}}if index !</description>
    </item>
    
    <item>
      <title>範例文章</title>
      <link>https://yoziming.github.io/post/200101-example/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/200101-example/</guid>
      <description>Heading 1 | 一級標題字 Heading 2 | 二級標題字 Heading 3 | 三級標題字 以此類推   引言 | Blockquotes
  內文 strud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum
 程式碼
fmt.Println(&amp;#34;hello&amp;#34;)  序列</description>
    </item>
    
  </channel>
</rss>
