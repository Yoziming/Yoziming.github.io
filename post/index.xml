<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 柚子茶室</title>
    <link>https://yoziming.github.io/post/</link>
    <description>Recent content in Posts on 柚子茶室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>yoziming</copyright>
    <lastBuildDate>Sun, 12 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://yoziming.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>路徑、正反斜槓與檔名的一些規則</title>
      <link>https://yoziming.github.io/post/211212-slash-file-name/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211212-slash-file-name/</guid>
      <description>正反斜槓  這個符號 「/」就是斜槓，呈現上右下左。 而 「\」是反斜槓，呈現上左下右。 斜線的方向，有時候真的是很容易搞混。其實只要回想一下手寫幾月幾日的時候，劃斜槓習慣往哪個方向就好了。反之，若寫起來感覺方向不太順手，那它就是反的。by IrisAndMimi  路徑 Windows系統  只有Windows系統會用反斜槓\表達路徑，原因是上古時代DOS把正斜&amp;quot;/&amp;ldquo;當作參數命令，於是就把反斜槓這個惡魔放了出來表示路徑，記憶法:W的第一筆畫就是\ 常見的Windows系統系統下的路徑:  除開使用DOS，大多數情況下用正斜槓Windows也能識別路徑  其他系統  不論是網址、MAC系統、Linux系統都是用&amp;rdquo;/&amp;quot;   雙斜槓   //雙斜槓：協議和主機名之間的分隔符 （比如http://localhost:8080）
  \\雙反斜線 ：在windows里表示絕對地址的第一項，比如后面跟上IP地址的話，就是需要打開這個IP地址的網絡共享資源，舉例windows使用網路芳鄰會看到這樣:
  在大部分的程式語言中，把\反斜槓當作轉譯字符使用了，比如\n、\t，單用一個反斜槓很容易引起錯誤。最好還是用/正斜槓表達路徑
  檔名的大小寫規則   檔名不分大小寫:Windows系統、MAC系統
  檔名區分大小寫:Linux系統
  Git則可以自己手動設定，使用命令:
git config core.ignorecase true  資料夾的命名建議   大寫開頭的通常是系統預設的資料夾，Windows系統、MAC系統、Linux系統都有這個特性，舉例:
  個人在長期的、大項的、很少更動的資料夾我才用大寫開頭，其他一律小寫
  檔名的命名建議   避免搞事，有需要上傳網路的、跨平台的檔案，使用者命名時最好用全英文小寫，之間用連接符&amp;quot;-&amp;ldquo;或下劃線&amp;rdquo;_&amp;ldquo;相連
  使用符號不要超過ASCII的範圍、不要用符號作為檔名開頭
  更嚴謹應該也不要用數字作為開頭，但我個人常用日期數字當開頭方便排序，在真有嚴格規定的地方前面多加英文字(通常是類型的縮寫)區分</description>
    </item>
    
    <item>
      <title>Map、HashMap、Collections工具類</title>
      <link>https://yoziming.github.io/post/211209-agg-ja-24/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211209-agg-ja-24/</guid>
      <description>Map Map接口:雙列數據，保存具有映射關係(key-value)成對的物件
分類  HashMap:主要實現類，線程不安全、效率高、可以存null  LinkedHashMap:遍歷時可以按照添加順序排列   TreeMap:可以按照key(必須都是同類)來排序，底層是紅黑樹 Hashtable:古老的實現類，注意t是小寫，線程安全、效率低、不能存null  Properties:常用來處理配置文件，key跟value都是String類型    結構  key:無序、不可重複的，使用Set儲存。key決定存放位置，key的所在類必須重寫equals()與hashCode() value:無序，可重複的，使用Collection儲存，value的所在類必須重寫equals() 一對key與value構成一個Entry物件，使用Set儲存，當然也是無序、不可重複的  HashMap源碼分析  以JDK7為例
  HashMap map = new HashMap():實例化時，底層創建了一個長度16的一維數組Entry[] table map.put(key1, value1):放數據時，調用key1所在類的hashcode()方法算出哈希值，以此哈希值再經過某些位運算，得到在Entry[] table數組中的存放位置，此時:  若位置是空的，放入成功 若已經有人(可能有一個數據或鏈表)，就來比較key1跟佔位者(可能有多個，全都要比一遍)的哈希值  如果哈希值都不同，添加成功(放成鏈表) 如果key1的哈希值跟已存在的某數據(舉例為key2, value2)哈希值相同，此時再比較key1所在類的equals()方法，此時:  如果equals()返回false，表示key不同只是恰好哈希值一樣，添加成功(放成鏈表) 如果equals()返回true，表示兩者key真的一樣，那就進入至尊對決，此時把put()方法理解為覆蓋，將舊的value2換成新的value1   所謂放成鏈表跟前面Set提到的一樣，類似於&amp;quot;卜&amp;quot;字的概念，從該位置延伸出去存放新的元素     擴容:超過臨界值(容量*負載因子)且要存的位置非空就會擴容，預設的擴容方式為造一個新的兩倍長數組，然後將原有的複製過來  預設容量:16 預設負載因子:0.75 擴容的邏輯是這樣的，為了減少哈希碰撞(就是不希望分支的鏈表太多太長)，所以不會等他裝到滿才擴容。假如負載因子0.9可能老是撞車分支很多，負載因子0.2可能一直在擴容，折衷就定負載因子0.75效率高    JDK8的改動  new HashMap():實例化時，底層沒有創建數組，首次調用put()方法才創建，類似懶漢式 底層數組用Node[]取代Entry[] 當數組某一個位置上的元素以鏈表形式存在的數據&amp;gt;8且當前主幹數組長度&amp;gt;64時，將鏈表改為紅黑樹儲存，提高查找效率  LinkedHashMap 繼承了HashMap的Node，但又多了before跟after兩個屬性，所以形成雙向鏈表可以再添加時記錄前後順序</description>
    </item>
    
    <item>
      <title>集合:Collection、疊代器Iiterator、List、Set</title>
      <link>https://yoziming.github.io/post/211208-agg-ja-23/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211208-agg-ja-23/</guid>
      <description>集合概述  集合、數組都是用來儲存多個數據(在記憶體中)的結構，簡稱Java容器 數組在聲明時長度跟數據類型就定死了，還強制是有序的，增刪改查都不變 Java集合分成兩種體系，有各種接口與實現類:  Collection接口:單列數據，用來存一個一個的物件  List接口:元素有序、可重複，又稱為&amp;quot;動態數組&amp;quot;  ArrayList LinkedList Vector   Set接口:元素無序、不可重複  HashSet LinkedHashSet TreeSet     Map接口:雙列數據，保存具有映射關係(key-value)成對的物件  HashMap  LinkedHashMap   TreeMap Hashtable  Properties        Collection Collection接口本身沒有直接的實現類，而是要通過其子類List與Set各自的實現類來完成物件的實例化
方法  用一個實現Collection接口的實例物件調用，例如:Collection coll = new ArrayList();
   add(Object e):將Object e加入集合中
  size():返回元素個數
  addAll(Collection c):將集合c的內容全加進來
  clear():清空元素，注意不是刪除集合本身，只是清掉其中的元素
  isEmpty():判定是否為空</description>
    </item>
    
    <item>
      <title>枚舉類enum、註解annotation</title>
      <link>https://yoziming.github.io/post/211207-agg-ja-22/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211207-agg-ja-22/</guid>
      <description>枚舉類(enum)  當類的物件數量是有限定的、確定的，例如:星期、性別、季節、支付方式、XX狀態 需要定義一組常量時，強烈建議使用枚舉類 如果類中只有一個物件，可以用單例模式 enum，發音&amp;quot;衣-囊&amp;quot;，名詞枚舉 enumerate，發音&amp;quot;以-new-merate&amp;quot;，動詞枚舉  自訂枚舉類  JDK 5以前
   聲明物件的屬性，用private final修飾
  將構造器私有化，給物件屬性賦上預想好的值
  在本類中預先創立好物件，用public static final修飾
  提供toSting方法
  提供其他訴求，例如:get屬性等等
  範例:
class PayMethod { private final String name; private final String desc; private PayMethod(String name, String desc) { this.name = name; this.desc = desc; } public static final PayMethod CASH = new PayMethod(&amp;#34;現金&amp;#34;, &amp;#34;真金白銀&amp;#34;); public static final PayMethod VISA = new PayMethod(&amp;#34;VISA卡&amp;#34;, &amp;#34;VISA金融卡&amp;#34;); public static final PayMethod ONLINE = new PayMethod(&amp;#34;電子支付&amp;#34;, &amp;#34;街口支付&amp;#34;); @Override public String toString() { return &amp;#34;PayMethod{&amp;#34; + &amp;#34;name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, desc=&amp;#39;&amp;#34; + desc + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } // 調用，因為是靜態，直接類名.</description>
    </item>
    
    <item>
      <title>日期時間、比較器、其他常用類</title>
      <link>https://yoziming.github.io/post/211206-agg-ja-21/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211206-agg-ja-21/</guid>
      <description>日期時間(JDK 8前)  提前說下，這些過時的類型跟方法實際95%用不上，了解一下就夠了
  System類中的currentTimeMillis():返回當下與1970年1月1日之間的時間差，單位毫秒  這一長串的數字稱為時間戳    java.util.Date類   創建
  使用空參構造器:創建一個當前時間的物件，格式為Wed Dec 01 13:35:20 CST 2021
  形參傳入時間戳，創建一個該時間戳的物件
    方法
 toString():顯示時間 getTime():返回時間戳    java.sql.Date類  本身是java.util.Date的子類，用來對應數據庫中的日期變量  為了區分，最好使用全類名例如:java.sql.Date d2 = new java.sql.Date(d1.getTime()); 創建:形參必須傳入時間戳 方法:  toString():顯示時間，格式只有日期，如:2021-12-01 getTime():返回時間戳     java.util.Date語java.sql.Date轉換:形參中填入getTime()即可互轉  SimpleDateFormat類   顧名思義，把Date類格式化成String用的
  創建一個形參為你想要的格式(如常見的&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;)的SimpleDateFormat物件
  用此物件調用format(date物件)方法返回想要的String，舉例:
Date d1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd hh:mm:ss&amp;#34;); String s1 = sdf.</description>
    </item>
    
    <item>
      <title>String相關常用類與方法</title>
      <link>https://yoziming.github.io/post/211205-agg-ja-20/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211205-agg-ja-20/</guid>
      <description>String類 String類特性  表示字符串，內容以&amp;quot;&amp;ldquo;包裹表示，稱為字面量的定義方式 是一個final類，不可被繼承 實現了Serializable接口，可以序列化 實現了Comparable接口，表示可以比較大小 內部定義了一個final char[] value數組來實際儲存數據，代表不可變的字符序列  當我們用字面量(區別於new)定義了一個String str1=&amp;ldquo;abc&amp;rdquo;，相當於在方法區的字符串常量池中新增了一個&amp;quot;abc&amp;quot;序列，其為不可變的 字符串常量池中不會儲存內容相同的字符串，比如我再新增一個str2=&amp;ldquo;abc&amp;rdquo;，則他們指向同一地址。  延伸str6=&amp;ldquo;a&amp;rdquo;+&amp;ldquo;bc&amp;rdquo;，在聲明時字面量相加，等於常量跟常量拼接，都是在常量池，所以指向同樣位置   而當我把str1=&amp;ldquo;hello&amp;rdquo;，或是用+拼接了其他內容，或是用replace取代了其中某一位的字，都是在常量池重新開闢空間，所謂不可變是這個意思   如果是用String str3=new String(&amp;ldquo;abc&amp;rdquo;);方法生成，則是創在堆中，str3本身是指向堆的地址，去比==都是false。這個動作實際開闢了2個記憶體空間，它在堆中的value才指向常量池  如果是new一個構造器生成時賦予的name傳入形參則跟new String是不同的，傳入形參也是類似於字面量的方法(因為顯然多在堆中開闢位置是毫無必要的) 若是用+拼接有任何涉及到變量的，例如str4=str1+&amp;ldquo;def&amp;rdquo;，都是相當於在堆空間new的操作，==去比較時全都false 但如果變量被final修飾(正常不會有人這麼做)，相當於這個變量存在常量池，又會是常量跟常量拼接，所以指向同樣位置 若是用intern()方法，例如str5=str1.intern();，返回值是在常量池中，==比較是true    面試題-判斷結果 public class StringTest { String str = new String(&amp;#34;good&amp;#34;); char[] ch = {&amp;#39;t&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;}; public void change(String str, char[] ch) { str = &amp;#34;bad&amp;#34;; ch[0] = &amp;#39;b&amp;#39;; } public static void main(String[] args) { StringTest ex = new StringTest(); ex.</description>
    </item>
    
    <item>
      <title>線程安全、線程通信、JDK5.0特性、線程池</title>
      <link>https://yoziming.github.io/post/211204-agg-ja-19/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211204-agg-ja-19/</guid>
      <description>線程安全 線程的生命週期 Thread.State類中定義了:
 新建:Thread類的物件被創建 就緒:start()後等待分配CPU資源的階段，可能是獲取了同步鎖、被notify() 運行:拿到實際資源、開始執行run()方法 阻塞:被暫時掛起，可能是sleep()或是被join()、或等待同步鎖、wait() 死亡:跑完或提前stop()、出錯了  同步代碼塊   解決多線程安全問題
  格式:
synchronized (同步器) { // 需要同步的代碼 }   同步器可以是任何物件，只需要滿足&amp;quot;它是多個線程共用的&amp;quot;，比如同類中的一個變量
 若是靠實現Runnable接口方法的多線程，可以用this，因為只有一個該類，當前對象是同一個 如果是繼承類實現的多線程，則可以用static變量，或是考慮&amp;quot;類名.class&amp;quot;(這玩意也是唯一的)    但這樣做實質等於單線程了，效率不高
  同步方法   解決多線程安全問題
  舉例:
public class SynTest implements Runnable { int ticket = 100; @Override public void run() { show(); } private synchronized void show() { for (; ticket &amp;gt; 0; ) { try { Thread.</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA Live Templates</title>
      <link>https://yoziming.github.io/post/211203-intellij_idea-live_templates/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211203-intellij_idea-live_templates/</guid>
      <description>IntelliJ IDEA Live Templates  盤點IDEA中tab的實用招式
 基本 psvm或main ▶ main 方法 for fori ▶ for (int i = 0; i &amp;lt; ; i++) itar ▶ for (int i = 0; i &amp;lt; arr.length; i++) iter ▶ for-each 數組或泛型物件.for ▶ for-each 數組物件.forr ▶ for (int i = arr.length - 1; i &amp;gt;= 0; i--) // 反向 print sout ▶ System.out.println(); souf ▶ System.out.printf(&amp;#34;&amp;#34;); &amp;#34;say something&amp;#34;.sout ▶ System.out.println(&amp;#34;say something&amp;#34;); obj.sout ▶ System.</description>
    </item>
    
    <item>
      <title>多線程:名詞解釋、基本用法</title>
      <link>https://yoziming.github.io/post/211203-agg-ja-18/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211203-agg-ja-18/</guid>
      <description>多線程 名詞解釋    英文 台灣 中國 意義     Program 程式 程序 靜態的程式碼集合   Process 程序(進程) 進程 動態、被執行中且載入記憶體的program，也是 OS 分配資源的最小單位。打開工作管理員看到的就是這個   Thread 執行緒 線程 一個進程裡至少會有一個線程，表示內部的一條執行路徑。把進程比喻為一個工廠，線程則是工廠裡面的工人，負責任務的實際執行。同一個Process內的Thread使用相同的Memory Space，但這些Thread各自擁有其Stack。換句話說，Thread能透過reference存取到相同的Object，但是local variable卻是各自獨立的。白話:共享方法區跟堆，獨立棧跟計數器   Coroutine 協程 協程 輕量級的執行緒，由使用者掌控，例如GO的goroutine   Concurrent 並行 並發 一個 CPU 會去做多件事，但是同一個時間點之內只會做一件事，像是早上做 Job1、下午做 Job2、晚上做 Job3不斷的切換，目標是希望能做更多的事   Parallel 平行 並行 多個 CPU 在同一個時間點內會去做多件事，例如會有三個人同時分別在做 Job1、Job2、Job3 的事情。目標是希望能把事情更快速的做完。    需求來源  希望同時執行複數的任務，例如一邊執行main方法，GC一邊收垃圾 需要等待的狀況，例如等用戶輸入、等IO、等網路連接  Java多線程-方法一   造一個類，繼承Thread</description>
    </item>
    
    <item>
      <title>項目練習3-開發團隊調度系統</title>
      <link>https://yoziming.github.io/post/211202-agg-ja-17/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211202-agg-ja-17/</guid>
      <description>項目練習3-開發團隊調度系統  雖然不是特別難，實做一遍還是會遇到不少坑，以下個人復盤的筆記
  A類中用到B類的物件，引包後可以直接&amp;quot;private B類 物件名=new B類&amp;quot;一個預設的來用 忽略大小寫可用equalsIgnoreCase 繼承的子類重複用到結構類似的方法，提取出相同因子在父類做一個public的然後去子類各自重寫，也能用來解決孫子super不到爺爺的困境 遍歷時注意.length的長度是在數組建立時就定死了，絕對不等於當前數組內的元素個數，如果遍歷.length有可能去遍歷到後面null的指針而報錯 單純只是想遍歷最好用for-each 手動複製數組使用System.arraycopy 方法形參是父類，想篩選傳進來的是否為某具體子類，用&amp;quot;if(!(物件 instanceof 子類))可以優雅的判斷 switch-case如果沒有return記得break  </description>
    </item>
    
    <item>
      <title>利用bat一鍵更新HugoBlog</title>
      <link>https://yoziming.github.io/post/211201-blog-one-key-update/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211201-blog-one-key-update/</guid>
      <description>一鍵更新   透過.bat一鍵打包+git發布上傳到你的github專案倉庫
  既然是個人的倉庫，首先要解決一個權限問題，否則隨便路人都可以亂上傳到你的倉庫豈不是亂套
  作法簡單來說，在電腦本機生成一個key(一串暗號)，然後到github網頁上設定，約好拿這個key來的人就允許上傳
  生成本機key $ ssh-keygen # 產生金鑰Generating public/private rsa key pair.Enter file in which to save the key : # 金鑰存放路徑，預設會放到我的文件/.ssh# 放哪不是特別重要，有強迫症可以自己改，否則直接按EnterEnter passphrase (empty for no passphrase): # 密碼，可設定可不設定，設定的話每次上傳會多需要輸入一次密碼Enter same passphrase again: # 再輸入一次密碼The key fingerprint is: # 之後會顯示你的 fingerprint，到這裡就完成 key 的產生了將key報備到專案  到生成的路徑，找id_rsa.pub，右鍵筆記本編輯打開，會看到很長一行開頭是&amp;quot;ssh-rsa &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&amp;quot;，全選複製   回你的github專案   內容貼上剛剛複製的那行 自己給這個key起個名，懶得命名可以取剛剛那串最尾的&amp;quot;使用者@電腦&amp;quot;當名稱  建立批次執行檔 起一個.</description>
    </item>
    
    <item>
      <title>異常處理:try、catch、finally、throw</title>
      <link>https://yoziming.github.io/post/211201-agg-ja-16/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211201-agg-ja-16/</guid>
      <description>異常的分類 在Java中，程序執行中的異常分為Exception與Error，他們都繼承自Throwable
(語法錯誤跟邏輯錯誤那不叫異常)
Error   錯誤，JVM系統內部錯誤虛擬機無法解決的問題、資源耗盡等嚴重情況，比如:
  無限迴圈產生堆疊溢位(Stack Overflow)
  寫錯分配導致記憶體不足(Out-Of-Memory)，
    解決方法就是把它寫對
  Exception   例外，發生了出乎預料的事，又依&amp;quot;受不受檢&amp;quot;分成
  Checked Exception:又稱編譯時異常，通常在原始碼中必須顯式地catch並且處理，比如:
  IOException、讀取文件不存在
  ClassNotFoundException
  這部分在compile time就會檢查
    Unchecked Exception:又稱RuntimeException，運行時異常，比如:
 NullPointerException，空指針訪問 ArrayIndexOutOfBoundsException，數組角標越界 ClassCastException，類型轉換異常 NumberFormatException，數字類型不合 InputMismatchException，輸入數據不符合，例如scan int結果來了字串 ArithmeticException，算法異常，例如把某數除以0 通常是透過撰寫相應程式以避免的邏輯錯誤, 可以根據當下的情境來判斷是不是要catch    異常處理 代碼執行時，一旦出現異常，就會在異常處生成一個對應異常類的物件，並將其拋出，拋出後的代碼就不再執行
try-catch   格式:
try { int num = Integer.parseInt(str); } catch (NumberFormatException e) { e.</description>
    </item>
    
    <item>
      <title>抽象abstract、接口interface、內部類</title>
      <link>https://yoziming.github.io/post/211130-agg-ja-15/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211130-agg-ja-15/</guid>
      <description>抽象abstract  隨著繼承不斷疊代，子類越來越具體，而父類越來越通用。
類的設計必須保證子類與父類共有特徵，有時候我們將父類設計得非常抽象，以至於它沒有具體的實例，這樣的類稱為抽象類。
 定義  abstract屬於Java中的關鍵字，可以用來修飾類與方法，以下分別說明  abstract修飾類  此類不能實例化 必定有構造器被繼承 開發中都會提供抽象類的子類，讓子類形成實例來調用 不能修飾final類，final類規定不能被繼承，玩毛線  abstract修飾方法  稱為抽象方法，只有聲明，沒有方法體 (就沒要讓你具體用) 此方法不能被調用 包含抽象方法的類，必定是一個抽象類。反之抽象類不一定要有抽象方法 實際開發中的調用必須是被子類繼承後重寫，所有的抽象方法都被重寫後此子類才能實例化(否則，存在繼承來的抽象方法你就是個抽象類) 不能修飾私有private方法，因為抽象就是為了被繼承，抽象與其矛盾 不能修飾靜態static方法，靜態方法跟類共存亡，可以直接被類調用，通常是去弄靜態屬性的，抽象與其矛盾 不能修飾final方法，final方法規定是不能被重寫，抽象與其矛盾  應用-模板方法設計 在軟體開發中，實現某種功能時，整體中很固定、通用的方法，在父類中就寫好了；而其他不確定、易變的就先抽象起來，交給子類去實現
匿名子類的匿名對象  在一次性使用的場合，不想實際造一個匿名類的實體子類，可以在new 匿名類()後面接{}，{內直接重寫方法，範例:
 abstract public class Person { abstract public void work(); } public class Student extends Person { @Override public void work() { System.out.println(&amp;#34;學生讀書&amp;#34;); } public static void main(String[] args) { method(new Student()); method(new Person() { @Override public void work() { System.</description>
    </item>
    
    <item>
      <title>關鍵字:static、main、final、代碼塊、單例模式</title>
      <link>https://yoziming.github.io/post/211129-agg-ja-14/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211129-agg-ja-14/</guid>
      <description>關鍵字static  意義:靜態的，類中共用的，生命週期跟隨類的 使用對象:屬性、方法、內部類、代碼塊，以下分別說明  使用static修飾屬性   稱為&amp;quot;靜態變量&amp;quot;或&amp;quot;類變量&amp;quot;
  先複習關於變量的知識
   實例變量是每個造出來的物件各自有的，比如:大明跟小明各自的age不同 類變量是整個類共用的，比如:大明跟小明的nation都是TW  類變量隨著類的加載而加載，可以通過&amp;quot;類.靜態變量&amp;quot;進行調用 物件沒創建之前類變量就已經存在 由於類只會加載一次，靜態變量在記憶體中也只存在一份，位於方法區的靜態域   在哪應用靜態屬性:  類中共用的，生命週期跟隨類的  舉例:構造器中自動生成編號的基數(比如從1001開始、1002..)   常量也常聲明為static，再加上final修飾  舉例:Math.PI      使用static修飾方法  稱為靜態方法，規則大致與上面相同 隨著類的加載而加載，可以通過&amp;quot;類.靜態方法&amp;quot;進行調用 不能在靜態方法中調用非靜態的屬性或方法(畢竟沒有物件) 在靜態方法中，不能使用this或super關鍵字(物件都沒出生當然不能用) 在哪應用靜態方法:  操作靜態屬性的方法，通常設為靜態 工具類的方法，比如Math、Array、Collections    單例(singleton)設計模式   定義:整個系統中，強制某個類只存在一個實例，減少資源消耗
  應用場合:
 網站的計數器，只造一個，不然難以同步 日誌:通常是一個日誌文件一直被開著，最好只有一個實例去操作它 數據庫的連接池 Windows的Task Manager跟Recycle Bin也是很典型的單例    &amp;ldquo;餓漢式&amp;quot;實現:
  私有化的構造器</description>
    </item>
    
    <item>
      <title>多態:instanceof、object類、包裝類</title>
      <link>https://yoziming.github.io/post/211128-agg-ja-13/</link>
      <pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211128-agg-ja-13/</guid>
      <description>多態性  類似go接口的概念，就是為了讓子類能調用父類的方法
白話:為了實現代碼的通用性
   一個事物的多種形態
  父類的引用指向子類的物件(子類的物件賦給父類的引用)，舉例:
Father obj = new Child();   使用:虛擬方法調用，編譯期只能調用父類中聲明的方法，但運行時執行的是子類重寫父類的方法。多態只有在運行那一個才知道要調用哪個方法，即多態是個運行時行為，又稱為動態綁定
 白話:編譯看左，運行看右    前提:類的繼承關係、方法的重寫，缺一不可
  目的:避免重複寫很多重載的方法
  體現:
  舉例Person類 之下有子類 Chinese、Japanese、American Person類有welcome方法，被各自子類以該國語言重寫過 我的某功能調用welcome時能接受Person類，依照實際子類物件呈現不同語言的welcome結果 該功能即不需要Chinese、Japanese、American都寫一次   public class Atest { public static void main(String[] args) { Atest test = new Atest(); test.func(new Dog()); // 多態體現在這  } public void func(Animal animal) { //Animal animal=new Dog();  animal.</description>
    </item>
    
    <item>
      <title>繼承:方法重寫、super、物件實例化</title>
      <link>https://yoziming.github.io/post/211127-agg-ja-12/</link>
      <pubDate>Sat, 27 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211127-agg-ja-12/</guid>
      <description>繼承 好處  減少代碼冗餘、提高復用性 便於功能擴展 為多態鋪路  格式 class A extends B{} // A延展了B A:子類、派生類、subclass B:父類、超類、基類、superclass 繪圖時，通常用實心箭頭從子指向父，例如:Student→Person，表示學生類繼承了人類
特性  A繼承B之後，子類A就獲取了B聲明的所有屬性與方法，包含了私有(private)的，但是由於封裝性的影響，子類無法直接調用父類私有(private)的屬性與方法 不允許多重繼承(一人只能有一個老爸) 可以多層繼承(允許有孫子，孫子也會繼承爺爺的特性) 一個父類可以有多個子類(允許家族開枝散葉) 所有類都繼承自java.lang.Object，換言之所有類都具有Object類的特性  權限修飾符protected的應用  之前提過protected的範圍是不同包的子類也能用，就是應在這了  實際發開中用的比較少一點    方法的重寫   子類繼承父類後，對父類同名同參數的方法，進行覆蓋
  子類重寫的方法權限修飾符必須不小於父類被重寫的方法
 白話:不能把公車私有化，權限範圍不能縮小 注意:不能重寫父類中聲明為private的方法(本身就見不到)，可以在子類中硬寫一個同名的方法，但那就不是構成重寫    若父類被重寫的方法返回值是void，子類重寫的方法也必須返回void
  若父類被重寫的方法返回值是A類型，子類重寫的方法返回值可以是A類或A類的子類
 舉例:父類返回值是動物類，子類可以重寫返回動物類或貓類狗類    若父類被重寫的方法返回值是基本數據類型，子類重寫的方法返回值必須是相同基本數據類
 舉例:父類返回double子類也必須是double，不能是int期待他自動類型提升    拋出異常(throws)的規則與返回值相同
  以上白話小結:權限不能小於爸爸、返回值不能大於爸爸
  補充:子類與父類同名同參數的方法要嘛都聲明為非static的(考慮重寫)，要嘛都聲明為static的(不是重寫，靜態類的方法不能被覆蓋)
  關鍵字super 用來表示父類中的屬性、方法、構造器</description>
    </item>
    
    <item>
      <title>項目練習2-客戶訊息管理</title>
      <link>https://yoziming.github.io/post/211126-agg-ja-11/</link>
      <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211126-agg-ja-11/</guid>
      <description>項目練習-客戶訊息管理  有點基礎這部分都蠻簡單的
 有個知識點是這邊在&amp;quot;刪除用戶&amp;quot;的功能用到了循環鏈表的概念
public boolean deleteCustomer(int index) { if (customers[index] != null) { for (int i = index; i &amp;lt; total - 1; i++) { // 不能搬到total，否則[i+1]會越位  customers[i] = customers[i + 1]; } customers[total - 1] = null; total--; System.out.println(&amp;#34;刪除用戶成功!&amp;#34;); return true; } System.out.println(&amp;#34;索引無效，操作失敗&amp;#34;); return false; } total表示當前數組中用戶總數，這個i &amp;lt; total - 1蠻關鍵的，我原先沒想到這邊要-1，還想著讓他把後面的null往前搬就好，沒考慮到末尾可能會越位的情況。
搬完再跟customers[total - 1] = null搭配使用，這樣才是健壯的</description>
    </item>
    
    <item>
      <title>封裝性、構造器、this、包</title>
      <link>https://yoziming.github.io/post/211125-agg-ja-10/</link>
      <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211125-agg-ja-10/</guid>
      <description>封裝的設計思想   高內聚:類的內部數據操作細節自己完成，不允許外部干涉
  低耦合:對外露出少量的方法(API)供使用
   舉例:微波爐，我不需要用戶控制燈光、波照、轉盤等等，只要他放入東西按下&amp;quot;解凍&amp;quot;即可。即所謂的&amp;quot;一鍵XX&amp;quot;功能。
 封裝性的體現  將類的屬性私有化(private)，通過公共的(public)的set與get方法讓外部調用，舉例:  public class Main { public static void main(String[] args) { Animal a1 = new Animal(); a1.setAge(10); System.out.println(a1.getAge()); } } class Animal { private int age; public void setAge(int i) { age = i; } public int getAge() { return age; } }  不對外公開的私有方法(比如對外是各種排序方法，內部自己寫了一個交換兩數據位置的&amp;quot;小工具&amp;quot;) 單例模式(將構造器私有化) &amp;hellip;等等 需要權限修飾符來配合  權限修飾符  JAVA中有4種權限修飾符，各自的範圍是: (從小到大，下包含上)
  private:限當前類內部使用 default(缺省，就是不寫):同一個包名就可以調用 protected:不同包它的子類可以調用 public:相當於開放的  修飾的對象  以上4種可以用於修飾類的內部結構:屬性、方法、構造器、內部類 class本身的修飾只能是缺省或public，一個.</description>
    </item>
    
    <item>
      <title>細說方法、重載、值傳遞</title>
      <link>https://yoziming.github.io/post/211124-agg-ja-09/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211124-agg-ja-09/</guid>
      <description>細說方法 方法的重載(overload)  定義:同一各類中，允許存在一個以上的同名方法，只要他們的參數個數或參數類型不同即可 跟方法的權限修飾符、返回值類型、形參變量名、方法體無關，判斷重點在於參數本身 可能會自動類型提升，舉例:傳入的是int形，方法中沒有int但有double，就會調用double 典型的例子就是內建的println()  可變個數形參  格式:方法名(形參類型 &amp;hellip; 形參名) 調用時傳入的形參數量可以是0到多個，包含數組 與本類中方法名相同，形參不同的方法間構成重載(可共存) 與本類中方法名相同，形參類型也相同的數組之間不構成重載(不可共存)  PS.這是歷史遺留問題，因為可變個數形參是JDK5加入的，以前都是用數組   方法內把它當作數組使用，遍歷itar (i=0;i&amp;lt;形參名.length;i++){} 必須聲明在末尾，且最多只能有一個  方法參數的值傳遞 先複習一下變量的賦值規則  變量是基本數據類型(byte、short、int、long、char、float、double、boolean)，賦值的是變量所保存的數據值 變量是引用類型(引用類型就只有null跟地址值兩種情況)，賦值給的是所保存數據的地址值  名詞解釋  形參:方法定義時，聲明的小括號中的參數 實參:方法調用時，實際傳給形參的數據  傳參規則  跟變量的賦值規則其實相同
  如果參數是基本數據類型，實參賦給形參的是數據值(類似給一份副本) 如果參數是引用類型，實參賦給形參的是地址值(包含變量的數據類型)  陷阱題  println在char[]這有個特例，要避免踩坑就是調用時多看看方法格式
 int[] arr1 = new int[]{1, 2, 3}; System.out.println(arr1); // [I@1b6d3586 char[] arr2 = new char[]{&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;}; System.out.println(arr2); // abc 練習-在方法中引用其他類的方法並調用 public class Main { public static void main(String[] args) { PassObject t1 = new PassObject(); Circle c = new Circle(); t1.</description>
    </item>
    
    <item>
      <title>物件導向:基本概念與學習路線</title>
      <link>https://yoziming.github.io/post/211123-agg-ja-08/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211123-agg-ja-08/</guid>
      <description>物件導向  Object-oriented programming中國翻為&amp;quot;面向對象&amp;quot;，台灣則翻為物件導向
我個人也覺得&amp;quot;物件導向&amp;quot;翻的比較信雅達，可以參考這篇知乎問答的解釋
https://www.zhihu.com/question/22515658/answer/120754062
 概念 首先用咖啡機煮咖啡為例:
過程導向(Process-oriented)  過程導向強調的是功能行為，以函數為最小單位，考慮如何做
   執行加咖啡豆方法
  執行加水方法
  執行煮咖啡方法
  執行喝咖啡方法
  物件導向(Object-oriented)  物件導向則是先將功能封裝進物件，強調具備功能的物件，以類/物件為最小單位，考慮誰來做
 在執行煮咖啡操作前要抽象出：人和咖啡機（分類），然後開始執行：
  人.加咖啡豆
  人.加水
  咖啡機.煮
  人.喝咖啡
  物件導向的三大特徵  封裝(Encapsulation) 繼承(Inheritance) 多態(Polymorphism)  類和實例 類(class):抽象的模板、概念上的定義
物件(object):是實際存在的個體，也稱為實例(Instance)
 比如說有輪子、吃汽油跑的是汽車類。小弟的車new march則為實例
 類的設計  設計類其實就是設計類的成員
 屬性(field):成員變量，又稱域、字段、欄位
行為(method):成員方法，又稱函數
舉例:汽車類的屬性有輪子大小、有品牌名稱；汽車的行為有吃汽油跑
練習-在JAVA創建類並實例化 class Car { // 屬性  String brand; String owner; boolean isNew = true; // 可以給預設值  // 行為(方法)  public void crash() { if (isNew) { System.</description>
    </item>
    
    <item>
      <title>數組的填值、複製、查找、排序、常用工具類</title>
      <link>https://yoziming.github.io/post/211122-agg-ja-07/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211122-agg-ja-07/</guid>
      <description>數組常用算法 數據結構  程序=數據結構+演算法
  數據間的邏輯關係:集合、一對一、一對多、多對多 數據的儲存結構:  線性表:順序表(如:數組)、鏈表、棧、隊列 樹形結構:二叉樹 圖形結構    演算法-Algorithm   排序
  檢索
  加密
  &amp;hellip;
  練習題-帕斯卡三角  形狀不是很漂亮
 int[][] arr = new int[10][]; for (int i = 0; i &amp;lt; arr.length; i++) { arr[i] = new int[i + 1]; // 兩外邊都是1  arr[i][0] = 1; arr[i][i] = 1; if (i &amp;gt; 1) { for (int j = 1; j &amp;lt; arr[i].</description>
    </item>
    
    <item>
      <title>數組Array</title>
      <link>https://yoziming.github.io/post/211121-agg-ja-06/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211121-agg-ja-06/</guid>
      <description>數組Array  多個相同類型的數據按一定的順序排列的集合
 結構  數組名 元素 下標aka角標/索引 長度(元素的個數)  特性  數組本身是引用數據類型，其中的元素可以是任何類型 數組的排列是有序的 在記憶體中開闢一整塊連續的空間，數組名引用的是這塊連續空間的首地址 長度確定後就不可更改  聲明與初始化  數組必須初始化才能使用
  方法1-靜態初始化，創建時填入已知的元素內容，由系統判定長度  int[] array1; // 聲明 array1 = new int[]{1, 2, 3}; // 靜態初始化:同時對元素賦值了 // 也可以合併成 int[] array1 = new int[]{1, 2, 3}; // 可以再縮寫成 (類型推斷) int[] array1 = {1, 2, 3};  方法2-動態初始化，創建時填入已知的長度，元素內容為0或空(系統默認，後述)  int[] array3 = new int[3]; // 動態初始化，注意後面的[5]是指長度 訪問數組內的元素  沒特別的，一樣從0~長度-1。長度=array.length
 舉例:array[0]、array[1]&amp;hellip;array[array.length-1]</description>
    </item>
    
    <item>
      <title>台灣人常唸錯的IT英文單字</title>
      <link>https://yoziming.github.io/post/211120-it-english-taiwanese-problems/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211120-it-english-taiwanese-problems/</guid>
      <description>台灣人常唸錯的IT英文單字  非母語有一些口音在所難免，我不求最正宗的發音，但至少不太要離譜甚至產生歧意，畢竟能夠順利溝通交流才是最重要的
 cache，錯誤&amp;quot;catch&amp;quot;，正確它和&amp;quot;cash&amp;quot;同音
archive，錯誤&amp;quot;阿起府&amp;quot;，正確&amp;quot;阿-凱f&amp;quot;，f幾乎不發音
SQL，錯誤&amp;quot;circle&amp;quot;，正確&amp;quot;see-qual&amp;quot;
hidden，錯誤&amp;quot;嗨-等&amp;quot;，正確&amp;quot;he-等&amp;quot;
suite，錯誤&amp;quot;訴-特&amp;quot;，正確&amp;quot;sweet&amp;quot;，發音相同都是swēt
virtual，錯誤&amp;quot;V-糗&amp;quot;，正確&amp;quot;ver-秋歐&amp;quot;，虛擬的
visual，正確&amp;quot;V-九歐&amp;quot;，視覺的，微軟的Visual Studio Code是這個
mobile，錯誤&amp;quot;哞比歐&amp;quot;，正確&amp;quot;ㄇㄡ-ㄅㄛˇ&amp;quot;
maintain，man-ten，動詞維護
maintenance，名詞維護，正確&amp;quot;咩-特-ㄋㄜˇ-死&amp;quot;4個音，重音在特
module，正確&amp;quot;媽-九&amp;quot;
enum，正確&amp;quot;衣-囊&amp;quot;，名詞枚舉
enumerate，正確&amp;quot;以-new-merate&amp;quot;，動詞枚舉
annotation，正確&amp;quot;A-ㄋ-tation&amp;quot;，名詞註解
Azure，正確&amp;quot;阿九兒&amp;quot;，連一起速念
parameter，錯誤&amp;quot;怕拉-咪特&amp;quot;，正確&amp;quot;ㄆ˙-ㄌㄩㄝ-ㄇ˙-ter&amp;quot;4個音，第一是輕聲ㄆ，重音在第二個音節
error，錯誤&amp;quot;ㄟ摟&amp;quot;，正確&amp;quot;ㄟ-惹&amp;quot;
format，錯誤&amp;quot;否-妹t&amp;quot;，正確&amp;quot;F歐-美t&amp;quot;
Period，正確&amp;quot;P-re-诶&amp;quot;
copy，錯誤&amp;quot;摳比&amp;quot;，正確&amp;quot;咖痞&amp;quot;
lambda，正確&amp;quot;ㄌ一ㄢ-打&amp;quot;
image，錯誤&amp;quot;一美舉&amp;quot;，正確&amp;quot;一米舉&amp;quot;
Algorithm，正確&amp;quot;凹狗-rithm&amp;quot;
width，錯誤&amp;quot;wide&amp;quot;，正確&amp;quot;with&amp;quot;，當作d不存在
lock，錯誤&amp;quot;肉可&amp;quot;，正確&amp;quot;辣可&amp;quot;
query，錯誤&amp;quot;誇-李&amp;quot;，正確&amp;quot;ㄎㄨㄧ-ㄜˇ-ry&amp;quot;3音連速念
confirm，錯誤&amp;quot;康鳳&amp;quot;，正確&amp;quot;ken-firm&amp;quot;，firm=&amp;ldquo;份兒&amp;quot;連念。這是認證、確認的意思
conform，錯誤&amp;quot;康鳳&amp;rdquo;，正確&amp;quot;ken-form&amp;quot;。這是符合的意思，兩字常常誤用誤念
register，錯誤&amp;quot;re-季-ster&amp;quot;，正確&amp;quot;ㄌㄩㄝ-幾-ster&amp;quot;
Arduino，正確&amp;quot;阿督衣no&amp;quot;
result，錯誤&amp;quot;re-造&amp;quot;，正確&amp;quot;re-奏特&amp;quot;，奏特連念
chrome，錯誤&amp;quot;恐龍米&amp;quot;，正確&amp;quot;窟窿&amp;quot;連念到近乎一個音
null，有些人念&amp;quot;怒偶&amp;quot;，正宗應為&amp;quot;鬧&amp;quot;、或&amp;quot;NO&amp;quot;，但這跟區域有關係，就算誤念成nil大概也能懂，不用太強求
record，做名詞紀錄時，正確&amp;quot;ㄌㄩㄝ-渴d&amp;quot;，d幾乎不發音
record，做動詞紀錄時，正確&amp;quot;re-扣d&amp;quot;，規律幾乎都是名詞重音在前，動詞重音在後
resume，做名詞履歷時，正確&amp;quot;ㄌㄩㄝ-su-美&amp;quot;，重音在前
resume，做動詞恢復時，正確&amp;quot;re-zoom&amp;quot;，重音在後
modem，錯誤&amp;quot;某店&amp;quot;，正確&amp;quot;ㄇㄡ-等&amp;quot;
cancel，正確&amp;quot;ken-叟&amp;quot;，取消
cancer，正確&amp;quot;ken-ser&amp;quot;，癌症，兩字常常誤用誤念
guarantee，正確&amp;quot;ㄍㄟ-掄-替&amp;quot;
standard，錯誤&amp;quot;stan-打&amp;quot;，正確&amp;quot;stan-得兒&amp;quot;
execute，正確&amp;quot;ㄟ-ser-cute&amp;quot;
compile，正確&amp;quot;康-派-偶&amp;quot;，動詞編譯
compiler，正確&amp;quot;康-派l-惹&amp;quot;，l幾乎不發音，名詞編譯器
exit，正確&amp;quot;ㄟㄎ-sit&amp;quot;，常誤念成exist
vehicle，正確&amp;quot;V-诶口&amp;quot;</description>
    </item>
    
    <item>
      <title>嵌套循環、break、continue、項目練習1-家庭收支</title>
      <link>https://yoziming.github.io/post/211120-agg-ja-05/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211120-agg-ja-05/</guid>
      <description>嵌套循環  就是for中有for，有時候需要多花點時間理解
  內層循環整個遍歷完，外層循環才執行一次 假設外層循環要執行m次，內層循環要執行n次。整個跑完內層循環一共執行了m*n次  練習題-印菱形 Scanner scan = new Scanner(System.in); System.out.println(&amp;#34;輸入想印的菱形邊長n=...&amp;#34;); int n = scan.nextInt(); // 上半部分(含中間最長邊) for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt; n - i; j++) { System.out.print(&amp;#34; &amp;#34;); } for (int k = 0; k &amp;lt; i; k++) { System.out.print(&amp;#34;* &amp;#34;); } System.out.println(); } // 下半部分(從最長-1開始) for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt; i; j++) { System.</description>
    </item>
    
    <item>
      <title>流程控制:if、switch、for、while</title>
      <link>https://yoziming.github.io/post/211119-agg-ja-04/</link>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211119-agg-ja-04/</guid>
      <description>分支控制 if-else  基礎都一樣不多贅述
   特殊情況有人不加{}，這種情境下就近原則且只控制一行(到第一個;為止)
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); System.out.println(&amp;#34;b&amp;#34;); System.out.println(&amp;#34;c&amp;#34;); 結果為 b c   只有單行時可以接else且也會就近選擇
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); else System.out.println(&amp;#34;d&amp;#34;); 結果為d   多行時直接報錯
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); System.out.println(&amp;#34;b&amp;#34;); System.out.println(&amp;#34;c&amp;#34;); else 報錯   小結:不加{}的全部拖出去打
  switch-case   結構:
switch (表達式) { case 常量1: // 執行語句  break; case 常量2... ... default: // 預設執行語句 }   如果不加break;就不會跳出，而是會穿透且之下的語句全都執行一遍
  基於上述特性，可以合併使用，舉例:</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA設定與常用快捷鍵</title>
      <link>https://yoziming.github.io/post/211117-intellij_idea-shortkey/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-intellij_idea-shortkey/</guid>
      <description>IDEA基礎設定   安裝的根目錄，舉例&amp;hellip;\IntelliJ IDEA 2021.2.3\bin\idea64.exe.vmoptions
編輯這個idea64.exe.vmoptions，改成-Xmx1024m -Xms2048m
  ctrl+alt+s開啟設定 -&amp;gt; plugins插件 -&amp;gt; 搜尋chinese -&amp;gt; 安裝重啟 -&amp;gt; 中文化
  plugins插件 -&amp;gt; 搜尋save actions-&amp;gt; 安裝重啟 -&amp;gt; 存檔時自動格式化
  外觀-使用自定義字體打勾-Sarasa mono&amp;hellip;，大小改14
   強烈建議使用更紗黑體Sarasa-Gothic https://github.com/be5invis/Sarasa-Gothic 特性:融合Iosevka(程式碼常用的等寬字型)跟Source Han Sans(思源黑)，有等距、繁簡中日韓不缺字，簡直完美
   編譯器-字體-一樣改，大小我是設18、行高1.1
  編譯器-代碼樣式-Java-空行-保持最大空白行，前三項我都設1，太多空白可自動刪除
  佈景主題推薦one dark，這也是最多人用的
  Rainbow Brackets 括弧變色
  IDEA常用快捷鍵 視窗  Close All Tabs : alt + w Terminal : ctrl + alt + 0  選取  选中下一个相同内容的快捷键(vs code中的Ctrl+D)：Alt + J 依照個人習慣我還是把它改成ctrl + D了，原本ctrl + D(複製當前行)改成alt+ shift + ↓  以「行」為單位  複製 : ctrl + D 移動 : ctrl + shift + ↑/↓ 註解 : ctrl + / 刪除 : ctrl+x(其實是剪下)  以「區塊」為單位  擴增選取 : ctrl + W 遞減選取 : ctrl + shift + W 更改大小寫 : ctrl + shift + U  自動功能 :  自動補全 : alt + enter 自動產生 : alt + Ins 自動排版 : ctrl + alt + L 自動移出未使用 import : ctrl + alt + O  顯示形參列表:ctrl+p 查找當前文件結構(有哪些方法、屬性):ctrl+F12 </description>
    </item>
    
    <item>
      <title>運算符:邏輯運算、自增減、賦值、位運算、三元</title>
      <link>https://yoziming.github.io/post/211118-agg-ja-03/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211118-agg-ja-03/</guid>
      <description>運算符 加減乘除  基本都一樣不再贅述
 % 取餘的規則  結果的符號與被取餘的數符號相同，舉例-12%5=-2、12%-5=2、-12%-5=-2 實際開發中取餘常用來判斷是否能除盡  自增自減的規則  ++a，(前++)先運算後取值，舉例a=2;b=++a;結果a=3;b=3 a++，先取值後運算，舉例a=2;b=a++;結果a=3;b=2 &amp;ndash;a，先運算後取值，舉例a=2;b=&amp;ndash;a;結果a=1;b=1 a&amp;ndash;，先取值後運算，舉例a=2;b=a&amp;ndash;;結果a=1;b=2 自增減不會改變數據類型(但可能會溢位) 不可連用，舉例a++++會報錯  另外+也能用在字符串聯接，舉例&amp;quot;he&amp;quot;+&amp;ldquo;llo&amp;rdquo;=&amp;ldquo;hello&amp;rdquo;
= 賦值的規則  可以連續賦值，舉例int i1,i2; i1=i2=10; int i3=10,j3=20; +=、-=、*=、/=、%= 不會改變數據類型 面試題n=10; n+=(n++)+(++n); n=? 解: 拆成 n = n + 10 + 12 =32  邏輯運算符  乍看邏輯跟短路結果是一樣，實際使用上差異為短路後的東西就不執行了 舉例: b=false; n=10; b &amp;amp;&amp;amp; (n++&amp;gt;0)=false，但n=10  位運算符   操作的都是整數 &amp;laquo; 向左移一位相當於*2，&amp;raquo;向右移一位相當於/2，有可能溢位   三元運算符  結構: (條件表達式) ? 表達式1 : 表達式2 說明: 條件表達式=boolean，如果是true則執行表達式1，反之執行2 表達式1 與 表達式2 要求一致(至少能裝進同一個類型) 其實就是簡易版的if，可以嵌套使用  優先級   基本原則是從上到下，從左到右，括號優先 自增減、賦值運算、三元運算才從右往左看  </description>
    </item>
    
    <item>
      <title>關鍵字、變量、數據類型、數據轉換</title>
      <link>https://yoziming.github.io/post/211117-agg-ja-02/</link>
      <pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-agg-ja-02/</guid>
      <description>關鍵字 關鍵字  有特殊含意與用途，所有關鍵字都是小寫
 例如:if、new&amp;hellip;等等，後面都會一一接觸到
保留字  未來版本可能會用到而保留
 例如:goto、const
標識符(identifier)  可以自己命名的(類、變量、函數&amp;hellip;等)就叫標識符
   由字母、數字、_、$組成
  數字不可為開頭
  能包含關鍵字但不能純用關鍵字
  嚴格區分大小寫
  不能包含空格
標識符的命名規範  不強制但最好遵守
   包名:多單詞所有字母小寫aaabbbccc
  類名、接口名:大駝峰(首字母大寫)AaaBbbCcc
  變量名、方法名:開頭小寫後面首字母大寫(小駝峰)aaaBbbCcc
  常量名:全大寫，用下畫線相連AAA_BBB_CCC
  命名要有意義，見名知意
  變量(variable)  記憶體中的一個儲存區域，使用的基本單位
  必須先聲明，後使用 作用域在其定義所在的一對{}內，只在其作用域中有效 同一作用域中不可重複  數據類型 基礎數據類型  六種數字類型（四個整數型，兩個浮點型），一種字符類型，還有一種布爾型。
 byte  byte數據類型是8位、有符號的，以二進制補碼表示的整數 最小值是-128（-2^7）最大值是127（2^7-1）默認值是0 byte類型用在大型數組中節約空間，主要代替整數，因為byte變量佔用的空間只有int類型的四分之一 例子：byte a = 100，byte b = -50。  short  short數據類型是16位、有符號的以二進制補碼表示的整數 最小值是-32768（-2^15）最大值是32767（2^15 - 1）默認值是0 Short數據類型也可以像byte那樣節省空間。 一個short變量是int型變量所佔空間的二分之一 例子：short s = 1000，short r = -20000。  int  int數據類型是32位、有符號的以二進制補碼表示的整數 最小值是-2,147,483,648（-2^31）最大值是2,147,483,647（2^31 - 1）默認值是0 一般整型變量默認為int類型 例子：int a = 100000, int b = -200000。  long  long數據類型是64位、有符號的以二進制補碼表示的整數 最小值是-9,223,372,036,854,775,808（-2^63） 最大值是9,223,372,036,854,775,807（2^63 -1） 這種類型主要使用在需要比較大整數的系統上 必須以L(大小都可)結尾，不加自動被當成int 默認值是0L 例子： long a = 100000L，Long b = -200000L。  float  float的儲存結構是1個符號位，8個指數位，23個尾數，符合IEEE 754標準的浮點數 可以看做float只有24位來表示精度，所以int或long轉float可能會有精度損失。 必須以F(大小都可)結尾，不加報錯 默認值是0.</description>
    </item>
    
    <item>
      <title>Java簡介、名詞認識、環境配置、HelloWorld</title>
      <link>https://yoziming.github.io/post/211116-agg-ja-01/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-agg-ja-01/</guid>
      <description>認識Java、環境配置 常用DOS操作  就是windows的cmd，影視中駭客情節常常出現的小黑窗，可以用文字操作基本的軟體功能
   cd=進入指定目錄
  cd..=回上層
  cd=回到根目錄
  變更硬碟目錄=直接輸入d:
  dir=列出當前目錄下的清單
  del=刪除檔案(對文件夾使用=刪除文件內所有檔案)
  md=創建目錄
  rd=刪除目錄
  exit=退出
  Java體系在不同平台的版本演化  Java SE，標準版，桌面級應用等，基礎API Java EE，企業版，主要用於Web開發，包含Servlet、JSP等技術 Java ME，小型版，古老的PDA、手機等，已過時 Java Card，面向小程序(Applets)，運行在小設備(如智能卡)等平台  Java語言特性  由繼承的脈絡可說JAVA是類C語言
  強制物件導向:總是基於&amp;quot;某件東西去做事&amp;quot;，得先搞懂何謂&amp;quot;類&amp;quot;與&amp;quot;物件&amp;quot;  三大特性:封裝、繼承、多態   健壯性:強類型、異常處理、GC(垃圾回收)、丟棄指針等 跨平台:只要平台能跑JVM(虛擬機)就能跑JAVA  Java的運行環境  JDK包含JRE包含JVM
  JDK，Java Development Kit，開發工具包，給開發人員用的，包含了JRE以及編譯工具(javac.exe)、打包工具(jar.exe)&amp;hellip;等等。 JRE，Java Runtime Environment，運行環境，包含JVM虛擬機和運作需要的核心類庫等等，簡單說就是運行由JDK做好的東西。  Java環境配置   下載JDK 8u202版本，最後的商用免費版(若純個人使用不論版本都是免費的)</description>
    </item>
    
    <item>
      <title>LeetCode:1.Two Sum、9.Palindrome Number、13.Roman to Integer</title>
      <link>https://yoziming.github.io/post/211116-leetcode1&#43;9&#43;13/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-leetcode1&#43;9&#43;13/</guid>
      <description>1. Two Sum
 求某數組中哪兩位數的和等於X
 // go // nums []int=傳入的數組；target=X func twoSum(nums []int, target int) []int { m := make(map[int]int, len(nums)) for i, num := range nums { if idx, ok := m[target-num]; ok { return []int{idx, i} } m[num] = i } return []int{0, 0} } 9. Palindrome Number
 判斷是否為迴文數字，例如121
 // java public boolean isPalindrome(int x) { // 判斷是否迴文，如121、2332、456654  // 負數或尾數是0或&amp;lt;10的顯然可以排除  if (x &amp;lt; 0 || (x !</description>
    </item>
    
    <item>
      <title>修改css或js後瀏覽器快取不更新問題</title>
      <link>https://yoziming.github.io/post/211017-explorer_cache_problems_with_cssjs/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211017-explorer_cache_problems_with_cssjs/</guid>
      <description>修改css或js後瀏覽器快取不更新問題  當初我真的是被這個整到懷疑人生
 解決方式一：
​ 使用者按Ctrl + F5強制重新整理頁面或者手動清空了瀏覽器的快取。此時瀏覽器會重新向伺服器獲取CSS和JS檔案,新的檔案便會生效。
解決方式二：
​ 但是使用者量過大的時候總不能讓每個使用者一一清理快取吧，於是便從程式碼的角度著手解決這個問題。在js後面新增版本號，讓瀏覽器把這個JS檔案當做新的檔案重新向伺服器獲取資源。
加版本號前：
 &amp;lt;script type=&amp;#34;text/javascript&amp;#34; th:src=&amp;#34;@{/js/test/index.js}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  加版本號後：
 &amp;lt;script type=&amp;#34;text/javascript&amp;#34; th:src=&amp;#34;@{/js/test/index.js?v=1.0}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  參考 https://www.itread01.com/content/1548610940.html</description>
    </item>
    
    <item>
      <title>Docker &amp; Hyper-V占用port問題</title>
      <link>https://yoziming.github.io/post/211015-dockerhyper-v-port-problem/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211015-dockerhyper-v-port-problem/</guid>
      <description>Docker &amp;amp; Hyper-V占用port問題 在window下用docker desktop有時候遇上port被莫名佔用 用指令netstat -ano | findstr xxx查詢xxx埠被誰佔用卻又顯示沒有
原來是因為在window下用docker需要依賴hyper-v技術， 而這個hyper-v每次都會隨機搶走一部分tcp埠，使用命令可以得知應避開的範圍:
# powershell / cmd netsh interface ipv4 show excludedportrange protocol=tcp 如果避不開就手動叫Hyper-V讓路   關閉hyper-v
# powershell / cmd dism.exe /Online /Disable-Feature:Microsoft-Hyper-V   配置ipv4動態埠 / 或者配置需要的埠不被佔用
# powershell / cmd 管理員許可權 # start 起始埠 num 表示可用埠數 按自己的需求來 netsh int ipv4 set dynamicport tcp start=30000 num=16383 // 叫他去用30000以後的阜 # 排除ipv4動態埠佔用 startport 起始埠 numberofports 埠數 netsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1 // 或是指定端口50051為要讓路的   重新啟動hyper-v</description>
    </item>
    
    <item>
      <title></title>
      <link>https://yoziming.github.io/post/99999999%E6%96%B0%E5%BB%BA%E6%96%87%E6%AA%94%E7%AF%84%E6%9C%AC/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/99999999%E6%96%B0%E5%BB%BA%E6%96%87%E6%AA%94%E7%AF%84%E6%9C%AC/</guid>
      <description>預設yaml檔頭標題 </description>
    </item>
    
    <item>
      <title>ubuntu常用操作</title>
      <link>https://yoziming.github.io/post/211010-ubuntu-common-operations/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211010-ubuntu-common-operations/</guid>
      <description>ubuntu常用操作  ubuntu 屋奔兔，算是最常見的Linux系統
 // 解壓縮XX檔案到/usr/local sudo tar -C /usr/local -xzvf go1.17.1.linux-amd64.tar.gz
// 文字編輯器 sudo gedit /home/yoziming/.config/go/env
// 檔案總管 sudo nautilus
// 啟用go mod go env -w GO111MODULE=on</description>
    </item>
    
    <item>
      <title>Kubernetes基礎認識</title>
      <link>https://yoziming.github.io/post/211006-k8s/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211006-k8s/</guid>
      <description>Kubernetes基礎認識  自動化地以容器的形式管理你的應用程式 To host your application in the form of containers in a automated fashion
 名詞解釋   Cluster:集群，計算、儲存資源的集合。一個Cluster通常包含一個Controller Plane和數個Node，視需求而定(也可能有Multi-Controller Plane 的集群)
 Controller Plane:(以前叫Mater)控制主節點，調度指揮所  APIserver:管理整個 K8s 所需 API 的接口(Endpoint)，提供HTTP Rest介面的關鍵服務處理程序，是集群中各個節點的溝通橋樑 etcd:存資料 Scheduler:資源調配，例如調度Pod運行在哪個Node Controller-manager:總經理，負責管理並運行 controller ，controller定義各種Pod的部屬特性(如最常用的Deployment)來滿足不同的業務場景   Node:節點，讓物件(resource-objects)運行的實體或虛擬機器  kubelet:對應api-server的接口，可以看成每個Node上的&amp;quot;實際執行者&amp;quot;或&amp;quot;操作者&amp;quot;，負責接收來自api-server的訊息，並做出相對應的動作，例如，負責Pod對應的容器的建立、啟動或停止等。 kube-proxy:維護網路規則(iptables)，這些規則允許從群集內部或外部的與Pod進行通訊。 Container Runtime:容器的運行引擎，預設是Docker，也支援其他滿足CRI標準的。  Pod:可被調度的最小單位，每個Pod包含一或多個容器，Pod內共享生命週期、資源、通信(使用同一個網路namespace，即相同的IP與port)、儲存空間。通常使用是一個Pod中放一個容器；當需要高度共享資源時才會用一個Pod內多個容器的形式      延伸觀念  Deployment:部屬，例如把Pod做橫向擴展，適用自動管理，或達成無停機系統升級 Service:服務，Deployment可以部屬多個Pod，每個Pod都有自己的IP，隨時都在生滅浮動，外界如何訪問? 答案就是透過Service，可以說Controller負責運行Pod，而Service負責訪問Pod。 Ingress:Service 中是將每個 Service 元件對外的 port number 跟 Node 上的 port number 做 mapping，這樣在我們的 Service 變多時，port number 以及分流規則的管理變得相當困難。而 Ingress 可以透過 HTTP/HTTPS，在我們眾多的 Service 前搭建一個 reverse-proxy。這樣 Ingress 可以幫助我們統一一個對外的 port number，並且根據 hostname 或是 pathname 決定封包要轉發到哪個 Service 上 Namespace:命名空間，假如有多個用戶使用同一個Cluster，想把他們創建的Controller、Pod等資源分開，就靠Namespace。Namespace將物理的Cluster從邏輯上切成多個虛擬Cluster，每一個虛擬Cluster就是一個Namespace，不同Namespace中的資源完全隔離。K8s默認創建2個Namespace:  default:如果不指定，資源就預設放這 kube-system:K8s自己創建的系統資源會放在這個Namespace中      </description>
    </item>
    
    <item>
      <title>MySQL常用語句 &amp; Workbench</title>
      <link>https://yoziming.github.io/post/211005-mysql-cmdworkbench/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211005-mysql-cmdworkbench/</guid>
      <description>MySQL 常用語句 資料庫database
create database XXX;show databases;use XXX;drop database XXX;資料表table
create table mytable(school char(5),name char(10),id int);show tables;describe mytable; // 顯示這表有哪些欄位跟屬性drop table mytable;select * from mytable; // 顯示mytable中所有資料insert into mytable(school, name, id) values (&#39;NCTU&#39;,&#39;Jerry&#39;,&#39;123&#39;);insert into mytable values (&#39;NCTU&#39;,&#39;Jerry&#39;,&#39;123&#39;);update mytable set name = &#39;HaHa&#39; where id = &#39;123&#39;;delete from mytable where name = &#39;HaHa&#39;;delete from 表格; // 把表格內資料都刪除(但格式宣告還在)select * from mytable where id = &#39;123&#39; order by name DESC; // 資料表查詢+條件+排序 (DESC 代表由大到小排序)load data local infile &amp;quot;c:\\data.</description>
    </item>
    
    <item>
      <title>Docker啟用Redis</title>
      <link>https://yoziming.github.io/post/211002-docker-redis/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211002-docker-redis/</guid>
      <description>Docker啟用Redis 抓映象檔 docker pull redis:6.0 拉一個6.0版本的redis  執行 Image docker run --name redis6 -p 6379:6379 -d redis:6.0 redis-server --appendonly yes –name redis6 ：將 Container 取名為 redis6 -p 6379:6379 ：將 Container 的 6379 Port 映射到主機的 6379 Port (前面代表主機，後面代表容器) -d :後台執行 Container ，並返回ID redis-server –appendonly yes : 在 Container 執行 redis-server 啟動命令，並打開redis持久化配置  進入 Container docker exec -it redis6 bash -i ：即使沒有附加也保持STDIN 打開 -t ：分配一個偽終端  資料庫測試 redis-cliset hello worldget hello</description>
    </item>
    
    <item>
      <title>Docker啟用Mysql</title>
      <link>https://yoziming.github.io/post/211001-docker-mysql/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211001-docker-mysql/</guid>
      <description>Docker啟用Mysql 抓映象檔 docker pull mysql/mysql-server:8.0 拉一個8.0版本的mysql  執行 Image docker run -d -it --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=mydb mysql:8 --default-authentication-plugin=mysql_native_password -d：同--detach，以背景模式執行。 -v ~/mysql-docker-data:/var/lib/mysql：同--volume，掛載host目錄到container目錄，也就是host的~/mysql-docker-data會保存container /var/lib/mysql的資料；windos docker app這樣做的話，資料是暫時的重開機後會不見。 -it：同--interactive加--tty，作用為運行container時可登入其bash操作。 --name mysql8，命名container名稱為mysql8。 -p：同--publish。作用為將container的3306 port對映到&amp;quot;主機(host)&amp;ldquo;的3306 port -e：同--env，設定環境變數。MYSQL_ROOT_PASSWORD設定MySQL root帳號的登入密碼為1234，MYSQL_DATABASE設定資料庫名稱為mydb。 mysql:8：mysql為image名稱，8為image tag。所以運行的是mysql:8的image。 --default-authentication-plugin=mysql_native_password：把儲存密碼的方式改為MySQL 5的mysql_native_password，因為MySQL 8的儲存方式預設為caching_sha2_password，但一些免費的MySQL client圖形工具如Sequel Pro，Navicat等會無法連線，所以設定此參數。  檢視運行中的容器 docker ps進入 Container docker exec mysql8 mysql -u root -p docker exec指令的作用為在運行的container執行指令，所以意思就是在mysql8這個container執行mysql -u root -p的指令。  docker container exec -it mysql8 /bin/bash 遇到權限問題用這個  進入Mysql mysql -uroot -p新增 1 個開放外部連線的帳號 CREATE USER &#39;user01&#39;@&#39;%&#39; IDENTIFIED BY &#39;1234&#39;;GRANT ALL ON your_database.</description>
    </item>
    
    <item>
      <title>Docker常用語句</title>
      <link>https://yoziming.github.io/post/210930-docker-common-operations/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210930-docker-common-operations/</guid>
      <description>Docker常用語句 抓映象檔 docker pull xxx檢視運行中的容器 docker ps進入 Container docker exec -it &amp;lt;container_id&amp;gt; /bin/bash -i ：即使沒有附加也保持STDIN 打開 -t ：分配一個偽終端  查看字元編碼 locale臨時改成UTF8 export LANG=&amp;quot;en_US.UTF-8&amp;quot;  永久設置需在Dockerfile中設置環境字元集環境變數
ENV LANG=&amp;quot;en_US.UTF-8&amp;quot;  </description>
    </item>
    
    <item>
      <title>Docker啟用MinIO</title>
      <link>https://yoziming.github.io/post/210929-docker-minio/</link>
      <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210929-docker-minio/</guid>
      <description>Docker啟用MinIO儲存 執行 Image docker run -d --name minio -e &amp;quot;MINIO_ROOT_USER=root&amp;quot; -e &amp;quot;MINIO_ROOT_PASSWORD=root1234&amp;quot; -p 9000:9000 -p 9001:9001 minio/minio server /data --console-address &amp;quot;:9001&amp;quot;  --name minio，命名container名稱為minio。 -v /data/minio:/data/minio該命令將主機 /data/minio 目錄對映到容器中的 /data/minio 目錄中 MinIO 還提供了圖形管理介面，在瀏覽器輸入 ip:9001即可檢視 不管是圖形介面操作，還是客戶端操作，預設賬號密碼都為 minioadmin -e環境變數，這裡用了自定義賬號密碼，賬號不能小於 3 字元，密碼不能小於 8 字元  Go初始化 導入github.com/minio/minio-go/v7，注意這個後面的v7，在自動引包時可能會漏掉，導致使用到舊版的同名函數而報錯
func InitMinio() { ctx := context.Background() endpoint := &amp;#34;localhost:9000&amp;#34; accessKeyID := &amp;#34;root&amp;#34; secretAccessKey := &amp;#34;root1234&amp;#34; useSSL := false // Initialize minio client object. 	minioClient, err := minio.</description>
    </item>
    
    <item>
      <title>consul基礎使用練習</title>
      <link>https://yoziming.github.io/post/210928-consul-practice/</link>
      <pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210928-consul-practice/</guid>
      <description>consul基礎使用練習  想像去郵局辦事，consul類似於發號碼牌的那個機器
伺服端(櫃台人員)去找consul註冊服務，比如說櫃台1~3提供儲蓄，櫃台4~6提供郵寄服務
客戶進來透過服務發現，把要辦的事丟給consul，它查看哪個櫃台健康，幫你匹配對應的服務或叫號
(感覺這例子不太完善，就&amp;hellip;類似的理解啦，實際用了才會懂)
   下載
# 官網:https://www.consul.io/downloads# ubuntu shell: (下載&amp;gt;解壓縮&amp;gt;把二進位執行檔丟進去)wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zipunzip consul_1.10.3_linux_amd64.zipsudo mv consul /usr/local/bin/  測試
consul -h  啟動server
consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=192.168.234.128 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0這個IP=192.168.234.128=ubuntu的ip
*若/etc/consul.d/不存在要先自己創
  查看服務
http://192.168.234.128:8500/  註冊自訂的健康檢查服務，範例:
剛剛自訂的配置檔路徑/etc/consul.d/下新增一個web.json
{&amp;quot;service&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;web&amp;quot;,&amp;quot;tags&amp;quot;: [&amp;quot;extract&amp;quot;, &amp;quot;verify&amp;quot;, &amp;quot;compare&amp;quot;, &amp;quot;idcard&amp;quot;],&amp;quot;address&amp;quot;: &amp;quot;192.168.234.128&amp;quot;,&amp;quot;port&amp;quot;: 9000,&amp;quot;check&amp;quot;: {&amp;quot;id&amp;quot;: &amp;quot;api&amp;quot;,&amp;quot;name&amp;quot;: &amp;quot;HTTP API on port 9000&amp;quot;,&amp;quot;http&amp;quot;: &amp;quot;http://localhost:9000&amp;quot;,&amp;quot;interval&amp;quot;: &amp;quot;10s&amp;quot;,&amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;}}}  重啟server並查看服務</description>
    </item>
    
    <item>
      <title>Golang下透過grpc調用服務案例</title>
      <link>https://yoziming.github.io/post/210927-grpc/</link>
      <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210927-grpc/</guid>
      <description>Golang下透過grpc調用服務案例  grpc簡單說就是跨平台(跨語言)調用各種服務的通用轉接口
 對.proto文件使用轉譯指令:
protoc --go_out=plugins=grpc:. *.proto 案例:透過grpc遠程傳遞一個調用teacher資料類型的服務
 .proto:
syntax=&amp;quot;proto3&amp;quot;;option go_package=&amp;quot;/.;pb&amp;quot;;message Teacher{int32 age=1;string name=2;}service SayName{rpc SayHello(Teacher) returns(Teacher);}server:
type Children struct{}// 綁定類方法func (c *Children) SayHello(ctx context.Context, t *pb.Teacher) (*pb.Teacher, error) {t.Name += &amp;quot;is sleeping&amp;quot;return t, nil}func main() {// 初始一個grpc對象grpcServer := grpc.NewServer()// 註冊服務pb.RegisterSayNameServer(grpcServer, new(Children))// 監聽listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.</description>
    </item>
    
    <item>
      <title>Golang中使用ProtoBuf</title>
      <link>https://yoziming.github.io/post/210926-golang-protobuf/</link>
      <pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210926-golang-protobuf/</guid>
      <description>Golang中使用ProtoBuf  protobuf類似json，它體積更小效率更高，規範統一(沒有大小寫等困擾)。
缺點是改動協議就要重新生成、數據本身是二進位沒有可讀性
   下載，window系統選.exe，解壓縮放到$GOPATH/bin
https://github.com/protocolbuffers/protobuf/releases  安裝golang對應的庫跟插件
go get github.com/golang/protobuf/protogo get github.com/golang/protobuf/protoc-gen-go  測試
protoc -h 或 protoc --version沒報錯就是成功
  消息體舉例，xxx.proto
// 指定版本，不打3就會是2syntax=&amp;quot;proto3&amp;quot;;// 指定輸出位置&amp;amp;go包名，沒寫轉換不了// option go_package =&amp;quot;path;name&amp;quot;;option go_package =&amp;quot;/.&amp;quot;; // 放在同一目錄下包名為__(空)// 定義消息體，分配唯一編號 (不能用19000~19999)message Student{int32 age = 1; // 可以不從1開始，但不可重複string name = 2;People p=3;repeated int32 score=4; // 數組Week w=5;// 聯合體oneof data{string teacher=6;string class=7;}}// 消息體可以嵌套message People{int32 weight=1;}// 定義枚舉類型enum Week{Monday=0; // 必須從0開始Turesday=1;}  生成go文件</description>
    </item>
    
    <item>
      <title>MVC &amp; Microservices</title>
      <link>https://yoziming.github.io/post/210920-mvcmicroservices/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210920-mvcmicroservices/</guid>
      <description>MVC架構 Model:模型，管理資料庫(增刪改查)、業務邏輯、物件結構定義
View:視圖，使用者實際在看、操作的介面(UI)，前端
Controller:控制，接收請求、回覆結果，決定工作流程，算是Model跟View的中間人
微服務架構（Microservices）  單一職責:把業務邏輯拆分成無數個小區塊(Blocks)，負責單一任務，服務之間透過管道來通訊。 輕量級通訊:使用不依賴語言或平台的格式，例如XML、JSON、protobuf。通常基於HTTP協議、符合REST風格來達成標準化、無狀態化。 獨立開發、測試、部屬:顧名思義，都拆開了就可以分開做，不像傳統架構牽一髮而動全身。 容器化:微服務既然能獨立作業了，就可以放到容器(Container)中，互相隔離互不干擾，達成快速部署、節省資源。Docker是目前最普遍的容器技術，Kubernetes(K8s)是常用來管理容器、協調整合的平台。  </description>
    </item>
    
    <item>
      <title>GoogleSearchConsole</title>
      <link>https://yoziming.github.io/post/211020-blog-ga/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211020-blog-ga/</guid>
      <description>如何讓自己的blog被google搜尋到  首先你要跟google證明這個網站是你的，並且允許google的爬蟲機器人獲取你的網站資料，這樣別人才能在google上搜尋到你的網站 同時也能夠使用google自訂搜尋方便自己查找資料  關於網站驗證  你同意後它才能把觸手深入你的網站，你可以自訂搜尋這個網站的資料權限 google提供多種方法，我是選html標記，放在套用的主題的之下，舉例:   如果你換了主題記得也要重改  Hugo建立sitemap索引  提供sitemap索引讓google機器人更好抓你的網站 Hugo內鍵就有這個功能，修改config.toml，插入:  [sitemap]changefreq = &#39;weekly&#39;filename = &#39;sitemap.xml&#39;priority = 0.5自訂搜尋 大部分主題都有此功能，一樣修改config.toml即可:
googleSearchCode = &amp;quot;你的SearchCode&amp;quot;</description>
    </item>
    
    <item>
      <title>HugoBlog的圖片插入方式</title>
      <link>https://yoziming.github.io/post/210930-blog-insert-image/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210930-blog-insert-image/</guid>
      <description>插入圖片的方式  常見有2種做法
 方法1  在.\static\images\下放入的圖片會被打包上傳，然後從相對路徑引用那個圖片 適和用在全站通用的資源，比如背景圖、縮圖  方法2   在.\content\post\下，每當有用到圖片一篇文章的就新增一個資料夾
  資料夾可以命名可自訂，然後進去把.md檔改名為&amp;quot;index.md&amp;quot;，圖片放同層
  範例:  這個方法比較好整理，每篇用到的圖片放在自己的資料夾中
  </description>
    </item>
    
    <item>
      <title>用Hugo建立靜態Blog</title>
      <link>https://yoziming.github.io/post/210909-blog-hugo/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210909-blog-hugo/</guid>
      <description>用Github&amp;amp;Hugo建立靜態Blog  看了很多教學有各種高級的自動部署、netlify後台等等，照做卻老是在一些關鍵點卡住。我這個土路雖然蠢笨但確實能做出東西，同樣新手可以試試。
   安裝Chocolatey //程式安裝器，讓你從終端裝各種東西很方便
https://chocolatey.org/install到這個網址，官方提供很多方法安裝，非常簡單快速一行搞定安裝hugo，有些佈景主題要用到加強版(extended)
choco install hugo -confirmchoco install hugo-extended -confirm  hugo new site &amp;lt;資料夾名稱&amp;gt; //建立一個root，相當於你個人網站的原始資料母巢
  挑主題，到https://themes.gohugo.io/
  套用主題，範例
 cd &amp;lt;資料夾名稱&amp;gt;git initgit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary  依照主題的說明文件修改根目錄下的config.toml 注意，config.toml中的第一項baseURL網址不要有&amp;quot;https://www.ooxx&amp;quot;，否則會造成一些未知的BUG。正確網址應為&amp;quot;https://你的username.github.io/&amp;quot;
  到content/post/下開始寫一篇blog
  開啟本地預覽，指令hugo server -F //防止時差問題用-F
  隨意一個地方開啟網址http://localhost:1313/ 看看網站
  網站沒問題就打包，指令hugo，會在root資料夾下多出一個public資料夾，裡面就是一個完整的網站準備丟去網路上發布
  去gitHub建一個Repository(倉庫)，名稱強制為 你的username.github.io
  下載GitHub Desktop客戶端，可以把他理解成一個雲端，我要把本地public資料夾的內容透過它丟去gitHub上剛剛建的那個Repository(倉庫)裡，之後就能透過網站提供的gitPage功能實現個人網站的搭建</description>
    </item>
    
    <item>
      <title>一次性隊列</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/</guid>
      <description>一次性隊列 //用結構體管理隊列type Queue struct {maxSize intarray [3]intfront int //隊列首(不包含)rear int //隊尾(含)}//添加數據val到隊列func (q *Queue) AddQueue(val int) (err error) {//先判斷是否已滿if q.rear == q.maxSize-1 {return errors.New(&amp;quot;queue full&amp;quot;)}q.rear++q.array[q.rear] = valreturn}//取出數據func (q *Queue) GetQueue() (val int, err error) {//先判斷是否為空if q.rear == q.front {return -1, errors.New(&amp;quot;queue empty&amp;quot;)}q.front++val = q.array[q.front]return val, err}//顯示隊列func (q *Queue) ShowQueue() {fmt.</description>
    </item>
    
    <item>
      <title>二分樹的3種遍歷</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/</guid>
      <description>二分樹的3種遍歷 package mainimport &amp;quot;fmt&amp;quot;type Hero struct {No intName stringLeft *HeroRight *Hero}//前序遍歷 先輸出root 再輸出左子樹 再輸出右子樹，會中左右一層層往下func PreOrder(node *Hero) {if node != nil {fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)PreOrder(node.Left)PreOrder(node.Right)}}//中序遍歷 左子樹 root 右子樹func InfixOrder(node *Hero) {if node != nil {InfixOrder(node.Left)fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)InfixOrder(node.Right)}}//後序遍歷 左子樹 右子樹 root，會一路到最左最下開始打func PostOrder(node *Hero) {if node !</description>
    </item>
    
    <item>
      <title>哈希表數據結構</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/</guid>
      <description>哈希表數據結構 package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;os&amp;quot;)type Emp struct {Id intName stringNext *Emp}func (e *Emp) ShowMe() {fmt.Printf(&amp;quot;链表%d 找到该雇员 %d\n&amp;quot;, e.Id%7, e.Id)}//不帶表頭，即第一個節點就放雇員資料type EmpLink struct {Head *Emp}func (e *EmpLink) FindByIdEmpLink(id int) *Emp {cur := e.Headfor {if cur != nil &amp;amp;&amp;amp; cur.Id == id {return cur} else if cur == nil {break}cur = cur.</description>
    </item>
    
    <item>
      <title>單向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>單向鏈表 type HeroNode struct {no intname stringnext *HeroNode //表示指向下一個節點}//給鏈表插入節點func Insert(head *HeroNode, newHeroNode *HeroNode) {//先找到最後的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break}temp = temp.next //不斷往下找}//把newHeroNode加到屁股temp.next = newHeroNode}//根據No從小到大插入func InsertNo(head *HeroNode, newHeroNode *HeroNode) {//想找到適當的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break} else if temp.next.no &amp;gt; newHeroNode.no {//表示new要插到temp後break} else if temp.</description>
    </item>
    
    <item>
      <title>插入&amp;選擇&amp;快速排序</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E6%8F%92%E5%85%A5%E9%81%B8%E6%93%87%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E6%8F%92%E5%85%A5%E9%81%B8%E6%93%87%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>插入&amp;amp;選擇&amp;amp;快速排序 //選擇排序func SelectSort(array *[6]int) {for j := 0; j &amp;lt; len(array)-1; j++ {min := array[j]minIndex := j//尋找最小的下標for i := j + 1; i &amp;lt; len(array); i++ {if min &amp;gt; array[i] {min = array[i]minIndex = i}}if minIndex != j {array[j], array[minIndex] = array[minIndex], array[j]}fmt.Printf(&amp;quot;第%d次交換後 %v\n&amp;quot;, j+1, *array)}}//插入排序func InsertSort(arr *[6]int) {for j := 1; j &amp;lt; len(arr); j++ {//給第二個元素找位置insertVal := arr[j]insertIndex := j - 1 //下標//由大到小for insertIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[insertIndex] &amp;lt; insertVal {arr[insertIndex+1] = arr[insertIndex] //數據後移insertIndex--}//插入if insertIndex+1 !</description>
    </item>
    
    <item>
      <title>模擬棧&amp;四則運算</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E6%A8%A1%E6%93%AC%E6%A3%A7%E5%9B%9B%E5%89%87%E9%81%8B%E7%AE%97/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E6%A8%A1%E6%93%AC%E6%A3%A7%E5%9B%9B%E5%89%87%E9%81%8B%E7%AE%97/</guid>
      <description>模擬棧&amp;amp;四則運算 //模擬棧的使用type Stack struct {MaxTop int //最大可存個數Top int //頂arr [20]int}func (s *Stack) Push(val int) (err error) {//先判斷是否滿if s.Top == s.MaxTop-1 {fmt.Println(&amp;quot;stack full&amp;quot;)return errors.New(&amp;quot;stack full&amp;quot;)}//放入數據s.Top++s.arr[s.Top] = valreturn}func (s *Stack) Pop() (val int, err error) {//先判斷是否空if s.Top == -1 {fmt.Println(&amp;quot;stack empty&amp;quot;)return 0, errors.New(&amp;quot;stack empty&amp;quot;)}//彈出數據val = s.arr[s.Top]s.Top--return val, nil}//遍歷func (s *Stack) List() {//先判斷是否空if s.</description>
    </item>
    
    <item>
      <title>環形單向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E7%92%B0%E5%BD%A2%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E7%92%B0%E5%BD%A2%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>環形單向鏈表 type CatNode struct {no intname stringnext *CatNode}func Insert(head *CatNode, newCatNode *CatNode) {//判斷是否第一隻貓if head.next == nil {head.no = newCatNode.nohead.name = newCatNode.namehead.next = head //構成環形fmt.Println(*newCatNode, &amp;quot;已初始化並加入環形鏈表&amp;quot;)return}//定義一個變量找到環形最後一個temp := headfor {if temp.next == head {break}temp = temp.next}temp.next = newCatNodefmt.Println(*newCatNode, &amp;quot;已加入環形鏈表&amp;quot;)newCatNode.next = head}func Del(head *CatNode, id int) *CatNode {temp := headhelper := headif temp.</description>
    </item>
    
    <item>
      <title>稀疏數組</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E7%A8%80%E7%96%8F%E6%95%B8%E7%B5%84/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E7%A8%80%E7%96%8F%E6%95%B8%E7%B5%84/</guid>
      <description>稀疏數組 type ValNode struct {row int //橫的col int //直的val int}func main() {//創建數組範例var chessMap [11][11]intchessMap[1][2] = 1chessMap[2][3] = 2//輸出看樣子for _, v := range chessMap {for _, v2 := range v {fmt.Printf(&amp;quot;%d\t&amp;quot;, v2)}fmt.Println()}//轉成稀疏數組，思路:遍歷他，創造一個結構體，發現有值就放進對應的切片var sparseArr []ValNode//紀錄規模跟預設值valNode0 := ValNode{row: 11,col: 11,val: 0,}sparseArr = append(sparseArr, valNode0)for i, v := range chessMap {for j, k := range v {if k !</description>
    </item>
    
    <item>
      <title>約瑟夫問題</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E7%B4%84%E7%91%9F%E5%A4%AB%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E7%B4%84%E7%91%9F%E5%A4%AB%E5%95%8F%E9%A1%8C/</guid>
      <description>約瑟夫問題 type Boy struct {No intNext *Boy //指向下一個小孩的指針}func addBoy(num int) *Boy {//num表示小孩的個數，*Boy返回第一個小孩的指針first := &amp;amp;Boy{}temp := &amp;amp;Boy{}if num &amp;lt; 1 {fmt.Println(&amp;quot;num值錯誤&amp;quot;)return first}for i := 1; i &amp;lt;= num; i++ {boy := &amp;amp;Boy{No: i,}if i == 1 {first = boy //不變temp = boytemp.Next = first} else {temp.Next = boytemp = boytemp.</description>
    </item>
    
    <item>
      <title>迷宮遞迴</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/</guid>
      <description>迷宮遞迴 func SetWay(myMap *[8][7]int, a int, b int) bool {//a,b 表示對地圖的那個點測試//找到出口if myMap[6][5] == 2 {return true} else {//繼續找if myMap[a][b] == 0 { //可探測的點myMap[a][b] = 2 //踩上去了，再探上下左右，但是我知道要往下往右探if SetWay(myMap, a+1, b) { //下return true} else if SetWay(myMap, a, b+1) { //右return true} else if SetWay(myMap, a-1, b) { //上return true} else if SetWay(myMap, a, b-1) { //左return true} else { //死路myMap[a][b] = 3return false}} else { //不可探測的點return false}}}func main() {//定義地圖 1=牆壁 0=沒走過的點 2=通路 3=走過的死路var myMap [8][7]int//四周設置圍牆for i := 0; i &amp;lt; 7; i++ {myMap[0][i] = 1myMap[7][i] = 1}for i := 0; i &amp;lt; 8; i++ {myMap[i][0] = 1myMap[i][6] = 1}myMap[3][1] = 1myMap[3][2] = 1//看樣子for i := 0; i &amp;lt; 8; i++ {for j := 0; j &amp;lt; 7; j++ {fmt.</description>
    </item>
    
    <item>
      <title>雙向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>雙向鏈表 type HeroNode struct {no intname stringpre *HeroNode //表示指向前一個節點next *HeroNode //表示指向下一個節點}//給鏈表插入節點func Insert(head *HeroNode, newHeroNode *HeroNode) {//先找到最後的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break}temp = temp.next //不斷往下找}//把newHeroNode加到屁股temp.next = newHeroNodenewHeroNode.pre = temp}//根據No從小到大插入func InsertNo(head *HeroNode, newHeroNode *HeroNode) {//想找到適當的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break} else if temp.</description>
    </item>
    
    <item>
      <title>channel通道</title>
      <link>https://yoziming.github.io/post/210810-agg-go-channel/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-channel/</guid>
      <description>channel通道 lock sync與chan基本認識 //階乘1-n 把各個數放到map中 用goroutine完成var (myMap = make(map[int]int, 10)//聲明一個全局的互斥鎖lock sync.Mutex//來點管道 記得要make初始化才能用intChan chan int = make(chan int, 3)//聲明類型為空接口可以接收任意類型allChan chan interface{} = make(chan interface{}, 5)//注意後面沒聲明容量則不給用)type Cat struct {Name stringAge int}func test(n int) {res := 1for i := 1; i &amp;lt;= n; i++ {res = res * i}//把res放進mayMap//加鎖lock.Lock()myMap[n] = res//解鎖lock.</description>
    </item>
    
    <item>
      <title>const常量</title>
      <link>https://yoziming.github.io/post/210810-agg-go-const/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-const/</guid>
      <description>const常量  常量 聲明時必須賦值、不能修改、只能是bool、數值、string，賦值需是一個確定的值
 func main() {const tax int = 10const x = 9 / 3// const c = 9 / a //因為a可能是一個變量所以這樣不行// var a int = 3fmt.Println(tax, x)const (a = iota //表示a=0b //b=a+1c //c=b+1)fmt.Println(a, b, c)const (d = iotaef, g = iota, iota)fmt.Println(d, e, f, g)//其他程式語言常量會用全大寫，go中沒限制，且一樣用首字母大小來控制使用範圍}</description>
    </item>
    
    <item>
      <title>defer臨走前啟用</title>
      <link>https://yoziming.github.io/post/210810-agg-go-defer/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-defer/</guid>
      <description>defer臨走前啟用  退出函數前才執行
 func sum(n1, n2 int) int {defer fmt.Println(&amp;quot;ok1&amp;quot;, n1)defer fmt.Println(&amp;quot;ok2&amp;quot;, n2)//defer棧先入後出n1++n2++res := n1 + n2fmt.Println(&amp;quot;ok3 res=&amp;quot;, res)return res}func main() {res := sum(10, 20)fmt.Println(&amp;quot;res=&amp;quot;, res)}</description>
    </item>
    
    <item>
      <title>goroutine</title>
      <link>https://yoziming.github.io/post/210810-agg-go-goroutine/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-goroutine/</guid>
      <description>goroutine  進程=程序在操作系統中的一次進行過程
線程=執行實例的最小單位
  一個進程可以創建多個線程且併發執行 一個程序至少包含一個進程，一個進程至少包含一個線程 併發=多線程程序在單核上運行 併行=多線程程序在多核上運行  GO的主線程(可以理解為進程)，一個GO進程上可以起很多協程，協程可以理解為輕量級的線程，協程特點:
 有獨立的棧空間 共享程序堆空間 調度由用戶控制 為輕量級的線程  func test() {for i := 0; i &amp;lt; 10; i++ {fmt.Println(&amp;quot;test()Hello,world&amp;quot; + strconv.Itoa(i))time.Sleep(time.Second / 10)}}func main() {go test() //開啟一個協程//如果主線程退出了，即使協程還沒執行完，也會退出//協程可以自己先結束for i := 0; i &amp;lt; 10; i++ {fmt.Println(&amp;quot;main()Hello,go&amp;quot; + strconv.Itoa(i))time.Sleep(time.Second / 10)}go test() //開啟一個協程，主線程退出了，即使協程還沒執行完，也會退出//查邏輯CPU數量cpuNum := runtime.NumCPU()fmt.Println(cpuNum)//設置最大線程數量runtime.</description>
    </item>
    
    <item>
      <title>Go使用mysql與事務操作</title>
      <link>https://yoziming.github.io/post/210810-agg-go-mysql/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-mysql/</guid>
      <description>Go使用mysql與事務操作 基本操作 import (&amp;quot;database/sql&amp;quot;&amp;quot;fmt&amp;quot;_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;)var db *sql.DB // 是一個連接池對象// user 接收數據type user struct {id intname stringage int}func initDB() (err error) {dsn := &amp;quot;root:root@tcp(127.0.0.1:3306)/sql_test&amp;quot;db, err = sql.Open(&amp;quot;mysql&amp;quot;, dsn) // 這個db要用全局的，重要!if err != nil {return}err = db.Ping()if err != nil {return} else {fmt.Println(&amp;quot;連接成功&amp;quot;)}return}// 查詢一個func find1() {var u1 usersqlStr := `select id, name, age from user where id=?</description>
    </item>
    
    <item>
      <title>JSON序列化</title>
      <link>https://yoziming.github.io/post/210810-agg-go-json/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-json/</guid>
      <description>JSON序列化  JSON 格式 {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:&amp;ldquo;值2&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:[&amp;ldquo;值2數組&amp;rdquo;,值2數組]}
 type Monster struct {Name string `json:&amp;quot;name&amp;quot;` //反射機制Age int `json:&amp;quot;age&amp;quot;`Sal float64 `json:&amp;quot;sal&amp;quot;`}func test1() {monster1 := Monster{Name: &amp;quot;牛魔王&amp;quot;,Age: 50,Sal: 8000.0,}data, err := json.Marshal(&amp;amp;monster1)if err != nil {fmt.Println(err)}fmt.Println(string(data))}//把map序列化func testMap() {var mapA map[string]interface{} = make(map[string]interface{})mapA[&amp;quot;name&amp;quot;] = &amp;quot;紅孩兒&amp;quot;mapA[&amp;quot;age&amp;quot;] = 18data, err := json.Marshal(&amp;amp;mapA)if err !</description>
    </item>
    
    <item>
      <title>Map集合</title>
      <link>https://yoziming.github.io/post/210810-agg-go-map/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-map/</guid>
      <description>Map集合 func main() {// map[key類型] value類型var m1 map[int]int = make(map[int]int)//key類型通常是int or string//value 通常是數字 or string or map or struct//只聲明不會給內存，要make才初始化才能用(跟切片一樣)m1[1] = 100m1[2] = 200m1[3] = 300m1[1] = 1000//key不能重複，後賦予的頂掉前面fmt.Println(m1)var m2 = make(map[string]string)m2[&amp;quot;AV&amp;quot;] = &amp;quot;sss&amp;quot;fmt.Println(m2)//推薦寫法m3 := make(map[string]string)m3[&amp;quot;一號&amp;quot;] = &amp;quot;台北&amp;quot;m3[&amp;quot;二奧&amp;quot;] = &amp;quot;桃園&amp;quot;fmt.Println(m3)m4 := map[int]int{1: 10, 2: 20, 3: 30}fmt.Println(m4)//學生姓名+性別m5 := make(map[string](map[string]string))m5[&amp;quot;stu01&amp;quot;] = make(map[string]string) //不能少m5[&amp;quot;stu01&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;tom&amp;quot;m5[&amp;quot;stu01&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;男&amp;quot;m5[&amp;quot;stu02&amp;quot;] = make(map[string]string) //不能少m5[&amp;quot;stu02&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;mary&amp;quot;m5[&amp;quot;stu02&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;女&amp;quot;fmt.</description>
    </item>
    
    <item>
      <title>new與make的區別</title>
      <link>https://yoziming.github.io/post/210810-agg-go-newmake/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-newmake/</guid>
      <description>func main() {num1 := 100fmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num1, num1, &amp;amp;num1)num2 := new(int) //*intfmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num2, num2, &amp;amp;num2)//new用來分配類型//make用來分配內存}</description>
    </item>
    
    <item>
      <title>Redis基本操作</title>
      <link>https://yoziming.github.io/post/210810-agg-go-redis/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-redis/</guid>
      <description>Redis基本操作 0.啟動cmd&amp;gt;redis-cli
1.數據結構類似JSON都是Key-Value
2.五大數據類型String、Hash、List、Set、Zset
2-1.String:最基本的字串，value最大值=512M
指令:set(如果存在就相當於修改)、get、del (很多指令可以用tab協助完成)
setex(幾秒後自毀)
2-2.Hash:類似於Map
指令:hset key field value、hget、hdel
一次設多項(空格隔開)hmset、hmget
hlen:統計有幾個元素
hexists:看field是否存在
2-3.List:是個有序的鏈表，元素的值可以重複，可以把東西加在頭或尾
指令:lpush 從左往管子裡塞東西，一直推擠過去
lrange 0 end (最左是0 1 2 3&amp;hellip;，也可以用負數 -1表示最後一個 -2表示倒數第2
比如說lrange 0 -1 =從左開始全顯示
rpush 從右邊加東西 (就順序上來說比較習慣)
lpop / rpop 從左或右取出數據(彈走了)
del key 刪掉就沒了
lindex 按照索引下標獲得元素(從左到右0開始)
llen 長度
2-4.Set:String類型的無序集合(元素的值不能重複)
舉例 存放email不該重複 (重複加了無效)
指令saad
smembers 印出所有值
sismember 判斷值是否成員
srem 刪除指定值</description>
    </item>
    
    <item>
      <title>Reflect反射</title>
      <link>https://yoziming.github.io/post/210810-agg-go-reflect/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-reflect/</guid>
      <description>reflect反射 func reflectTest01(b interface{}) {//通過反射獲取傳入的各種訊息//先拿reflect.TyperType := reflect.TypeOf(b)fmt.Println(&amp;quot;rType=&amp;quot;, rType)rVal := reflect.ValueOf(b)fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)// n1:=10+rVal //rVal他看起來是int但其實是type reflect.Valuen1 := 10 + rVal.Int() //用.Int()轉換後就可以了// n3 := rVal.Float()//像這樣也不行的，一定要確認類型fmt.Println(&amp;quot;n1=&amp;quot;, n1)// fmt.Println(&amp;quot;n3=&amp;quot;, n3)//把rVal轉回interface{}iV := rVal.Interface()n2 := iV.(int)fmt.Println(&amp;quot;n2=&amp;quot;, n2)}func reflectTest02(b interface{}) {//通過反射獲取傳入的各種訊息//先拿reflect.TyperType := reflect.TypeOf(b)fmt.Println(&amp;quot;rType=&amp;quot;, rType)rVal := reflect.ValueOf(b)fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)//把rVal轉回interface{}iV := rVal.Interface()//斷言回來n2, ok := iV.</description>
    </item>
    
    <item>
      <title>RPC</title>
      <link>https://yoziming.github.io/post/210927-rpc/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210927-rpc/</guid>
      <description>server / 用接口，讓服務端註冊RPC的時候，就能確保他合法type World struct{}func (w *World) HelloWorld(name string, resp *string) error {*resp = name + &amp;quot;你好&amp;quot;return nil// 如果這個return的返回值不為空，// 那無論傳出的參數是否有值，服務端都不會給東西// (就你給你error)}// 用接口，讓服務端註冊RPC的時候，就能確保他合法type MyInerface interface {HelloWorld(string *string) error}// 調用方法時，給i傳參，參數是實現HelloWorld方法的對象func RegsiterService(i MyInerface) {rpc.RegisterName(&amp;quot;hello&amp;quot;, i)}func main() {// 1.註冊RPC服務 綁定對象方法err := rpc.RegisterName(&amp;quot;hello&amp;quot;, new(World))if err != nil {fmt.Println(&amp;quot;註冊RPC服務失敗&amp;quot;, err)}// 2.開始監聽listener, err := net.</description>
    </item>
    
    <item>
      <title>Split切分字串</title>
      <link>https://yoziming.github.io/post/210810-agg-go-split/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-split/</guid>
      <description>Split切分字串 // abc,b=&amp;gt;[a c]func Split(str, sep string) []string {// str=&amp;quot;bsfcvjkhbafs&amp;quot; sep=&amp;quot;b&amp;quot;var ret = make([]string, 0, strings.Count(str, sep)+1)index := strings.Index(str, sep)for index &amp;gt;= 0 {ret = append(ret, str[:index])str = str[index+len(sep):]index = strings.Index(str, sep)}ret = append(ret, str)return ret}</description>
    </item>
    
    <item>
      <title>Test單元測試</title>
      <link>https://yoziming.github.io/post/210810-agg-go-test/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-test/</guid>
      <description>Test單元測試  單元測試目的是驗證程式碼(例如一個方法)本身的邏輯是否正確 單元測試應排除外部依賴（Database、File System IO） 單元測試應該是隨時隨地都要能正確執行 單元測試的標題需要具備好的可讀性、明確、標題與測試的內容精確吻合 例：「public void GetTest_帶入會員ID＿應回該ID搜尋到的會員資料DTO」，盡量符合：受測方法＿傳入參數意義＿期望得到的結果 一個測試只應該關注一件事情，如果受測目標有多種狀況，應該分成好幾個測試去涵蓋所有邏輯   3A原則
  Arrange = 準備受測物件、參數、預期結果 Act = 執行受測方法 Assert = 驗證執行結果與預測結果是否一致  cal.go func addUpper(n int) int {res := 0for i := 0; i &amp;lt;= n; i++ {res = +i}return res}func getSub(n1, n2 int) int {return n1 - n2}cal_test.go func TestAddUpper(t *testing.T) {//調用res := addUpper(10)if res !</description>
    </item>
    
    <item>
      <title>WaitGroup鎖</title>
      <link>https://yoziming.github.io/post/210810-agg-go-waitgroup/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-waitgroup/</guid>
      <description>WaitGroup鎖 讀寫鎖 var x = 0var wg sync.WaitGroupvar rwlock sync.RWMutexfunc write() {rwlock.Lock()x = x + 1time.Sleep(time.Millisecond * 10)rwlock.Unlock()wg.Done()}func read() {// lock.Lock()rwlock.RLock() //鎖讀time.Sleep(time.Millisecond)rwlock.RUnlock()// lock.Unlock()wg.Done()}func main() {start := time.Now()for i := 0; i &amp;lt; 10; i++ {wg.Add(1)go write()}for i := 0; i &amp;lt; 1000; i++ {wg.Add(1)go read()}wg.</description>
    </item>
    
    <item>
      <title>二維數組</title>
      <link>https://yoziming.github.io/post/210810-agg-go-array/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-array/</guid>
      <description>// 000000// 001000// 020300// 000000func main() {var arr [4][6]intarr[1][2] = 1arr[2][1] = 2arr[2][3] = 3//遍歷for i := 0; i &amp;lt; len(arr); i++ {for j := 0; j &amp;lt; len(arr[i]); j++ {fmt.Print(arr[i][j], &amp;quot; &amp;quot;)}fmt.Println()}//遍歷rangefor i, v := range arr {for j, v2 := range v {fmt.Printf(&amp;quot;arr[%v][%v]=%v \t&amp;quot;, i, j, v2)}fmt.</description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://yoziming.github.io/post/210810-agg-go-bubble-sort/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-bubble-sort/</guid>
      <description>冒泡排序 var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 6}func main() {s1 := arr1[:]bubbleSort(s1)fmt.Println(arr1)}func bubbleSort(x []int) {for j := 1; j &amp;lt; len(x); j++ {for i := 0; i &amp;lt; len(x)-1; i++ {if x[i] &amp;gt; x[i+1] {x[i], x[i+1] = x[i+1], x[i]}}}}</description>
    </item>
    
    <item>
      <title>函數封裝的金字塔</title>
      <link>https://yoziming.github.io/post/210810-agg-go-pyramid/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-pyramid/</guid>
      <description>package mainimport (&amp;quot;fmt&amp;quot;)var input intfunc jin(input int) {for i := 1; i &amp;lt;= input; i++ {for k := 1; k &amp;lt;= input-i; k++ {fmt.Print(&amp;quot; &amp;quot;)}for j := 1; j &amp;lt;= 2*i-1; j++ {if j == 1 || j == 2*i-1 || i == input {fmt.Print(&amp;quot;*&amp;quot;)} else {fmt.Print(&amp;quot; &amp;quot;)}}fmt.Println()}}func main() {fmt.</description>
    </item>
    
    <item>
      <title>函數綁定方法</title>
      <link>https://yoziming.github.io/post/210810-agg-go-method/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-method/</guid>
      <description>函數綁定方法  方法:結構體的行為，自訂義的結構都可以有方法，方法是作用在指定類型上(綁定的)
方法就是跟一種類型綁定的函數，因為綁定數據類型了就可以偷雞，具體表現在省指針
定義方法時候寫的是func(a ABC) //後面怎樣調用都是值拷貝
定義方法時候寫的是func(a *ABC)//後面怎樣調用都是真實地址
要調用方法，只能透過那種類型的的數據變量 例如a1.ABC
 package mainimport (&amp;quot;fmt&amp;quot;)type Person struct {Name string}//給Person類型綁定一個方法func (p Person) test() {p.Name = &amp;quot;jack&amp;quot;fmt.Println(&amp;quot;test()=&amp;quot;, p.Name)}//給Person類型添加一個speak方法，輸出xxx是好人func (p Person) speak() {fmt.Println(p.Name, &amp;quot;是一個好人&amp;quot;)}//添加一個計算方法算+1...+100func (p Person) count() {res := 0for i := 1; i &amp;lt;= 100; i++ {res += i}fmt.Println(p.Name, &amp;quot;計算的結果是&amp;quot;, res)}//添加一個計算方法算+1.</description>
    </item>
    
    <item>
      <title>切片</title>
      <link>https://yoziming.github.io/post/210810-agg-go-slice/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-slice/</guid>
      <description>func main() {//切片的類型是引用(傳遞的時候也是引用地址)//切片長度可變(不像數組)var arr1 = [5]int{1, 2, 3, 4, 5}s1 := arr1[1:3] //表示切arr的[1 2] 左開右閉(含左不含右)//var slice=arr[0:end]簡寫[:end]//[start:len(arr)]=[start:]//[0:len(arr)]=[:]fmt.Println(&amp;quot;s1內容是&amp;quot;, s1)fmt.Println(&amp;quot;s1長度是&amp;quot;, len(s1))fmt.Println(&amp;quot;s1容量是&amp;quot;, cap(s1))fmt.Printf(&amp;quot;s1第一個地址是%p\n&amp;quot;, &amp;amp;s1[0])fmt.Printf(&amp;quot;arr1[1]地址是%p\n&amp;quot;, &amp;amp;arr1[1])s1[0] = 33fmt.Println(&amp;quot;arr1內容是&amp;quot;, arr1)//var 切片名[]type=make([]type,len,cap)var s2 []float64 = make([]float64, 5, 10)fmt.Println(s2)//var 變量=make(類型)var s22 = make([]float64, 5, 10)fmt.Println(s22)var s3 []int = []int{1, 2, 3, 4, 5}fmt.Println(s3)//用append動態追加s3 = append(s3, 6, 7, 8, 9)fmt.</description>
    </item>
    
    <item>
      <title>匿名函數與閉包</title>
      <link>https://yoziming.github.io/post/210810-agg-go-closure/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-closure/</guid>
      <description>匿名函數 func main() {res := func(n1, n2 int) int {return n1 + n2}(10, 20)fmt.Println(res)a := func(n1, n2 int) int {return n1 - n2}res = a(10, 5)fmt.Println(res)}閉包 //累加器func Add() func(int) int { //Add是一個函數，返回的數據類型是func(int) intvar n int = 10 //返回的是一個匿名函數，那這個函數用到函數外的n，因此形成一個整體稱為閉包return func(x int) int {n = n + xreturn n//閉包是類，函數是操作，n是字段，函數+使用n構成閉包//n只初始化一次}}func main() {a := Add()fmt.</description>
    </item>
    
    <item>
      <title>命令行參數Args&amp;Flag</title>
      <link>https://yoziming.github.io/post/210810-agg-go-argsflag/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-argsflag/</guid>
      <description>命令行參數Args&amp;amp;Flag func main() {fmt.Println(&amp;quot;命令行參數有&amp;quot;, len(os.Args))//遍歷os.Args切片 得到所有輸入的參數值for i, v := range os.Args {fmt.Printf(&amp;quot;args[%v]=%v\n&amp;quot;, i, v)}fmt.Println(&amp;quot;=====================&amp;quot;)//flag方法 先定義幾個變量用於接收參數值var user stringvar pwd stringvar host stringvar port intflag.StringVar(&amp;amp;user, &amp;quot;u&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;帳號 預設為空&amp;quot;)flag.StringVar(&amp;amp;pwd, &amp;quot;pwd&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;密碼 預設為空&amp;quot;)flag.StringVar(&amp;amp;host, &amp;quot;h&amp;quot;, &amp;quot;localhost&amp;quot;, &amp;quot;主機 預設為localhost&amp;quot;)flag.IntVar(&amp;amp;port, &amp;quot;port&amp;quot;, 3306, &amp;quot;端口 預設為3306&amp;quot;)//前面有亂打的字就不行 比如...exe 12354 -u tom會調用預設flag.Parse() //這個一定要調用//輸出結果fmt.Printf(&amp;quot;user=%v pwd=%v host=%v port=%v&amp;quot;,user, pwd, host, port)}</description>
    </item>
    
    <item>
      <title>字串轉換常用函數</title>
      <link>https://yoziming.github.io/post/210810-agg-go-string-conver/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-string-conver/</guid>
      <description>字串轉換常用函數 var str string = &amp;quot;abc123中文&amp;quot;func main() {fmt.Println(&amp;quot;長度=&amp;quot;, len(str))r := []rune(str)for i := 0; i &amp;lt; len(r); i++ {fmt.Printf(&amp;quot;遍歷=%q\n&amp;quot;, r[i])}//轉成整數 Atoin, err := strconv.Atoi(&amp;quot;5421&amp;quot;)if err != nil {fmt.Println(&amp;quot;錯誤,err&amp;quot;)} else {fmt.Println(&amp;quot;轉換成&amp;quot;, n)//整數轉字串str2 := strconv.Itoa(654231)fmt.Printf(&amp;quot;類型是%T\n&amp;quot;, str2)//轉bytevar bytes = []byte(&amp;quot;hello&amp;quot;)fmt.Printf(&amp;quot;bytes=%v \n&amp;quot;, bytes)//byte轉回字串str3 := string([]byte{97, 98, 99})fmt.Printf(&amp;quot;str3=%v \n&amp;quot;, str3)//10進制轉2,8,16返回字串str4 := strconv.</description>
    </item>
    
    <item>
      <title>實作練習-ini解析器</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</guid>
      <description>用來解析.ini文檔格式是否有問題
 package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;io/ioutil&amp;quot;&amp;quot;reflect&amp;quot;&amp;quot;strings&amp;quot;)type RedisConfig struct {Host string `ini:&amp;quot;host&amp;quot;`Port int `ini:&amp;quot;port&amp;quot;`Password string `ini:&amp;quot;password&amp;quot;`Database int `ini:&amp;quot;database&amp;quot;`}type MysqlConfig struct {Address string `ini:&amp;quot;address&amp;quot;`Port int `ini:&amp;quot;port&amp;quot;`Password string `ini:&amp;quot;password&amp;quot;`Username string `ini:&amp;quot;username&amp;quot;`}type Config struct {MysqlConfig `ini:&amp;quot;mysql&amp;quot;`RedisConfig `ini:&amp;quot;redis&amp;quot;`}func loadIni(fileName string, data interface{}) (err error) {// 0. 參數校驗// 0.1 傳來的data必須是結構體類型指針t := reflect.</description>
    </item>
    
    <item>
      <title>實作練習-txt文本批次取代器</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/</guid>
      <description>實作練習-txt文本批次取代器  自己寫用來一次取代多個名詞，去除多餘空格或符號等等
 package mainimport (&amp;quot;bufio&amp;quot;&amp;quot;fmt&amp;quot;&amp;quot;io&amp;quot;&amp;quot;os&amp;quot;&amp;quot;strings&amp;quot;)var data []string = make([]string, 128)func main() {readByBufio()for _, v := range data {if v == &amp;quot;&amp;quot; {break}fmt.Print(v)}}func readByBufio() {file, err := os.Open(&amp;quot;C:/test.txt&amp;quot;)if err != nil {fmt.Printf(&amp;quot;os.Open err %s\n&amp;quot;, err)return}defer file.Close()reader := bufio.NewReader(file)for i := 0; ; i++ {line, err := reader.</description>
    </item>
    
    <item>
      <title>實作練習-多人聊天室</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>實作練習-多人聊天室  本來很傻的檔案代碼一個一個貼，後來學了github的專案管理就放到那了
 https://github.com/yoziming/go-practice-chatroom</description>
    </item>
    
    <item>
      <title>實作練習-客戶名單管理系統</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/</guid>
      <description>實作練習-客戶名單管理系統 model type Customer struct {Id intName stringGender stringAge intPhone stringEmail string}//使用工廠模式返回一個實例func NewCustomer(id int, name string, gender string,age int, phone string, email string) Customer {return Customer{Id: id,Name: name,Gender: gender,Age: age,Phone: phone,Email: email,}}//返回用戶訊息func (c Customer) GetInfo() string {info := fmt.Sprintf(&amp;quot;%v	%v	%v	%v	%v	%v&amp;quot;,c.Id, c.Name, c.Gender, c.Age, c.</description>
    </item>
    
    <item>
      <title>實作練習-家庭收支小app</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/</guid>
      <description>實作練習-家庭收支小app type MyMoney struct {key string //鍵入值note string //收支說明balance float64 //餘額money float64 //收支flag bool //判斷是否有明細details string //詳細loop bool //循環}//綁定方法func (mm *MyMoney) MainMenu() {for {if !mm.loop {break}fmt.Println(&amp;quot;\n-----------------家庭收支记账软件-----------------&amp;quot;)fmt.Println(&amp;quot; 1 收支明细&amp;quot;)fmt.Println(&amp;quot; 2 登记收入&amp;quot;)fmt.Println(&amp;quot; 3 登记支出&amp;quot;)fmt.Println(&amp;quot; 4 退出软件&amp;quot;)fmt.Print(&amp;quot;請選擇(1-4)...&amp;quot;)fmt.Scanln(&amp;amp;mm.key)switch mm.key {case &amp;quot;1&amp;quot;:mm.showDetails()case &amp;quot;2&amp;quot;:mm.income()case &amp;quot;3&amp;quot;:mm.outcome()case &amp;quot;4&amp;quot;:mm.exit()default:fmt.</description>
    </item>
    
    <item>
      <title>實作練習-點對點聊天</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/</guid>
      <description>實作練習-點對點聊天 server.go func main() {fmt.Println(&amp;quot;服務器開始監聽&amp;quot;)listen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;0.0.0.0:8888&amp;quot;) //0.0.0.0 寫4位ip v4 v6都能用if err != nil {fmt.Println(&amp;quot;監聽失敗&amp;quot;, err)return}defer listen.Close() //主程式退出後就關閉監聽// fmt.Printf(&amp;quot;listen succes=%v\n&amp;quot;, listen)for {//開啟監聽端口8888time.Sleep(time.Microsecond)fmt.Println(&amp;quot;等待連接中...&amp;quot;)conn, err := listen.Accept()if err != nil {fmt.Println(&amp;quot;Accept()err=&amp;quot;, err)} else {fmt.Printf(&amp;quot;conn suc con=%v 客戶端ip=%v\n&amp;quot;, conn, conn.RemoteAddr().String())}//準備啟動一個協程go process(conn)}}func process(conn net.Conn) {//循環接收客戶端送來的數據defer conn.Close()fmt.Printf(&amp;quot;服務器等待%s客戶端輸入...\n&amp;quot;, conn.</description>
    </item>
    
    <item>
      <title>對有序數列進行二分查找</title>
      <link>https://yoziming.github.io/post/210810-agg-go-binary-search/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-binary-search/</guid>
      <description>//對有序數列進行二分查找var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 0}func bubble(x []int) {for j := 1; j &amp;lt; len(x); j++ {for i := 0; i &amp;lt; len(x)-1; i++ {if x[i] &amp;gt; x[i+1] {x[i], x[i+1] = x[i+1], x[i]}}}}func bi(x int, s []int, left int, right int) {middle := (right + left) / 2if left &amp;gt; right {fmt.</description>
    </item>
    
    <item>
      <title>工廠模式</title>
      <link>https://yoziming.github.io/post/210810-agg-go-factory/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-factory/</guid>
      <description>//工廠模式// 假如有些要公用的東西又不想用大寫讓人隨意改了 例如結構體、結構體內的字段等等// 我就在那個包裏建一個方法，這個方法本身大寫，在方法中原地調用那些本來是大寫的玩意// 返回一個相同的值過來，相當於那在那個包里把該封裝的都封好，拿出來的就是產品import (&amp;quot;fmt&amp;quot;)type Student struct {Name stringAge intScore float64}func (s *Student) Say() string {infoStr := fmt.Sprintf(&amp;quot;信息 name=[%v] age=[%v] score=[%v]&amp;quot;,s.Name, s.Age, s.Score)return infoStr}func main() {var s1 = Student{Name: &amp;quot;tom&amp;quot;,Score: 98,Age: 18, //不依賴順序}res := s1.Say()fmt.Println(res)//其他創建結構變量同時指定值的方法:stu2 := Student{&amp;quot;Jack&amp;quot;, 20, 100} //項目順序都要有對應fmt.Println(stu2)//返回結構的指針var stu3 = &amp;amp;Student{&amp;quot;Mary&amp;quot;, 28, 5}fmt.</description>
    </item>
    
    <item>
      <title>拷貝檔案</title>
      <link>https://yoziming.github.io/post/210810-agg-go-io-copy/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-io-copy/</guid>
      <description>拷貝一個檔案 //定義一個函數接收2個路徑func CopyFile(dstFileName, srcFileName string) (written int64, err error) {srcFile, err := os.Open(srcFileName)if err != nil {fmt.Println(err)}defer srcFile.Close()//通過srcFile獲取到readerreader := bufio.NewReader(srcFile)//打開dstFileNamedstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666)if err != nil {fmt.Println(err)}//通過dstFile獲取到writerwriter := bufio.NewWriter(dstFile)defer dstFile.Close()return io.Copy(writer, reader)}func main() {src := &amp;quot;C:/01.mkv&amp;quot; //原始檔dst := &amp;quot;C:/food2.mkv&amp;quot;_, err := CopyFile(dst, src)if err == nil {fmt.</description>
    </item>
    
    <item>
      <title>接口interface</title>
      <link>https://yoziming.github.io/post/210810-agg-go-interface/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-interface/</guid>
      <description>接口interface  例如定義 只要滿足&amp;quot;會跑&amp;quot;且&amp;quot;會叫&amp;quot;的就是&amp;quot;動物&amp;quot;，
那不管你是啥玩意只要實現會跑跟會叫，我就當你是動物，就能用動物的接口去調用
 //接口內不能有變量，方法也不能實現type Usb interface {//聲明兩個沒實現的方法Start()Stop()}type Usb2 interface {//接口是不需要顯示聲明，只要能實現就都能調用Start()Stop()//假如我多聲明一個沒實現的方法在接口內就不能調用Test() //有方法沒實現，導致Usb2這個接口不能用}type Phone struct {}//讓Phone實現USB接口的方法func (p Phone) Start() {fmt.Println(&amp;quot;手機啟動&amp;quot;)}func (p Phone) Stop() {fmt.Println(&amp;quot;手機停止&amp;quot;)}type Camera struct {}func (c Camera) Start() {fmt.Println(&amp;quot;相機啟動~~&amp;quot;)}func (c Camera) Stop() {fmt.Println(&amp;quot;相機停止&amp;quot;)}//電腦type Computer struct {}func (c Computer) Working(usb Usb) { //接受一個Usb的接口類型//通過usb變量來調用Start等方法fmt.</description>
    </item>
    
    <item>
      <title>數組</title>
      <link>https://yoziming.github.io/post/210810-agg-go-array1/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-array1/</guid>
      <description>數組 func main() {var n1 [3]int = [3]int{1, 2, 3}var n2 = [3]int{4, 5, 6}//長度聲明後就不能變化var n3 = [...]int{7, 8, 9}//數組長度是類型的一部分 [3]int != [4]intvar n4 = [...]string{0: &amp;quot;李四&amp;quot;, 1: &amp;quot;張三&amp;quot;, 5: &amp;quot;王武&amp;quot;}n5 := []int{5, 5, 5, 5, 5}//[]int 這樣定義其實是切片fmt.Println(n1)fmt.Println(n2)fmt.Println(n3)fmt.Println(n4)fmt.Println(n5)n9 := fmt.Sprintf(&amp;quot;%.2f&amp;quot;, 9.888888)fmt.Println(n9)var score [5]float64for i := 0; i &amp;lt; len(score); i++ {fmt.Println(&amp;quot;輸入成績&amp;quot;)fmt.Scanln(&amp;amp;score[i])}for i := 0; i &amp;lt; len(score); i++ {fmt.</description>
    </item>
    
    <item>
      <title>文字檔案讀取寫入</title>
      <link>https://yoziming.github.io/post/210810-agg-go-io-reader/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-io-reader/</guid>
      <description>讀取 func main() {//打開一個文件file, err := os.Open(&amp;quot;c:/test.txt&amp;quot;)//有人叫file對象/指針/文件句柄if err != nil {fmt.Println(&amp;quot;open file err=&amp;quot;, err)}//看看文件是啥fmt.Printf(&amp;quot;file=%v\n&amp;quot;, file)//退出函數就關閉文件defer file.Close()//創建一個帶緩衝的reader，預設大小是4096reader := bufio.NewReader(file)for {str, err := reader.ReadString(&#39;\n&#39;) //讀到換行就結束fmt.Print(str)if err == io.EOF { //表示文件末尾break}}fmt.Println(&amp;quot;\n讀取結束&amp;quot;)//用ioutil.ReadFile一次讀完//這個包已經封裝了open跟close了，只適用在檔案大小不大的情境file2 := &amp;quot;c:/test.txt&amp;quot;str2, err2 := ioutil.ReadFile(file2)if err2 != nil {fmt.Println(err)}fmt.Printf(&amp;quot;%s&amp;quot;, str2) //原本輸出是[]byte,用%s轉//創建一個新檔案，寫入5句話filePath := &amp;quot;c:/abc.</description>
    </item>
    
    <item>
      <title>文檔字符統計</title>
      <link>https://yoziming.github.io/post/210810-agg-go-txt/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-txt/</guid>
      <description>文檔字符統計 //保存結果用type CharCount struct {ChCount int //英文字數NumCount int //SpaceCount intOtherCount int}func main() {//思路 打開一個文件 創一個reader每讀取一行就去統計，將結果保存到一個結構體fileName := &amp;quot;c:/abc.txt&amp;quot;file, err := os.Open(fileName)if err != nil {fmt.Println(err)return}defer file.Close()//來個實例var count CharCountreader := bufio.NewReader(file)//開始讀取for {str, err := reader.ReadString(&#39;\n&#39;)//這存在BUG 當行不換行做結尾就統計不到if err == io.EOF {break}for _, v := range str {switch {case v &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;z&#39;:fallthroughcase v &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;Z&#39;:count.</description>
    </item>
    
    <item>
      <title>日期時間</title>
      <link>https://yoziming.github.io/post/210810-agg-go-datetime/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-datetime/</guid>
      <description>日期時間 func main() {//1.獲取當前本地時間now := time.Now()fmt.Printf(&amp;quot;now=%v,type=%T&amp;quot;, now, now) //返回的類型是struct//2.通過now獲取各種詳細fmt.Printf(&amp;quot;年=%v,type=%T\n&amp;quot;, now.Year(), now.Year())fmt.Printf(&amp;quot;月=%v,type=%T\n&amp;quot;, now.Month(), now.Month())fmt.Printf(&amp;quot;月=%v,type=%T\n&amp;quot;, int(now.Month()), int(now.Month()))fmt.Printf(&amp;quot;日=%v,type=%T\n&amp;quot;, now.Day(), now.Day())fmt.Printf(&amp;quot;時=%v,type=%T\n&amp;quot;, now.Hour(), now.Hour())fmt.Printf(&amp;quot;分=%v,type=%T\n&amp;quot;, now.Minute(), now.Minute())fmt.Printf(&amp;quot;秒=%v,type=%T\n&amp;quot;, now.Second(), now.Second())fmt.Printf(&amp;quot;星期=%v,type=%T\n&amp;quot;, now.Weekday(), now.Weekday())fmt.Printf(&amp;quot;星期=%v\n&amp;quot;, int(now.Weekday()))//3.格式化日期時間dateStr := fmt.Sprintf(&amp;quot;年月日時分=%d-%d-%d %d:%d\n&amp;quot;, now.Year(), now.Month(),now.Day(), now.Minute(), now.Second())fmt.Println(dateStr)//4.蛋疼的指定格式fmt.Println(now.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;))fmt.Println(now.Format(&amp;quot;2006-01-02&amp;quot;))fmt.Println(now.Format(&amp;quot;06&amp;quot;))fmt.Println(now.Format(&amp;quot;01&amp;quot;))fmt.Println(now.Format(&amp;quot;03&amp;quot;))fmt.Println(now.Format(&amp;quot;01-02-06 03 04 05&amp;quot;))//123456=月日時分秒年//5.時間常量&amp;amp;休眠//每隔固定時間打印數字，打到100退出for i := 0; i &amp;lt;= 100; i++ {fmt.</description>
    </item>
    
    <item>
      <title>結構體</title>
      <link>https://yoziming.github.io/post/210810-agg-go-struct/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-struct/</guid>
      <description>結構體 type Cat struct {Name stringAge intColor string// S1 []int //可以是切片 但是預設值為nil(沒分配空間，一樣要先make後才能用)}//結構體是一個值類型，預設是值拷貝，比如cat1跟cat2是獨立存在兩個空間func main() {//創建Cat的變量var cat1 Catcat1.Name = &amp;quot;小花&amp;quot;cat1.Age = 18cat1.Color = &amp;quot;花&amp;quot;fmt.Println(&amp;quot;cat1=&amp;quot;, cat1)// cat1.S1 = make([]int, 10)// cat1.S1[0] = 100// fmt.Println(&amp;quot;cat1=&amp;quot;, cat1)//推薦方式cat2 := Cat{&amp;quot;小黑&amp;quot;, 5, &amp;quot;black&amp;quot;}fmt.Println(cat2)//方法3//var c *C=new(C)var cat3 *Cat = new(Cat)//因為cat3是一個指針(*cat3).Name = &amp;quot;小白&amp;quot;//語法糖 cat3.Age也可以 ，不建議cat3.</description>
    </item>
    
    <item>
      <title>繼承</title>
      <link>https://yoziming.github.io/post/210810-agg-go-inherit/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-inherit/</guid>
      <description>繼承 type Student struct {Name stringAge intScore int//共有的字段}type Pupil struct {Student //套入Covid19 bool}type College struct {Student //套入指針效率更好SexExp bool}func (stu *Student) ShowInfo() {fmt.Printf(&amp;quot;姓名=%v 年齡=%v 成績=%v\n&amp;quot;, stu.Name, stu.Age, stu.Score)}func (stu *Student) SetScore(s int) {stu.Score = s}func (p *Pupil) Test() {fmt.Println(&amp;quot;小學生考試&amp;quot;)}func main() {pupilA := &amp;amp;Pupil{}pupilA.Student.Name = &amp;quot;tome&amp;quot;pupilA.Student.Age = 8pupilA.</description>
    </item>
    
    <item>
      <title>錯誤處理</title>
      <link>https://yoziming.github.io/post/210810-agg-go-err/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-err/</guid>
      <description>錯誤處理 func test() { //捕捉異常 	defer func() { //內置函數recover就是找是否異常 	if err := recover(); err != nil { //err不為空=有錯 	fmt.Println(&amp;#34;錯誤&amp;#34;, err) } }() n1 := 10 n2 := 0 res := n1 / n2 fmt.Println(res) } //讀取文件名稱，錯誤就報錯 func readConf(name string) (err error) { if name == &amp;#34;config.ini&amp;#34; { return nil } else { //返回自訂錯誤 	return errors.New(&amp;#34;文件錯誤&amp;#34;) } } func test02() { err := readConf(&amp;#34;config.in564&amp;#34;) if err != nil { panic(err) } fmt.</description>
    </item>
    
    <item>
      <title>順序查找</title>
      <link>https://yoziming.github.io/post/210810-agg-go-sequential-search/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-sequential-search/</guid>
      <description>順序查找 func main() {names := [4]string{&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;}var input = &amp;quot;&amp;quot;fmt.Println(&amp;quot;輸入...&amp;quot;)fmt.Scanln(&amp;amp;input)//順序查找// for i := 0; i &amp;lt; len(names); i++ {// if input == names[i] {// fmt.Printf(&amp;quot;找到%v,下標=%v \n&amp;quot;, input, i)// break// } else if i == len(names)-1 {// fmt.Println(&amp;quot;比對失敗...&amp;quot;)// }//順序查找2index := -1for i := 0; i &amp;lt; len(names); i++ {if input == names[i] {index = ibreak}}if index !</description>
    </item>
    
  </channel>
</rss>
