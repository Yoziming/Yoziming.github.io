<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 柚子茶室</title>
    <link>https://yoziming.github.io/post/</link>
    <description>Recent content in Posts on 柚子茶室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Yoziming</copyright>
    <lastBuildDate>Sat, 05 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yoziming.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>前端筆記</title>
      <link>https://yoziming.github.io/post/220305-frontend-learn/</link>
      <pubDate>Sat, 05 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220305-frontend-learn/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JSP、Hibernate、Spring Data JPA</title>
      <link>https://yoziming.github.io/post/220301-jsp-jpa/</link>
      <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220301-jsp-jpa/</guid>
      <description>JSP  萬萬沒想到JSP這種我以為早就被淘汰的東西，在台灣還有很多企業在用
  JSP的本質其實是Servlet，當它第一次被訪問，透過Web容器(Tomcat)的JSP引擎編譯成Servlet，然後一樣執行init()方法一次，之後開始service()，直到最後被卸載destroy() Servlet在Web容器中其實也是編譯成Java，產生.class檔案，當有請求過來就動態的處理一些業務邏輯(例如從request拿參數、去DB撈出對應的資料)，最後這個.class用out.print()拼接出封裝好的html的靜態頁面，返回給使用者 確實可以在JSP中寫出一個直接捅到JDBC撈資料然後返回的程式碼，但一般來說不會這麼做，而是使用MVC架構 MVC架構下，訪問發送一個請求過來，轉到Controller，再送到Service層處理業務邏輯，把處理完的資料(可能是某VO)放到pageContext之類的地方，而JSP是作為一個類似模板的地位，用jstl之類的標籤做簡單的邏輯控制、填充要呈現的結果頁面，最後輸出成html給使用者 在這種使用框架的情境下，通常用xx.do、xx.action、xx.html等等作為請求的網址，方便Controller區分靜態文件(例如.css或.js)與請求 JSP的缺點就是它必須依賴Web容器，部署、調試都很麻煩又慢，且Web容器Tomcat在高併發之下成為性能瓶頸，高耦合、難遷移(如果是純html模板那遷移相對容易，JSP就綁死在Java樹上)，故JSP技術被淘汰  JPA  Java Persistence API
  「Java 持久化的 API」，JPA是一個標準規範及接口，通過註解(annotation) 如@Entity、@Table、@Column或XML描述物件－關係表的對映關係，將執行期(在記憶體中)的實體物件持久化到資料庫中 JPA只是一個標準規範，而要使用JPA的功能就需要Provider來配合，而Provider就是各種ORM框架 Database - JDBC - JPA - 各種ORM框架  Hibernate  全表映射，它把DB與開發者隔離了，可以完全不管DB類型，而使用HQL語句代替，但也是可以用native sql，壞處是性能差，有3種使用模式 Hibernate Query Language  String hql=&amp;#34;select u.uid,u.uname,u.upwd from Users u where u.uname=&amp;#39;張三&amp;#39;&amp;#34;; Query query = session.createQuery(hql); List&amp;lt;Object[]&amp;gt; list = query.list(); for (Object[] objects : list) {  System.out.println(Arrays.toString(objects)); }  原生SQL查詢，例如:  String sql = &amp;#34;select uid,uname,upwd from _users&amp;#34;; List list = session.</description>
    </item>
    
    <item>
      <title>用Javafaker產生假資料</title>
      <link>https://yoziming.github.io/post/220228-postgres-javafaker/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220228-postgres-javafaker/</guid>
      <description>填充模板資料  工作上遇到的情境，業務要推銷軟體產品，需要做一個Demo展示，有個功能是可以顯示精美的圖形報表，那總不可能自己一筆一筆輸入資料
  使用的技術有PostgreSQL、JPA、Javafaker、Gradle 其實單純是我目前工作上即將用到的技術  PostgreSQL   資料庫，開源免費，社群愛用
  直接docker拉一個
  docker pull postgres:10-alpine docker run -p 5432:5432 --name postgres --restart=always -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -d postgres:10-alpine  隨便建一個表  CREATE TABLE public.staff ( id int8 NOT NULL, full_name text NOT NULL, age int4 NOT NULL, address bpchar(150) NULL, salary numeric NULL, CONSTRAINT company_pkey PRIMARY KEY (id) ); Eclipse + Gradle + Lombok  首先確定Eclipse有裝好Lombok，沒有的話去官網下載  https://projectlombok.</description>
    </item>
    
    <item>
      <title>Windows 11與WSL</title>
      <link>https://yoziming.github.io/post/220226-win11-wsl2/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220226-win11-wsl2/</guid>
      <description>Win 11  其實單純就是手癢，順便記錄一下重灌後的事項  chocolatey  Windows 上的套件管理工具，類似apt跟brew 安裝使用powershell執行:  Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&amp;#39;https://community.chocolatey.org/install.ps1&amp;#39;))  (非必要) 修改安裝路徑，預設是在  C:\ProgramData\chocolatey  他其實是一個系統環境變數，所以也可以手動修改，例如  setx.exe ChocolateyInstall D:\Chocolatey /M  安裝常用的工具，可以自己做批次腳本執行  -y的意思是自動確認，可以全自動安裝    choco install chocolateygui -y choco install -y notepadplusplus choco install qdir -y choco install -y git choco install -y hugo choco install typora --version=0.11.18.20211125 -y choco pin add --name=&amp;#34;&amp;#39;typora&amp;#39;&amp;#34; --version=&amp;#34;&amp;#39;0.</description>
    </item>
    
    <item>
      <title>從IDEA轉移至Eclipse</title>
      <link>https://yoziming.github.io/post/220224-idea-to-eclipse/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220224-idea-to-eclipse/</guid>
      <description>背景  進了公司才發現沒有買IDEA，既然下定決心要做長期的，只能一切重來了  下載  直接下載Spring Tools 4 for Eclipse: https://spring.io/tools  這玩意就是包好的Eclipse，然後針對spring有優化 下載回來會是一個.jar，執行它就會解壓縮成資料夾，點進去裡面SpringToolSuite4.exe就是開啟了    JDK設定  這個.ini裡面的vm是for Eclipse本身(Eclipse是用java寫的)，不要去改它，就用它自帶的就好，否則太低版本會啟動不了   專案裡面用的jdk版本那是另一回事，可以按alt+enter查看專案設定   設定從這邊進去   在這裡選定預設的JDK版本  插件  這邊可以安裝插件，有些插件還要選安裝範圍、還要按同意、總之挺麻煩的   透過這個內建的瀏覽器去開市集、安裝、移除插件都慢得離譜(好像是因為每次打開他都會下載整個清單) 還不如直接用瀏覽器開啟網站 https://marketplace.eclipse.org/  用拖曳的就可以安裝，把排名靠最前的都裝一裝基本不會錯    DevStyle  提供好看的主題，並且可以改成自己習慣的配色  編碼  需要手動設定成UTF-8   還有其他各種奇奇怪怪的地方也都要改，以及XML等等  改字型  超麻煩，需要一個一個點開然後修改  console  這個不改，執行前就會一直跳出警告，既然他說buffer最好要1000000，那一開始何必設80000，真的是有病  自動補完  Eclipse預設只對.起反應 搜尋Content Assist，手動把所有字都加進去   另外IDEA中自動補完的Tab在這裡變成alt+/，如果延遲設成0就不用按，直接用方向鍵上下選，然後enter套用(蠻難用的，不像IDEA一個Tab走天下) 但是這樣會出事，因為它很蠢的連按空格跟;都會自動選用補完的第一順位，導致超級難用，需要根據個人習慣的速度，像我設定延遲500毫秒  改檔案瀏覽器  路徑改成樹狀顯示(預設是Flat，這個相當於.</description>
    </item>
    
    <item>
      <title>職場新人要點</title>
      <link>https://yoziming.github.io/post/220222-java-interview-04/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220222-java-interview-04/</guid>
      <description>新人該學的  把自己當作海綿，先努力吸收 觀察、記錄團隊文化，包括檔案分類/命名/類別分類/資料庫慣例 提前問，好過事後出包補救 知道怎麼&amp;quot;問問題&amp;quot;  最好先理解關鍵字，試著猜答案，先google看看 實際操作發現不行了，將問題具體化，例如: 我想達成怎樣的效果，嘗試使用了何種方法，但遇到怎樣的問題，請教需要如何解決 切勿成為伸手黨，切勿還沒試過就說不會或不行   定期要求他人評價，審視自己是否能跟上、融入團隊  該做的  閱讀使用者文件(給客戶看的)，先別管程式是怎麼寫的，第一件事情要先搞懂你的產品，以使用者的角度 嘗試理解公司的程式架構，大處著眼小處著手，試著畫出程式之間的依賴關係 做每個功能前先確認這個功能的目的是什麼，你的工作不是完成某個 for loop，而是確保你的 code 有幫助到你們公司/組織 coding前先用文字把想像中的實作大概描述一下，看一下是否合理(容易理解、擴充) 注意影響的範圍與權限，改動前確保有做好備份，可別出包搞到全公司無法運作 請同事 review 你的 code 看有沒有改進的地方(跟你的寫法有什麼差異、看不看得懂、有沒有辦法修改)  關於Code品質  有意義的、完整的命名，不要擅自簡寫還以為別人也都能看懂 限制傳入參數數量，不要大於3個，超過就考慮傳map或DTO 變數考慮使用的範圍，適當封裝、避免耦合 一次只做一件事，function命名要跟實際做的事情相符，沒有明確告知就不要擅自夾帶各種的功能，否則可能造成後續test困擾 避免使用多層if嵌套、可以Early return  給自己設立目標  短期: 一個月內掌握情況，開始有產出 中期: 半年內能獨立完成交辦任務 長期: 嘗試學習做手機app，看學Flutter或是專攻kotlin與jetpack compose  </description>
    </item>
    
    <item>
      <title>Java面試，機考題整理</title>
      <link>https://yoziming.github.io/post/220217-java-interview-02/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220217-java-interview-02/</guid>
      <description>其實就是leetcode easy題，把常見的盡量做一做吧
 反轉字串 /** * 輸入 &amp;#39;abcde&amp;#39; 輸出 &amp;#39;edcba&amp;#39; */ private static String reverseStr(String str) { String result = &amp;#34;&amp;#34;; for (int i = str.length(); i &amp;gt;= 1; i--) { result = result + str.charAt(i - 1); } return result; } 是否迴文 private boolean isPal(String str) { String newStr = new StringBuilder(str).reverse().toString(); return str.equals(newStr); } FizzBuzz /** * FizzBuzz * 給一個整數 n 請列印出 1~n 的每一個整數， 但是 * 當整數可以被 3 整除的時候印出 Fizz 來代替原本要印出的數， * 當整數可以被 5 整除的時候印出 Buzz 來代替原本要印出的數， * 當整數可以被 3 跟 5 整除的時候印出 FizzBuzz 來代替原本原本要印出的數。 */ private static void printFizzBuzz(int n) { for (int i = 1; i &amp;lt;= n; i++) { if (i % 3 == 0 &amp;amp;&amp;amp; i % 5 == 0) { System.</description>
    </item>
    
    <item>
      <title>Java初階面試題整理-01</title>
      <link>https://yoziming.github.io/post/220216-java-interview-01/</link>
      <pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220216-java-interview-01/</guid>
      <description>Java特性  純物件導向(Object-oriented programming，OOP)，任何行為是來自某個資料(物件)，目的是方便維護跟擴展性 跨平台(只要能跑JVM)、有GC  Java中的基本資料類型    基本類型 位元 位元組 預設值     int 32 4 0   short 16 2 0   long 64 8 0L   byte 8 1 0   char 16 2 &amp;lsquo;u0000&amp;rsquo;   float 32 4 0f   double 64 8 0d   boolean 1  false     這八種基本類型都有對應的包裝類分別為:Byte、Short、Integer、Long、Float、Double、Character、Boolean 包裝類型不賦值就是 Null ，而基本類型有預設值且不是 Null，所以通常在專案中設計entity都用包裝類，這樣從資料庫抓過來如果是空的不會自動變成0之類的引起麻煩 基本資料類型是存放在JVM棧中的區域變數表中(那些常用的早就準備好了)，而包裝類型屬於物件類型，我們知道物件實例都存在於堆中。相比於物件類型， 基本資料類型佔用的空間非常小  包裝類型的常量池技術？  Java 基本類型的包裝類的大部分都實現了常量池技術 Byte,Short,Integer,Long 這 4 種包裝類默認創建了數值 [-128，127] 的相應類型的緩存資料，Character 創建了數值在 [0,127] 範圍的緩存資料 就是因為有裝箱與常量池，所有整型包裝類物件之間值的比較，全部使用 equals 方法比較才不會踩坑  基本雜問 Java中只有值傳遞  Java是Pass by Value傳值，將參數值複製後傳遞 如果參數是基本類型的話，很簡單，傳遞的就是基本類型的字面量值的拷貝，會創建副本 如果參數是參考類型，傳遞的就是實參所引用的物件在堆中位址值的拷貝，同樣也會創建副本  throw與throws的區別?</description>
    </item>
    
    <item>
      <title>商城初級高級篇總和與展示</title>
      <link>https://yoziming.github.io/post/220214-gulimall-26/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220214-gulimall-26/</guid>
      <description>柚子商城  基於SpringBoot、SpringCloud的大型分散式微服務架構B2C商城項目 項目由業務集群 + 後台管理系統構成，主要練習微服務架構、服務註冊與發現、遠程調用、網關、Restful接口、數據校驗、高併發處理、MQ訊息中心、限流降級、鏈路追蹤、性能監控、壓力測試等等  專案背景(Background)  本項目參考自 尚硅谷java微服務課程: https://www.bilibili.com/video/BV1np4y1C7Yf?p=342 個人學習過程的詳細筆記(共26篇): https://yoziming.github.io/post/220118-gulimall-01/  項目架構圖 解析  使用者通過任意客户端（app/Web）向伺服器發送請求，請求首先來到Nginx集群，Nginx將請求轉交給Api網關（SpringCloud Gateway） Api網關:  根據當前請求，動態路由到指定的服務 如果服務出現問題，也可以在網關通過Sentinel做熔斷降級與限流，例如超過負荷時暫時顯示排隊頁面，只放伺服器能乘載的輛   Nacos註冊中心：微服務的註冊與發現 Feign：微服務之間的遠程調用 OAuth2.0認證中心：登入與請求權限的管理 快取：使用Redis結合spring cache與redsson分布式鎖 持久化：使用MySQL 消息隊列：使用Rabbit MQ實現微服務之間的非同步解耦，包括完成分佈式事務的最終一致性 全文檢索：使用Elastic Search實現 圖片存儲：使用MinIO存儲服務 Sleuth + Zipkin：服務的可視化追蹤 其他運維部分暫時沒完成  服務模組 檔案結構 mall-parent ├── auth-server -- 登入認證中心 ├── cart -- 購物車服務 ├── common -- 工具類及通用程式碼 ├── coupon -- 優惠服務 ├── gateway -- 網關 ├── member -- 會員服務 ├── order -- 訂單服務 ├── preset -- 啟動需要的前置工作(docker、sql語句等等) ├── product -- 商品服務 ├── search -- 商品搜尋服務 ├── seckill -- 秒殺優惠服務(高併發所以獨立出來) ├── third-party -- 第三方服務 ├── ware -- 倉儲服務 ├── renren-fast -- 後台管理系統 ├── renren-generator -- 人人開源項目的代碼生成器 renren-fast-vue -- 後台管理系統 技術選型 後端技術    技術 説明 官網     SpringBoot 容器+MVC框架 https://spring.</description>
    </item>
    
    <item>
      <title>微服務商城之高可用集群篇</title>
      <link>https://yoziming.github.io/post/220213-gulimall-25/</link>
      <pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220213-gulimall-25/</guid>
      <description>高可用集群篇  微服務做到現在，終於要開始部署了，首先要認識Kubernetes(K8S) 之前也有稍微了解過K8S，見筆記 https://yoziming.github.io/post/211006-k8s/ 簡單來說就是用來管理doker的總控  Master  API Server: API介面 etcd: K-V形式的消息隊列 Scheduler: 監視Pod、調度叢集 kube-controller-manager: 操作進程的管理員  節點控制器（Node Controller）: 負責在節點出現故障時進行通知和回應 任務控制器（Job controller）: 監測代表一次性任務的 Job 物件，然後創建 Pods 來運行這些任務直至完成 端點控制器（Endpoints Controller）: 填充端點(Endpoints)對象(即加入 Service 與 Pod) 服務帳戶和權杖控制器（Service Account &amp;amp; Token Controllers）: 為新的命名空間創建默認帳戶和 API 訪問權杖    Noede  Container Runtime: 正常就是Docker，負責運行容器 kubelet: 工頭，每個節點的負責人，管理Pod kube-proxy: 節點的網路接口，負責通訊 Fluentd: 日誌  Pod  K8s管理的最小單元 裡面可以有多個容器，共用一個網路位置  其他名詞  Controllers: Pod的高層抽象，用來實際執行部署   Service: 也是抽象，Pod組成的一個服務   Namespace: 邏輯隔離資源  暫時停下  要運行K8S對資源的要求(主要是ram)太狠了，我的小破電腦已經扛不住了 課程只好暫時先停在這，整理一下手邊的資源，先去準備工作的事  </description>
    </item>
    
    <item>
      <title>初識AWS與帳號驗證的趣事</title>
      <link>https://yoziming.github.io/post/220212-aws-phone/</link>
      <pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220212-aws-phone/</guid>
      <description>申請AWS帳號  是這樣的，我的手機門號是台灣之星，註冊後的驗證始終收不到簡訊驗證碼  題外話，國際電話手機格式 +886 912345678，+886就是0   估狗發現別人也有同樣問題，有說更換語言的，有說換APN的，但我試過都沒用 只好找客服，AWS有線上客服(跳出一個小即時通那樣)，我就填說帳號啟用有問題，收不到驗證碼，我的電話號是多少之類(英文) 結果隔一會顯示有專人來處理了，是直接打電話過來，嚇我一跳 重點是她客服那邊的口音超重(好像是個印度小妹)，通話音質又差，我自己英文也是好幾年沒用，整個溝通真的是困難到爆炸 雞同鴨講半天，最後只好說咱們用文字溝通吧 後來終於弄懂她的意思是，你需要在電話中用語音說出你的用戶名稱、email帳號、電話，他們公司服務部門才能確認跟處理後續 好久沒講英文突然真不習慣，像是塵封多年的老機器突然重新開機，搞定後說要5小時工作時間，看看後續如何  結論  如果找AWS客服，最好提前做下心理準備要用英語溝通 效率還是不錯的，兩個小時後就收到回信了  Hello again, Great news! Our service team has manually bypassed the phone verification step for you, so all you need to do is refresh your console and Select a Support Plan. 1) Validate your credit/debit card ✓ DONE 2) Validate your phone number - ✓ DONE 3) Select your Support Plan - (Pending) You will be able to do this once step 4 is finished.</description>
    </item>
    
    <item>
      <title>用Heroku部署Tomcat網站</title>
      <link>https://yoziming.github.io/post/220211-javaweb-heroku/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220211-javaweb-heroku/</guid>
      <description>Heroku部署JavaWeb項目   我自己的JavaWeb是運行在Tomcat的，所以要用heroku提供的Tomcat，叫做webapp-runner
  用法也很簡單，本地maven引用webapp-runner，打包成war，push到heroku倉庫，自動就能運行起來了
  首先在專案根目錄新增Procfile，沒有副檔名
  web: java $JAVA_OPTS -jar target/dependency/webapp-runner.jar --port $PORT target/*.war  加入webapp-runner依賴，注意它版本是跟Tomcat的，我用8版Tomcat所以選8.5.68   &amp;lt;build&amp;gt;  &amp;lt;plugins&amp;gt;  &amp;lt;plugin&amp;gt;  &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;  &amp;lt;executions&amp;gt;  &amp;lt;execution&amp;gt;  &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;  &amp;lt;goals&amp;gt;  &amp;lt;goal&amp;gt;copy&amp;lt;/goal&amp;gt;  &amp;lt;/goals&amp;gt;  &amp;lt;configuration&amp;gt;  &amp;lt;artifactItems&amp;gt;  &amp;lt;artifactItem&amp;gt;  &amp;lt;groupId&amp;gt;com.heroku&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;webapp-runner&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;8.5.68.1&amp;lt;/version&amp;gt;  &amp;lt;destFileName&amp;gt;webapp-runner.jar&amp;lt;/destFileName&amp;gt;  &amp;lt;/artifactItem&amp;gt;  &amp;lt;/artifactItems&amp;gt;  &amp;lt;/configuration&amp;gt;  &amp;lt;/execution&amp;gt;  &amp;lt;/executions&amp;gt;  &amp;lt;/plugin&amp;gt;  &amp;lt;/plugins&amp;gt;  &amp;lt;/build&amp;gt;  打包完成專案長這樣    我是有安裝heroku cli，比較方便一點，可以直接在本地用heroku指令，也可以在網頁版上面做到一樣的步驟</description>
    </item>
    
    <item>
      <title>高併發方案、Sentinel限流、Sleuth鏈路追蹤</title>
      <link>https://yoziming.github.io/post/220210-gulimall-24-sentinel/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220210-gulimall-24-sentinel/</guid>
      <description>高併發關注重點  單一職責: 專門的服務模組，就只幹這件事，不論要擴容或是掛了都方便 鏈結加密: 每場商品都有隨機產生的Token，防有心人提早準備(台鐵搶票系統學一下好嗎?) 預熱、扣減: 既然知道會讀多寫少，提前把要被查的資料放Redis；用信號量做令牌，只放行這些數量 動靜分離: 靜態資源從網關就打回去，確保來到伺服的都是動態請求 攔截惡意請求: 在網關設定，判斷那些非人的操作(例如同IP超快超大量的)，直接擋回去 流量錯峰: 用干擾手段使人的操作時間不同(就是噁心用戶)，爭取錯開請求進來的時間 限流、熔斷、降級: 降級就是負載超過上限，Show一個&amp;quot;當前流量過高，請稍後重試&amp;quot;之類的惱人畫面給用戶看 延遲隊列: 終極手段，管你多少請求只要通過驗證就放進隊列，之後慢慢處理，總會給你處理到，但不保證是現在  Sentinel  官方: https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D
  用來限流、保護資源 Sentinel分為核心庫 與 Dashboard可視化界面，核心庫不依賴Dashboard 工作原理主要分為三個步驟:  定義資源: 叫做&amp;quot;埋點&amp;quot;，即聲明要保護的資源，可以是服務、方法、甚至單純一段程式碼  方法很多，最簡單就是用註解或try-catch https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8   定義規則: 流量控制規則、熔斷降級規則、系統保護規則、來源訪問控制規則 和 熱點參數規則  最簡單就是開啟Dashboard用可視化界面建立規則(但這樣用的設定保存在記憶體，重開會消失)   檢驗規則是否生效    使用  引包  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-sentinel&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2021.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  設定application.properties  注意他有2端口，一個是訪問dashboard本身，預設是8080 另一個是微服務傳給sentinel中心，預設是8719    # sentinel控制台 spring.cloud.sentinel.transport.dashboard=localhost:8333 # 微服務與控制台傳輸數據的端口 spring.</description>
    </item>
    
    <item>
      <title>柚子書城</title>
      <link>https://yoziming.github.io/post/220209-javaweb-book-market/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220209-javaweb-book-market/</guid>
      <description>柚子書城  柚子書城是一個不依賴Spring框架，純粹的JavaWeb項目，主要練習HTTP基本功、Servlet、Session等原理，以及JDBC、資料庫連接池等基礎的SQL操作。
 專案背景(Background)  本項目參考自 尚硅谷java web課程 https://www.bilibili.com/video/BV1Y7411K7zz 個人學習過程的詳細筆記(共14篇): https://yoziming.github.io/post/220101-agg-javaweb-01/ 我修復了一些邏輯並完善功能，並成功將網站部署到雲端，可以透過公開網址訪問  展示網站(Website)  已將專案部署到heroku，由於dyno長時間沒用會自動休眠，有時候訪問可能需要等待約30秒雲端server啟動時間 https://my-javaweb-book-market.herokuapp.com/ 可自行註冊帳號，管理員權限帳號密碼為 admin  學習技術 前端   html、css、javascript的基礎認識
 例如: 各種標籤&amp;lt;a href&amp;gt;、&amp;lt;input type&amp;gt;、&amp;lt;form&amp;gt;    jsp、jQuery、JSTL標籤庫、EL運算式
 例如: &amp;lt;c:if test=&amp;quot;&amp;quot;&amp;gt;、${key1}、綁定點擊事件&amp;hellip;等等    Ajax，非同步請求的基礎構成，例如: $.getJSON()
  後端  不依賴Spring框架的http請求與響應操作 Servlet、Filter、Listener、Cookie、Session、JSON 驗證資訊、權限隔離、防止重複提交 JDBC、資料庫連接池、DAO操作SQL MVC與三層架構、搭建javaweb專案 web容器的運作與部屬  實現功能(Service)  柚子書城是簡單的商城項目，依業務劃分可分為五個主要模組     模組 需求     用戶 能驗證資訊(ajax)即時提示的會員註冊、登入(透過cookie)功能   商品 能夠分頁顯示商品(圖書)、可依照價格區間篩選   購物車 以Session實現的購物車，用戶可以快速地瀏覽、增刪購物項目   訂單 提交訂單、查看訂單詳情、確認收貨等等   管理後台 能驗證管理員帳號，增刪改查商品訊息、訂單訊息    演示(Demo)  以下透過gif簡單展示相關功能，若顯示有問題，可以移至個人blog觀看 https://yoziming.</description>
    </item>
    
    <item>
      <title>秒殺優惠模組、Cron表達式</title>
      <link>https://yoziming.github.io/post/220209-gulimall-23-sec-kill/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220209-gulimall-23-sec-kill/</guid>
      <description>秒殺優惠活動 流程  秒殺分兩部分，一是營運人員後台系統新增秒殺場次到DB，然後關聯商品到場次中 後台系統新增場次隸屬於Coupon優惠模組之下   這邊把活動的訊息封裝到資料庫，大部分生成器都做好了，只有少數搜尋條件等等要調整，就不一一列出  網關   注意，後台是網址帶有/api/，請求來自renren-fast-admin的(例如營運人員上架商品、促銷活動)，再重寫URL轉發給其他模組
  用戶訪問商城網站，是來自nginx轉發的，斷言是Host=cart.mall.com
  application.yml
  - id:coupon_routeuri:lb://couponpredicates:- Path=/api/coupon/**filters:- RewritePath=/api/(?&amp;lt;segment&amp;gt;.*),/$\{segment}- id:mall_seckill_routeuri:lb://seckillpredicates:- Host=seckill.mall.com秒殺模組  這邊負責實際業務邏輯的執行，秒殺有瞬間高併發的特點，必須要做限流＋異步＋緩存 + 頁面靜態化+ 獨立部署，還需要處理定時任務等等 定時任務將最近三天的場次 + 關聯商品上傳到redis中  高併發用redis    Cron表達式  用來定義定時任務的週期 由6個空格分開7個域     域 是否必填 值以及範圍 通配符     秒 是 0-59 , - * /   分 是 0-59 , - * /   時 是 0-23 , - * /   日 是 1-31 , - * ?</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA File scope</title>
      <link>https://yoziming.github.io/post/220208-idea-file-scpoe/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220208-idea-file-scpoe/</guid>
      <description>IDEA篩選檔案  IDEA預設的檔案瀏覽器真的很不優，我以前都很蠢的用搜尋然後一個一個翻。原來他還是能做到篩選的，就是步驟挺麻煩 首先要去scope裡面自己設定規則，還可以設定顏色之類的，參考官方: https://www.jetbrains.com/help/phpstorm/configuring-scopes-and-file-colors.html#predefined-scopes-list 一樣記得要設在&amp;quot;用於每個新專案&amp;quot;的設定，否則只會在當前專案生效 例如只想顯示設定檔，可以設定規則:  file:*.properties||file:*.yml||file:*.yaml  回到檔案瀏覽區，最好勾上compact，省得太多層資料夾會把列表拉得很長   切換到自定的scope規則，然後全部展開，就可以快速切換許多子模組的設定了   其他實用的篩選還有pom.xml、*config等等，可以自己發揮  </description>
    </item>
    
    <item>
      <title>LeetCode Easy: 66</title>
      <link>https://yoziming.github.io/post/220208-leetcode-easy-66/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220208-leetcode-easy-66/</guid>
      <description>\66. Plus One  沒頭緒時，可以先列出多種結果，拆解歸納相似之處 像這題+1其實就只有兩種情況，9或其他  class Solution {  /** * Input: digits = [4,3,2,1] * Output: [4,3,2,2] * Explanation: The array represents the integer 4321. * Incrementing by one gives 4321 + 1 = 4322. * Thus, the result should be [4,3,2,2]. */  // 從最後一位數開始遍歷(向前)，不為9時直接加一，為9時讓當前元素重置為0(進位了)  public int[] plusOne(int[] digits) {  for (int i = digits.length - 1; i &amp;gt;= 0; i--) {  // 如果等於 9 ，重置為0  if (digits[i] == 9){  digits[i] = 0;  } else {  // 不為9，直接加一返回  digits[i] ++;  return digits;  }  }  // 循環出來如果沒返回(原數字剛好是999之類的情況)，  // 所有的位都已經重置為0了 ，只需要數組擴容，在第一位數加一即可  digits = new int[digits.</description>
    </item>
    
    <item>
      <title>Maven微服務多模組管理</title>
      <link>https://yoziming.github.io/post/220209-maven-parent-module/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220209-maven-parent-module/</guid>
      <description>Maven多模組管理  groupId、artifactId、version稱為gav，三個必要項組成座標  &amp;lt;project&amp;gt; ... &amp;lt;dependencies&amp;gt;  &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;實際項目&amp;lt;/groupId&amp;gt; 　&amp;lt;artifactId&amp;gt;模塊&amp;lt;/artifactId&amp;gt; 　&amp;lt;version&amp;gt;版本&amp;lt;/version&amp;gt; 　&amp;lt;type&amp;gt;依賴類型&amp;lt;/type&amp;gt; 　&amp;lt;scope&amp;gt;依賴範圍&amp;lt;/scope&amp;gt; 　&amp;lt;optional&amp;gt;依賴是否可選&amp;lt;/optional&amp;gt; 　&amp;lt;!—主要用於排除傳遞性依賴--&amp;gt; 　&amp;lt;exclusions&amp;gt; 　&amp;lt;exclusion&amp;gt; 　&amp;lt;groupId&amp;gt;…&amp;lt;/groupId&amp;gt; 　&amp;lt;artifactId&amp;gt;…&amp;lt;/artifactId&amp;gt; 　&amp;lt;/exclusion&amp;gt; 　&amp;lt;/exclusions&amp;gt; 　&amp;lt;/dependency&amp;gt; &amp;lt;dependencies&amp;gt; ... &amp;lt;/project&amp;gt;   compile，預設的依賴範圍，表示依賴需要參與當前項目的編譯，後續的測試、運行週期也參與其中，是比較強的依賴。
  test，表示依賴僅僅參與測試相關的工作，包括測試代碼的編譯和運行。比較典型的如 junit。
  runntime，表示依賴無需參與到項目的編譯，不過後期的測試和運行需要其參與其中。
  provided，表示打包的時候可以不用包進去，別的容器會提供。和 compile 相當，但是在打包階段做了排除的動作。
  system，從參與程度上來説，和 provided 類似，但不通過 Maven 倉庫解析，可能會造成構建的不可移植，要謹慎使用。
   部分引用自 沉默王二 鏈接：https://juejin.cn/post/7033652977973854244
 父項目的作用  父項目繼承spring框架  繼承spring-boot-starter-parent同時也會繼承properties例如java.</description>
    </item>
    
    <item>
      <title>串接第三方支付</title>
      <link>https://yoziming.github.io/post/220208-gulimall-22-pay/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220208-gulimall-22-pay/</guid>
      <description>商城支付 非對稱加密 RSA  加密跟解密是不同的鑰匙  我用私鑰加密，發給給你，你用公鑰解密，你不知道我的私鑰   加簽: 根據明文(例如: &amp;ldquo;我給小明100元&amp;rdquo;)用MD5生成一個簽名，如果明文任意字符修改，簽名就會天差地別(MD5特性) 驗簽: 確定 明文與簽名是否對應(明文是否被篡改)  NAT穿透  Network Address Translation Traversal
  內部IP就是192.168.X.X開頭的那些，穿透技術就是讓外部可以透過公有IP訪問到你的內部IP 原理就是透過各種網路服務供應商幫你搭橋 使用場景:  開發測試，取得暫時的對外域名讓外部可以訪問本機 智慧家電連網，例如出門在外用手機網路可以看家裡監控那種 遠程控制，遠端桌面   以前玩Minecraft架server有用過類似的東西  支付沙盒  大部分的電子支付API都有提供一個sandbox做測試開發用  LinePay的 https://pay.line.me/jp/developers/techsupport/sandbox/creation?locale=zh_TW   但是這個申請都要有店家資格，不好弄  我研究了一下這個EcPAY的 https://www.ecpay.com.tw/Service/API_Dwnld   大致使用流程就是申請帳號，然後下載支付網站提供的API與SDK，包到自己的專案之下，填上各種授權key，串接付款與跳轉的頁面這樣  支付串接流程  PayWebController.java  這邊接收前端來的訂單號@RequestParam(&amp;quot;orderSn&amp;quot;)，用訂單號去查詢訂單內容，然後帶著訂單內容往支付的API    @GetMapping(value = &amp;#34;/payOrder&amp;#34;, produces = &amp;#34;text/html&amp;#34;) public String payOrder(@RequestParam(&amp;#34;orderSn&amp;#34;) String orderSn) throws AlipayApiException {  	PayVo payVo = orderService.</description>
    </item>
    
    <item>
      <title>Seata、消息隊列分佈式事務</title>
      <link>https://yoziming.github.io/post/220207-gulimall-21-delay-queue/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220207-gulimall-21-delay-queue/</guid>
      <description>Spring cloud alibaba Seata  有很多模式，這邊只演示最簡單的AT模式 簡單來說就是多包一層，額外開一個伺服器去監控多個分佈式模組，誰出問題就讓大家都回滾    使用@GlobalTransactional就可以達成分佈式事務
  利用的機制是在DB增加一個undo_log表，這個表相當於存快照的地方，當要回滾就從這邊還原
 AT模式簡單，代價就是面對併發效率不高    這玩意才幾個版本設定就變好多次，具體使用還是看官網吧
 https://seata.io/zh-cn/docs/ops/deploy-guide-beginner.html    延遲隊列  Delay Queue，使用 消息隊列 + 庫存工作單表 來控制分佈式事務
  下訂單後，要鎖定庫存，這是個分佈式事務，需要保證鎖定的庫存能回滾，首先在DB使用兩張表 wms_ware_order_task 庫存工作單表，訂單、工作單id、倉庫id wms_ware_order_task_detail 庫存工作單詳情表，訂單、工作單id、倉庫id、skuId、鎖庫存數量 鎖庫存的時候往工作單表、工作單詳情表插入數據  創建隊列與交換機  在RabbitMQ
  創建訂單時，遠程調用orderLockStock創建了庫存工作單，並且鎖定庫存  那邊發了&amp;quot;stock-event-exchange&amp;quot;, &amp;quot;stock.locked&amp;quot;, lockedTo，lockedTo裡面就是庫存工作單id   當遠程調用創建庫存工作單成功，本地也發一個&amp;quot;order-event-exchange&amp;quot;, &amp;quot;order.create.order&amp;quot;，裡面存的是訂單本體   改良，省下一個交換機，帶有&amp;quot;order.create.order&amp;quot;路由鍵的訂單會進到order.delay.queue這個延遲隊列，而這個隊列還是指向order-event-exchange交換機 但是他設有過期時間，當時間到了就把路由鍵換成order.release.order 也就是說，所有的訂單最終都會進到order.release.order.queue，並且被listener消費，這個listener會調用closeOrder方法 closeOrder方法查看訂單是否已經支付，若已支付就完事，訂單可以安心離開隊列。若沒支付就查詢訂單最新狀態，再發到&amp;quot;order-event-exchange&amp;quot;, &amp;quot;order.release.other.unlock&amp;quot;, order 這個&amp;quot;order.release.other.unlock&amp;quot;路由鍵就會把訂單送到stock.release.stock.queue，嘗試進行庫存解鎖的動作   之前學了用AmqpAdmin創建交換機與隊列的方法，有更省事的可以直接用@Bean讓spring自動創建  Broker中沒有該名字的隊列、交換機才會創建 不會重複創建覆蓋(一旦創好，不能更新)，如果同名的隊列其中設定(例如過期時間)對不上會報錯 第一次使用隊列的時候才會創建   MyMQConfig.</description>
    </item>
    
    <item>
      <title>阿里巴巴Java開發手冊</title>
      <link>https://yoziming.github.io/post/220207-alibaba-java-guide/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220207-alibaba-java-guide/</guid>
      <description>阿里巴巴Java開發手冊  學sentinel時翻了一下alibaba的github，按照star排序第2名是個p3c，好奇點進去看原來是一份Java Coding Guidelines
  官方: https://github.com/alibaba/p3c 線上電子書: https://www.cntofu.com/book/78/index.html 他甚至有一個用來檢查的IDEA插件，厲害  個人知識重點  已經掌握的知識就不記了，以下都是我以前犯過的錯誤或是不懂原理的地方
   【強制】類名使用UpperCamelCase風格，但以下情形例外：DO / BO / DTO / VO / AO / PO等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion
  【強制】杜絕完全不規範的縮寫，避免望文不知義。 反例：AbstractClass“縮寫”命名成AbsClass；condition“縮寫”命名成 condi，此類隨意縮寫嚴重降低了代碼的可閲讀性。
  【強制】POJO類中布爾類型的變量，都不要加is前綴，否則部分框架解析會引起序列化錯誤。 反例：定義為基本數據類型Boolean isDeleted；的屬性，它的方法也是isDeleted()，RPC框架在反向解析的時候，“誤以為”對應的屬性名稱是deleted，導致屬性獲取不到，進而拋出異常。
  【強制】long或者Long初始賦值時，使用大寫的L，不能是小寫的l，小寫容易跟數字1混淆，造成誤解。
  【強制】不允許任何魔法值（即未經預先定義的常量）直接出現在代碼中。
  【強制】避免通過一個類的對象引用訪問此類的靜態變量或靜態方法，無謂增加編譯器解析成本，直接用類名來訪問即可。
  【強制】Object的equals方法容易拋空指針異常，應使用常量或確定有值的對象來調用equals。 正例：&amp;ldquo;test&amp;rdquo;.equals(object);
  【強制】所有的相同類型的包裝類對象之間值的比較，全部使用equals方法比較。 説明：對於Integer var = ? 在-128至127範圍內的賦值，Integer對象是在IntegerCache.cache產生，會複用已有對象，這個區間內的Integer值可以直接使用==進行判斷，但是這個區間之外的所有數據，都會在堆上產生，並不會複用已有對象，這是一個大坑，推薦使用equals方法進行判斷。</description>
    </item>
    
    <item>
      <title>提交訂單: 冪等性、分散式交易的一致性</title>
      <link>https://yoziming.github.io/post/220206-gulimall-20-idempotent/</link>
      <pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220206-gulimall-20-idempotent/</guid>
      <description>冪等性  idempotent
  多次提交，結果不變，常見有這些辦法:  Token  令牌或驗證碼 伺服器存儲了一個令牌，然後頁面要帶上這個令牌比較，一樣才可以提交  提交後刪除掉token，再次點擊提交就會失敗 但是F5刷新的話就不一樣了，會有新的token產生   注意: 獲取redis令牌 + 令牌匹配 + redis刪除，全程要保證原子性，使用lua腳本  鎖 數據庫悲觀鎖  Pessimistic Lock
  就是排他鎖，所謂悲觀在於覺得總有刁民想亂搞我的data，所以自己拿到鎖就把data藏到大衣裡，完全不給其他人用，連看都不給看 當一個SQL command獲得悲觀鎖後，其他的SQL command 無法讀取無法修改，直到悲觀鎖被釋放後才能執行，例如:  select* from xxx where id = 1 for update;  悲觀鎖使用時一般伴隨事務一起使用，數據鎖定時間可能會很長，需要根據實際情況選用 另外要注意的是，id字段一定是主鍵或者唯一索引，不然可能造成鎖表的結果，處理起來會非常麻煩 資料庫中的行鎖，表鎖，讀鎖，寫鎖，以及syncronized實現的鎖均為悲觀鎖  數據庫樂觀鎖  Optimistic Lock
  允許多個 SQL command 來操作 table，但是要帶上版本號 當 SQL command 想要變更欄位 data 時會先把之前取出 version 跟 table 現在的 version 做對比，如果相同就代表這段期間沒人修改可以執行；如果不同就會禁止這次的操作 這種方法適合在更新的場景中，例如:  update t_goods set count = count-1,version =version + 1 where good_id=2 and version = 1  樂觀鎖主要使用於處理讀多寫少的場景  分佈式鎖  不管多少服務，限制同時都只有一人能操作 參考之前的筆記: https://yoziming.</description>
    </item>
    
    <item>
      <title>生活雜記</title>
      <link>https://yoziming.github.io/post/220206-eu-name/</link>
      <pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220206-eu-name/</guid>
      <description>夢中的婚禮  事情是這樣，我國小音樂老師(我竟然還記得她的全名，姓許)很常在上下課間隙彈&amp;quot;夢中的婚禮&amp;quot;  Richard Clayderman - Mariage d&amp;rsquo;amour (夢中的婚禮) https://www.youtube.com/watch?v=QLHHfrL_eJk   這首優美的鋼琴曲相信大家都有聽過，我本來以為它是類似卡農之類流傳很久的經典曲目，直到前陣子才了知道原來作者是現代人，並且還活著! 作者理查 克萊德門被稱為&amp;quot;鋼琴王子&amp;quot;，還來過台灣錄節目(張菲的龍兄虎弟，也是年代久遠)、開音樂會 那我就在想，該簡稱他為理查呢? 還是克萊德門? 總有先例可循吧，於是我搜尋巴哈、貝多芬、蕭邦、莫札特&amp;hellip;等等，才驚覺原來這些都是家族的姓，難道這是音樂家的傳統?  歐洲人的姓與名  原來歐洲在中世紀的時候，名只能在教廷規定的&amp;quot;教名&amp;quot;中選(例如Peter)，而姓才是能自己決定的 所以造成他們重複的是名，而姓卻是千變萬化(跟中國剛好相反)，例如目前德國人最多的姓是Müller，也才佔不到1%。而那些少見的姓Mozart、Beethoven幾乎就只有他們那一家 街上喊Adolf可能有好幾人回頭看你，但是喊Hitler大家就知道是在說誰，所以用姓來稱呼才是有效率的區分方法 至於同姓就要用其他修飾詞來區分，例如地區；真的同家族的就會用XXX的兒子、小、老之類，想被記住就要成為家族中最厲害的那個，也難怪那些電影或小說動不動就為了家族的榮耀之類的 在正式寫作中也是要稱呼姓才有禮貌，這點倒是跟華人一樣  其他當代音樂家   我個人特別喜歡的，附上他們的經典曲
  馬克西姆 - 克羅迪亞狂想曲
 Maksim - Croatian Rhapsody https://youtu.be/3aTEjyzWKFQ    久石讓 - 菊次郎的夏天
 Joe Hisaishi - Summer https://youtu.be/l0GN40EL1VU    </description>
    </item>
    
    <item>
      <title>LeetCode Easy: 35-58</title>
      <link>https://yoziming.github.io/post/220205-leetcode-easy-35/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220205-leetcode-easy-35/</guid>
      <description>\35. Search Insert Position  二分查找  核心思路是&amp;quot;下一輪的搜索區間&amp;quot; 然後逐步縮小區間    public int searchInsert(int[] nums, int target) {  // 右邊界最大的數有可能就是答案(最衰的情況下)，他的index就是長度  int len = nums.length, left = 0, right = len;  // 開始迫近  while (left &amp;lt; right) {  // 每輪都重新定義中間數，注意小數點會被捨去  int mid = left + (right - left) / 2;  // 如果目標更大  if (nums[mid] &amp;lt; target) {  // 成為新的左標，下一輪搜尋[mid + 1...right]  left = mid + 1; // 因為小數點會被捨去，所以這邊+1  } else {  // 成為新的右標，下一輪搜尋[left.</description>
    </item>
    
    <item>
      <title>整理常用的git操作</title>
      <link>https://yoziming.github.io/post/220205-git-common-use/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220205-git-common-use/</guid>
      <description>整理常用的git操作  這東西沒在用的時候硬學也記不住，用到的時候又總是順序不太對，這樣那樣的報錯，乾脆寫一篇筆記統一整理一下 首先git是以&amp;quot;資料夾&amp;quot;為單位進行版本控制(了解後感覺理所當然，但我一開始沒弄明白這點只會複製貼上教學的指令，就一直懵懵懂懂的) 我們幹的事是把&amp;quot;本地這個資料夾&amp;quot;連結到github上的遠端倉庫，針對某個分支進行某些操作  常用的git操作  所謂&amp;lt;倉庫網址&amp;gt;就是在github網站某倉庫，點右上角綠色的code顯示的那串，例如  https://github.com/yoziming/javamall.git
 下載遠端倉庫到本地，會得到一個資料夾  git clone https://github.com/yoziming/javamall.git  本地連到遠端倉庫  用於本地已經建了一個資料夾的狀況 origin是用來操作的別名，因為如果是載下來的倉庫預設就叫origin    git remote add origin &amp;lt;倉庫網址&amp;gt;  查看當前資料夾控制的遠端  git remote -v  切換分支(需要該分支確實存在)  git checkout &amp;lt;分支&amp;gt;  建立新的 branch 並切到新的 branch  git checkout -b &amp;lt;新分支名稱&amp;gt;  添加全部檔案  git add .  加上註解  使用git commit -e添加多行    git commit -m &amp;#34;一行註解&amp;#34;  推送到遠端  origin是別名    git push -u origin &amp;lt;分支名&amp;gt;  修改連線的倉庫網址  git remote set-url origin https://github.</description>
    </item>
    
    <item>
      <title>確認訂單、feign請求頭問題</title>
      <link>https://yoziming.github.io/post/220205-gulimall-19/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220205-gulimall-19/</guid>
      <description>商城訂單模組  訂單通常是最複雜的模組之一
  涉及三流:  信息流：商品信息、優惠信息 資金流：退款、付款 物流：發送、退貨    訂單流程  訂單流程是指從訂單產生到完成的過程
   不同的產品類型或業務類型在系統中的流程會千差萬別，比如線上實物訂單和虛擬訂單與o20訂單等，所以需要根據不同的類型進行構建訂單流程
  不管類型如何訂單都包括正向流程和逆向流程，對應的場景就是購買商品和退換貨流程，正向流程就是一個正常的網購步驟
 訂單生成-&amp;gt; 支付訂單-&amp;gt; 賣家發貨-&amp;gt; 確認收貨-&amp;gt; 交易成功    而每個步驟的背後，訂單是如何在多系統之間交互流轉的，可概括如下圖
  正向流程  訂單創建前需要預覽訂單，選擇收貨信息等 訂單創建需要鎖定庫存，庫存有才可創建，否則不能創建 訂單創建後超時未支付需要解鎖庫存 支付成功後，需要進行拆單，根據商品打包方式，所在倉庫，物流等進行拆單 支付的每筆流水都需要記錄，以待查賬 訂單創建，支付成功等狀態都需要給MQ發送消息，方便其他系統感知訂閲  逆向流程  修改訂單，用户沒有提交訂單，可以對訂單一些信息進行修改，比如配送信息， 優惠信息，及其他一些訂單可修改範圍的內容，此時只需對數據進行變更即可。 訂單取消，用户主動取消訂單和用户超時未支付，兩種情況下訂單都會取消訂單，而超時情況是系統自動關閉訂單，所以在訂單支付的響應機制上面要做支付的  訂單狀態  待付款: 用户提交訂單後，訂單進行預下單，目前主流電商網站都會便於用户快速完成支付，需要注意的是待付款狀態下可以對庫存進行鎖定，鎖定庫存需要配置支付超時時間，超時後將自動取消訂單，訂單變更為關閉狀態 已付款/待發貨: 用户完成訂單支付，訂單系統需要記錄支付時間，支付流水單號便於對賬，訂單下放到WMS系統，倉庫進行調撥，配貨，分揀，出庫等操作 待收貨/已發貨: 倉儲將商品出庫後，訂單進入物流環節，訂單系統需要同步物流信息，便於用户實時知悉物品物流狀態 已完成: 用户確認收貨後，訂單交易完成。後續支付側進行結算，如果訂單存在問題進入售後狀態 已取消: 付款之前取消訂單。包括超時未付款或用户商户取消訂單都會產生這種訂單狀態 售後中: 用户在付款後申請退款，或商家發貨後用户申請退換貨。售後也同樣存在各種狀態，當發起售後申請後生成售後訂單，售後訂單狀態為待審核，等待商家審核，商家審核通過後訂單狀態變更為待退貨，等待用户將商品寄回，商家收貨後訂單狀態更新為待退款狀態，退款到用户原賬户後訂單狀態更新為售後成功  前端頁面 等待付款，詳情頁：
訂單頁：
收銀頁：
整理各種POJO與規範  feign包放在common模組下，用TO(Transfer Object)來跨模組接收、傳遞物件 VO(View Object) 是專門返回給前端、給人看的東西 Entity實體，也稱為PO(Persistant Object)，屬性基本和資料表欄位一一對應。一個實體即是真實存在的一筆資料，必須要有唯一標識(例如id)以區分其它實體 DAO(Data Access Object)封裝了PO在資料庫的CRUD等操作  實作 登入攔截  點結算時，沒登入就讓用戶先去登入</description>
    </item>
    
    <item>
      <title>RabbitMQ與訊息確認</title>
      <link>https://yoziming.github.io/post/220204-gulimall-18-rabbitmq/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220204-gulimall-18-rabbitmq/</guid>
      <description>Message Queue  Message queue 訊息佇列
  佇列（queue），又稱為隊列，特性是先進先出(FIFO) 訊息佇列是一個中間件，又是經典的&amp;quot;加一層&amp;quot;操作，抽出一個專門存放溝通訊息的地方，就是訊息佇列  可以理解成去銀行辦事，那個領號碼牌的機器   市面上常見的MQ: ActiveMQ、RabbitMQ、RocketMQ、Kafka  目的  縮短調用時間: 透過序列分發後續的異步調用，不需要一步一步往下走等返回  就像去醫院，醫生開了檢查要你去抽血跟照X光，哪邊方便就先去做，總之檢查單開了醫生就不管了，你總會去做完檢查     解耦: 模組間溝通用訂閱佇列的形式，只需要關注收發訊息，減少業務邏輯的侵入  比如到了抽血站，拿檢驗單去掃機器就能完成抽血報名，不需要醫生打電話告知抽血站誰要抽什麼血     削峰: 流量控制，錯開高併發，依順序處理  隊列是有序、可控制流量的，不會突然1000人擠爆抽血站    名詞   消息代理（message broker）: 安裝了消息中間件的伺服器，發送消息和接收消息都要連上它
 冒險者公會的任務看板    目的地（destination）: 目的地表示生產者發送消息給消息代理之後，是存儲到消息代理中哪一個具體的目的地（隊列或主題）
  隊列（queue）：點對點通信，1個發送者，n個接受者，但一個信息只會被一個接受者消費（消費後移出隊列）
 理解為拋繡球    主題（topic）：發佈/訂閲，多個發送者+多個訂閲者。多個訂閲者會同時接收到
 廣播      JMS (Java Message Service): 基於JAVA API定義的標準介面</description>
    </item>
    
    <item>
      <title>cookie&amp;redis實現訪客購物車</title>
      <link>https://yoziming.github.io/post/220203-gulimall-17-offline-cart/</link>
      <pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220203-gulimall-17-offline-cart/</guid>
      <description>購物車需求分析 訪客購物車  沒登入也能放地購物車，是我才不搞那麼多，沒登入就讓用戶登一下不就好了，唉當練習吧
意外的是這個項目是仿京東，結果京東現在也不提供這種功能了，一律先登入再說
   可以把資料暫存在客戶端，例如:
 localstorage cookie WebSQL    但何種商品被放到購物車本身是一個有價值的資訊，所以選擇放到伺服端的redis
  用户購物車  一樣採用redis，優勢在於  極高的讀寫併發性能 好組織數據結構 redis也有持久化策略，AOF   登入後會將離線購物車合併  操作分析  增（添加商品到購物車） 刪（刪除某個商品） 改（修改商品數量） 查（查詢購物車中的商品）  商品是否被選中，下次進來還是選中狀態 用户可以使用購物車多件商品一起結算下單 在購物車中展示商品優惠信息 提示購物車商品價格變化    資料庫設計  Redis數據結構用Hash，造一個雙層Map來存  Map&amp;lt;String, Map&amp;lt;String, String&amp;gt;&amp;gt;  第一個key是用户id，value是購物車信息 第二個key是skuId，value是購物項數據  Vo設計  類似之前做的書城項目
  CartVo是完整的一台車，這邊有CartItemVo構成的List、總件數、總價 CartItemVo略等同於Sku，就是車中的某項商品，加上件數與價格   在CartVo.java 將計算總價等等方法封裝起來  public BigDecimal getTotalAmount() {  BigDecimal amount = new BigDecimal(&amp;#34;0&amp;#34;);  // 計算購物項總價  if (!</description>
    </item>
    
    <item>
      <title>LeetCode Easy: 26-28</title>
      <link>https://yoziming.github.io/post/220203-leetcode-easy-26-28/</link>
      <pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220203-leetcode-easy-26-28/</guid>
      <description>\26. Remove Duplicates from Sorted Array  數組去重
  想對數組做啥，都可以考慮雙指針  public int removeDuplicates(int[] nums) {  // 起始第一個指針從頭開始  int p = 0;  // 第二個指針，從p+1開始  for (int q = 1; q &amp;lt; nums.length; ) {  // 如果不一樣  if (nums[p] != nums[q]) {  // 就把q往前搬，讓不一樣的數緊貼著第一個指針  nums[p + 1] = nums[q];  // 並且讓第一個指針P移往下一步  p++;  }  // 如果數字一樣表示要被忽略，q往後移，直到找到不同的數字  q++;  }  //  return p + 1; } \27.</description>
    </item>
    
    <item>
      <title>個人對區塊鏈的白話理解</title>
      <link>https://yoziming.github.io/post/220203-bitcoin/</link>
      <pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220203-bitcoin/</guid>
      <description>區塊鏈  雖然沒投資，並且我也覺得區塊鏈、NFT等等基本都是炒作，但背後的原理還是非常有意思的
  區塊鏈就像有一本公有記帳本，比如今天一筆交易是&amp;quot;小明給小花5元&amp;quot;，既然是公有記帳本，這筆交易由誰來記帳? 透過網路與程式，把&amp;quot;小明給小花5元&amp;quot;這個內容經密碼學轉換成數學題，這個數學題就是單純的猜數字，很簡單但是很耗時，解題只能靠窮舉 誰窮舉猜到了答案就可以記帳，並且有手續費獎勵，這個過程稱為工作量證明 PoW  鏈   而區塊鏈叫做&amp;quot;鏈&amp;quot;就是因為一環套一環，帳本要基於上次的結果往下寫
  例如下一筆交易發生時，題目就是&amp;quot;小明給小花5元+小強給張三10元&amp;quot;
  再出數學題&amp;hellip;再窮舉&amp;hellip;再下一筆交易
  可靠性  為何不用擔心公有記帳本被人竄改?  因為除非你能與世界為敵，瞬間算出一條更長的鏈(所謂的51%攻擊)   比如現在已經來到第三筆交易&amp;quot;小明給小花5元+小強給張三10元+小華&amp;hellip;&amp;quot; 你想竄改紀錄成&amp;quot;小明給小花500元+小強給張三..&amp;ldquo;得超越全世界的算力，瞬間算完三題難題並拼接成鍊，因為世界上隨時都有人在算題，所以基本上不可能。故一旦帳本紀錄確定，就沒人能更改  巧妙之處  區塊鏈巧妙在於人們為了自己利益(挖礦的手續費)就會天然保證帳簿的可靠性，形成一個自洽的循環 當自利對整體最有利，有人想作惡還必須能敵過全世界的算力，一個成功去中心化記帳方式就誕生了  浪費資源  挖礦本身的窮舉確實純粹是為算而算，但又不能說他無意義，因為正是計算很浪費資源才能保證帳簿不被竄改 如果說開燈照明=浪費電，在現代可能沒人同意，但回到電燈剛被發明的年代，那時候的人可能覺得我燒蠟燭才多少錢，開電燈多浪費阿、又貴又不討好 所以終究是環境決定一切，比特幣的發明者中本聰始終為謎，可能也有這顧忌吧，只能希望哪天核融合發電商用成功了，在我有生之年不知是否能見到  權益證明機制PoS  工作量證明的缺點很明顯，交易慢(比特幣一秒只能紀錄7筆交易，ETH30筆)、浪費電 所以就有人提出PoS，簡單說就是決定誰來寫帳本的時候，咱們不要算題目了，換成隨機指派，但是每個人可以決定要質押多少錢，當要驗證(提交鏈)的時候，質押多的人就越有機會被選中 類似股權機制，持股越多分紅越多，並且系統中權益越多的人就是越在乎安全性的人(我在這邊投了錢，我當然要保證系統安全可靠)，以此達成自洽 但是這玩意又跟去中心化的理念相違背，PoS鼓勵的是囤錢，並且如果產生了超級財閥，那他又可能為所欲為。所以目前主流都是POW與POS混用  </description>
    </item>
    
    <item>
      <title>註冊、登入與Spring Session</title>
      <link>https://yoziming.github.io/post/220202-gulimall-16-spring-session/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220202-gulimall-16-spring-session/</guid>
      <description>WebMvcConfigurer  參考 https://blog.csdn.net/pan_junbiao/article/details/120039885
  複習SpringMVC WebMvcConfigurer是一個接口，用JavaBean的方式代替web.xml，常用於: 攔截器，例如:  @Override public void addInterceptors(InterceptorRegistry registry) {  super.addInterceptors(registry);  registry.addInterceptor(new TestInterceptor()).addPathPatterns(&amp;#34;/**&amp;#34;).excludePathPatterns(&amp;#34;/emp/toLogin&amp;#34;,&amp;#34;/emp/login&amp;#34;,&amp;#34;/js/**&amp;#34;,&amp;#34;/css/**&amp;#34;,&amp;#34;/images/**&amp;#34;); }  跨域設定，例如:  // 跨域 @Override public void addCorsMappings(CorsRegistry registry) {  registry.addMapping(&amp;#34;/**&amp;#34;)  .allowedOrigins(&amp;#34;*&amp;#34;) //浏览器允许所有的域访问 / 注意 * 不能满足带有cookie的访问,Origin 必须是全匹配  .allowCredentials(true) // 允许带cookie访问  .allowedMethods(&amp;#34;GET&amp;#34;, &amp;#34;POST&amp;#34;, &amp;#34;PUT&amp;#34;, &amp;#34;DELETE&amp;#34;, &amp;#34;OPTIONS&amp;#34;)  .allowedHeaders(&amp;#34;token&amp;#34;)  .maxAge(3600); }  更多關於跨域，參考 https://segmentfault.com/a/1190000019485883
  映射html頁面  前後綴一樣由thymeleaf加上    @Configuration public class MallWebConfig implements WebMvcConfigurer {   // View映射，省下造controller一個一個設定  @Override  public void addViewControllers(ViewControllerRegistry registry) {  registry.</description>
    </item>
    
    <item>
      <title>商品詳情</title>
      <link>https://yoziming.github.io/post/220201-gulimall-15/</link>
      <pubDate>Tue, 01 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220201-gulimall-15/</guid>
      <description>商品詳情 View  商品詳情也是子網域，設定網關:   nginx就不用改了，因為之前設的規則是*.mall.com 導入頁面item.html與靜態資源 前端頁面一樣用thymeleaf渲染 thymeleaf中動態網址的寫法，用|包住網址前後，中間${參數}  &amp;lt;a th:href=&amp;#34;|http://item.mall.com/${product.skuId}.html|&amp;#34;&amp;gt;  格式化數字，前面3是整數位，2是小數位  &amp;lt;span th:text=&amp;#34;${#numbers.formatDecimal(item.info.price,3,2)}&amp;#34;&amp;gt;  sku組合切換，太偏前端了，有用到再來學   https://www.bilibili.com/video/BV1np4y1C7Yf?p=208&amp;amp;spm_id_from=pageDriver
  另外我發現thymeleaf是不是有病，一般的HTML註解&amp;lt;!--他竟然還是會解析，不顯示但是會解析 可以參考 https://blog.csdn.net/sun_jy2011/article/details/40299821 比如一塊代碼有問想先註解掉，整塊用快捷鍵選起來ctrl+/先註解掉還不行，他就是硬要解析，如果有BUG就會一直讀出BUG，真的是有病耶，這樣設計是腦子被門夾到嗎。一定要用下面這樣的格式包起來的才不會解析  &amp;lt;!--/*--&amp;gt; xxxx OOOO &amp;lt;!--*/--&amp;gt; Controller  ItemController.java  我才搞懂return &amp;quot;item&amp;quot;是因為前面說的thymeleaf自動會加上前後綴，就相當於templates/item.html    @GetMapping(&amp;#34;/{skuId}.html&amp;#34;) public String skuItem(@PathVariable(&amp;#34;skuId&amp;#34;) Long skuId, Model model) throws ExecutionException,  InterruptedException {  System.out.println(&amp;#34;準備查詢&amp;#34; + skuId + &amp;#34;詳情&amp;#34;);    SkuItemVo vos = skuInfoService.item(skuId);  model.</description>
    </item>
    
    <item>
      <title>線程池與CompletableFuture異步編排</title>
      <link>https://yoziming.github.io/post/220131-gulimall-14-thread/</link>
      <pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220131-gulimall-14-thread/</guid>
      <description>多線程 初始化線程的4種方式  繼承 Thread 實現 Runnable接口 實現 Callable接口 + FutureTask（可以拿到返回結果，可以處理異常） 線程池   複習 https://yoziming.github.io/post/211204-agg-ja-19/
 區別  1、2不能得到返回值。3可以獲取返回值 1、2、3都不能控制資源 4可以控制資源，性能穩定，不會一下子所有線程一起運行 實際開發中，只用線程池，因為高併發狀態開啓了n個線程，會直接耗盡資源  線程池的優勢  降低資源的消耗: 省得在那創了又刪，刪了又創 提高響應速度: 已經在池子那等了，來活就幹 提高線程的可管理性: 例如系統中可以創建兩個線程池，核心線程池、非核心線程池，有需要時可以關閉非核心線程池釋放記憶體資源  就像公司分兩部門，壓力大就把非核心的部門關了    手動創建線程池  可以new ThreadPoolExecutor(參數)手動創建線程池，七大參數:  // ThreadPoolExecutor.java 原始碼 corePoolSize – the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set maximumPoolSize – the maximum number of threads to allow in the pool keepAliveTime – when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</description>
    </item>
    
    <item>
      <title>用ElasticSearch實現商品搜索</title>
      <link>https://yoziming.github.io/post/220130-gulimall-13/</link>
      <pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220130-gulimall-13/</guid>
      <description>搜索頁面   搜尋頁面有自己的子網域，網址是 http://search.mall.com/
  我觀察了一下，台灣的商城網站大多是用子目錄，例如:
  https://www.momoshop.com.tw/search/ https://www.etmall.com.tw/Search? https://shopping.friday.tw/ec2/search?   而用子網域的通常是大陸的電商網站，經過查詢兩者其實沒太大差異
  通常來說，屬於網站下的附屬小功能，用子目錄；而體量大到可以分割出去才用會用子網域
  子網域複雜了一點，反正都學學吧
  設定網段  改host模擬DNS   nginx  採了坑，改完忘記要重開服務     網關  - id: mall_search_route uri: lb://search predicates: - Host=search.mall.com 靜態資源  這邊一樣用thymeleaf渲染，引包 關閉 spring.thymeleaf.cache=false 調整 list.html，確認一下跟首頁的超連結是否正確  寫Vo  這可就複雜了，需要考慮各種搜尋條件、返回的結果&amp;hellip;
  搜尋條件 SearchParam.java  @Data public class SearchParam {   /** * 頁面傳遞過來的全文匹配關鍵字 */  private String keyword;   /** * 品牌id,可以多選 */  private List&amp;lt;Long&amp;gt; brandId;   /** * 三級分類id */  private Long catalog3Id;   /** * 排序條件：sort=price/salecount/hotscore_desc/asc */  private String sort;   /** * 是否有貨 */  private Integer hasStock;   /** * 價格區間查詢 */  private String skuPrice;   /** * 按照屬性進行篩選 */  private List&amp;lt;String&amp;gt; attrs;   /** * 頁碼 */  private Integer pageNum = 1;   /** * 原生的所有查詢條件 */  private String _queryString;  }  返回的結果 SearchResult.</description>
    </item>
    
    <item>
      <title>Redisson與SpringCache</title>
      <link>https://yoziming.github.io/post/220129-gulimall-12-redisson/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220129-gulimall-12-redisson/</guid>
      <description>Redisson   Java操作Redis的框架，主要用他的分布式鎖的功能
  加鎖的方法與邏輯幾乎都跟java.util.concurrent包下的一樣
 JUC包: ReentrantLock那些，如果沒印象了看下面個種鎖的範例就會回想起來    前置設定  https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95
  引包  &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;3.16.8&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  造config類  注意import org.redisson.config.Config    @Configuration public class RedissonConfig {  /** * 所有對Redisson的使用都是通過RedissonClient * * @return * @throws IOException */  @Bean(destroyMethod = &amp;#34;shutdown&amp;#34;)  public RedissonClient redisson() throws IOException {  // 創建配置  Config config = new Config();  config.</description>
    </item>
    
    <item>
      <title>Redis緩存與分佈式鎖</title>
      <link>https://yoziming.github.io/post/220128-gulimall-11-synchronized-lock/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220128-gulimall-11-synchronized-lock/</guid>
      <description>緩存  誰適合進緩存?  讀多寫少 即時性、一致性要求不高的   例如: 物流資訊、排行榜  實現   請求來了，緩存中是否已有資料?
 無，去DB拿一份給他，並且存到緩存中 有，直接從緩存拿給他    本地緩存: 最簡單實現就是寫一個Map，把東西存裡面。然而在分布式會有問題
 負載均衡: 每次輪到可能每個分散的機站都要去DB取一份資料 資料一致性: 某處更新了，其他處已經緩存中的不會更新    於是就會用到Redis這種noSQL
  Spring Redis  引包: spring-boot-starter-data-redis application.properties設定端口與密碼(如果有)  spring.redis.host=localhost spring.redis.port=6379  造一個StringRedisTemplate 用.opsForXXX()方法造出操作子，XXX是要存的value類型 拿造出的操作子開始set、get  @Autowired StringRedisTemplate stringRedisTemplate;  @Test void test1() {  ValueOperations&amp;lt;String, String&amp;gt; ops = stringRedisTemplate.opsForValue();  ops.set(&amp;#34;hello&amp;#34;, &amp;#34;world_&amp;#34; + UUID.randomUUID());  System.out.println(&amp;#34;ops.get(\&amp;#34;hello\&amp;#34;) = &amp;#34; + ops.</description>
    </item>
    
    <item>
      <title>Nginx&amp;網關、壓測與性能優化</title>
      <link>https://yoziming.github.io/post/220127-gulimall-10-stress-testing/</link>
      <pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220127-gulimall-10-stress-testing/</guid>
      <description>Nginx反向代理  正向代理，例如Proxy、VPN，我透過它去訪問別人。例如我暗戀班上正妹但不敢講，拜託正妹的閨密轉交情書，正妹只知道情書來自閨密轉交但不知道是誰送的(除非閨密把我賣了)  閨密對我而言就是正向代理(前向代理)   反向代理，例如某殺手組織內有多個專業殺手，跟一個對外的業務窗口。當委託人想下任務只能找到窗口，而組織內的任務實際由哪位殺手完成外人無從得知。委託人最終只知道任務的結果  窗口對於殺手組織而言就是反向代理   目的: 負載均衡、安全(對外只暴露一個IP，內部伺服器真實網址別人不知道)  模擬部署  首先docker拉一個nginx，並且把設定檔文件夾掛載出來，方便修改  乍看有點混亂，nginx.conf是主配置檔 而conf.d是子資料夾，裡面可以放多個xxx.conf，為從配置 第三個掛載是為了放html靜態資源 最後一個是log    docker run -p 80:80 --name nginx -v /mydata/nginx/nginx.conf:/etc/nginx/nginx.conf -v /mydata/nginx/conf.d:/etc/nginx/conf.d -v /mydata/nginx/html:/usr/share/nginx/html -v /mydata/nginx/logs:/var/log/nginx -d nginx  為了模擬DNS的效果，用SwitchHosts修改本機  SwitchHosts: https://github.com/oldj/SwitchHosts/releases     進到虛擬機，修改nginx轉發的規則，讓它指向本機IP   把服務都開起來，有點樣子了  其實目前只是繞一圈回來，接著再來設定網關    結合網關  大的HTTP  使用nginx注意{}閉合與結尾的;     小的Server  通過nginx的時候，會把請求頭裡面很多訊息都削掉 所以這邊要手動把頭加回去，否則下面的網關沒辦法靠Host=XX來辨識斷言 把檔案名稱保存為mall.</description>
    </item>
    
    <item>
      <title>JVM模型與GC策略</title>
      <link>https://yoziming.github.io/post/220126-jvm-gc/</link>
      <pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220126-jvm-gc/</guid>
      <description>JVM記憶體模型 GC  Garbage Collection 垃圾回收是影響程式效能的重中之重
 誰是垃圾?  Reachability Analysis 可達性分析: 把所有引用的物件看成一棵樹，從樹的根結點 GC Roots 出發，持續遍歷找出所有連接的樹枝物件，能連到的就是&amp;quot;可達&amp;quot;的存活物件 沒有任何引用相連的就是垃圾 在Java中GC Roots包括:  虛擬機棧中引用的物件 方法區中類靜態屬性實體引用的物件 方法區中常量引用的物件 本地方法棧中JNI引用的物件    引用的擴充  自 JDK 1.2 以後，Java 對引用的概念進行了擴充
  String Reference 強引用：類似 &amp;ldquo;Object obj = new Object()&amp;rdquo; 屬於強引用，只有引用還在，垃圾收集器永遠不會回收掉被引用對象 Soft Reference 軟引用：用來描述一些還有用但不是必須的物件。對於軟引用相關的物件，在系統將要發生 OOM（記憶體溢出）時，將會把軟引用對象列進回收範圍並進行二次回收。如果這次回收後還是沒有足夠記憶體才會拋出 OOM 異常 Weak Reference 弱引用：也是用來描述非必須物件，但它的強度比軟引用更弱，被弱引用的對象只會生存到下一次垃圾回收之前。當進行 GC 時，無論當前記憶體是否足夠，都會回收掉弱引用的物件 Phantom Reference 虛引用：又稱幽靈引用或幻影引用，最弱的引用關係。無法通過虛引用獲取物件的實例，為物件設置虛引用唯一的目的就是能在該物件被垃圾收集器回收時收到一個系統通知  清理機制  GC發生在堆HEAP上
  新物件創在Eden區，放不下就MinorGC小清理  MinorGC小清理把Eden區中能搬的搬到隔壁Survivor倖存者區   Eden區清了還是放不下，就對倖存者區也MinorGC，嘗試放到倖存者區  每次MinorGC倖存者區中的物件就變老，待在倖存者區太久超過域值，就趕去老年區養老   倖存者區還是放不下，表示是個大物件，嘗試放在老年區 老年區還是放不下，執行大掃除FullGC，來個大風吹 還是放不下，報OOM(OutOfMemory Error)錯誤  算法   GC的算法各有優劣，實際上是綜合使用</description>
    </item>
    
    <item>
      <title>抽取關鍵字至ES、Thymeleaf模板引擎</title>
      <link>https://yoziming.github.io/post/220126-gulimall-09-thymeleaf/</link>
      <pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220126-gulimall-09-thymeleaf/</guid>
      <description>商品上架  上架，除了把狀態改成上架，為了商品能被快速搜索到，還要提取出關鍵訊息存到ES 簡單來說就是把該商品的sku提取出來，存到ES的index中，當用戶搜索商品時，就可以依照分組動態產生篩選條件，依照得分呈現商品屬性   很繁瑣，但是不難 SpuInfoController.java  // 上架 @PostMapping(&amp;#34;/{spuId}/up&amp;#34;) public R spuUp(@PathVariable Long spuId) {  spuInfoService.up(spuId);  return R.ok(); }  SpuInfoServiceImpl.java  知識點:用stream把list轉map    // 商品上架 @Override public void up(Long spuId) {  // 先從spuID查出對應的所有sku  List&amp;lt;SkuInfoEntity&amp;gt; skuInfoEntities = skuInfoService.getSkusBySpuId(spuId);   // 先查出當前sku的所有可以被用來檢索的規格屬性  List&amp;lt;ProductAttrValueEntity&amp;gt; baseAttrs = productAttrValueService.baseAttrListforspu(spuId);  List&amp;lt;Long&amp;gt; attrIds = baseAttrs.stream().map(ProductAttrValueEntity::getAttrId).collect(Collectors.toList());  // sku當初填值時就有一欄是&amp;#34;是否能被檢索  List&amp;lt;Long&amp;gt; searchAttrIds = attrService.selectSearchAttrs(attrIds);  // 轉換為Set集合  Set&amp;lt;Long&amp;gt; idSet = searchAttrIds.</description>
    </item>
    
    <item>
      <title>DockerDekstop掛載相關設定</title>
      <link>https://yoziming.github.io/post/220125-wsl2-docker/</link>
      <pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220125-wsl2-docker/</guid>
      <description>Docker Dekstop   Docker Dekstop本身可以在Windows 上執行(基於wsl)，簡單使用沒問題，然而需要匯出匯入、掛載檔案就比較麻煩，
  wsl2可以透過加入一個中間橋(例如一個ubuntu)掛載雙方來達成操作檔案的目的
  PS.一般教學會用到Windows市集安裝，但我個人特別不喜歡Windows內建的那些東西，啥更新、市集全都在安裝後就砍光光了，所以只能全手動
  必要環境 Windows 10 64-bit：Home or Pro 2004 (build 19041) or higher, or Enterprise or Education 1909 (build 18363) or higher.
啟動wsl與hyper-V dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 安裝ubuntu   去微軟官方拿，我是選ubuntu-18.04版本
  手動下載網址: https://aka.ms/wsl-ubuntu-1804
  下載完直接改副檔名成.zip之類的，解壓縮
 注意好像必須在C槽且有管理員權限     執行這個一臉欠執行的.exe就會開始安裝，並且要求輸入建立用戶與密碼，記住帳號密碼  # 查看剛剛點ubuntu1804.exe裝的是否成功 wsl -l -v # 將 WSL 2 設定為預設版本 wsl --set-default-version 2 # 設定 WSL 預設 的Linux wsl --set-default Ubuntu-18.</description>
    </item>
    
    <item>
      <title>ElasticSearch與Spring整合</title>
      <link>https://yoziming.github.io/post/220125-gulimall-08-elasticsearch/</link>
      <pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220125-gulimall-08-elasticsearch/</guid>
      <description>ElasticSearch  用來執行站內搜索(如商品查詢)的引擎
  開源的分散式搜尋引擎，基於Apache Lucene，但是封裝成REST API，方便操作 核心觀念: Inverted Index (反向索引) 是 NoSQL 資料庫的一種，所有的資料都是以 JSON 的方式進行存取 名詞對應:     RDBMS 概念 Elasticsearch     Table 表 Index   Row 一筆資料(例如:張三) Document   Column 屬性(例如:姓名) Field   Schema 架構(例如:資料類型、允許為空等等) Mapping   SQL 操作語句 DSL     以前可能有人會說Index對應database，type才是對應表，但在ES7版後Type已經幾乎被棄用 個人直接把它看作表了，畢竟是概念，不用分太細  安裝  使用docker
  教學的他設定掛載位置與插件路徑，並取得權限等等，方便後續操作  mkdir -p /mydata/elasticsearch/config mkdir -p /mydata/elasticsearch/data echo &amp;#34;http.</description>
    </item>
    
    <item>
      <title>商品屬性維護、庫存模組、基礎篇總結</title>
      <link>https://yoziming.github.io/post/220124-gulimall-07/</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220124-gulimall-07/</guid>
      <description>商品屬性維護 spu檢索  一個快速找到API的方法  裝上插件RestfulTool，直接貼上文檔給的URL瞬間就能定位     SpuInfoServiceImpl.java  處理多條件模糊搜索    @Override public PageUtils queryPageByKeyword(Map&amp;lt;String, Object&amp;gt; params) { /* key: &amp;#39;華為&amp;#39;,//檢索關鍵字 catelogId: 6,//三級分類id brandId: 1,//品牌id status: 0,//商品狀態 */  QueryWrapper&amp;lt;SpuInfoEntity&amp;gt; wrapper = new QueryWrapper&amp;lt;&amp;gt;();  String key = (String) params.get(&amp;#34;key&amp;#34;);  if (StringUtils.isNotBlank(key) &amp;amp;&amp;amp; !&amp;#34;0&amp;#34;.equalsIgnoreCase(key)) {  wrapper.and(w -&amp;gt; {  // 模糊搜索為了怕蓋掉下面的所以用and，其實也能放最後就好  // 優先 NOT&amp;gt;AND&amp;gt;OR  w.eq(&amp;#34;id&amp;#34;, key).or().like(&amp;#34;spu_name&amp;#34;, key);  });  }  String status = (String) params.</description>
    </item>
    
    <item>
      <title>array、list多型與BaseMapper之謎</title>
      <link>https://yoziming.github.io/post/220123-array-list-polymorphism/</link>
      <pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220123-array-list-polymorphism/</guid>
      <description>Array  Java學著學著，有天用了一下go解題，才驚覺java中很少用Xxx[]，都快忘記為什麼了
  數組、陣列，例如Cat[] 長度固定，造的時候就要指定 可以間隔存null 不能泛型、但是協變 String[] is subtype of Object[]  聽說是早期因為沒有泛型所以做的設計，沒人用了    List List本身是接口，無法new List()
 ArrayList是它的主要實現類 另一個兄弟是LinkedList(鏈表，在高頻重複拔插有利) 還有一個被遺忘的vector，特色是執行緒安全，但幾乎沒人用  ArrayList   真正最常來當&amp;quot;數組&amp;quot;用的有序列表
  長度可變
   多型   目的是為了複用性與擴展性
 不需要每個子類都造相同的方法    同一個行為具有多個不同表現形式或形態的能力
  三個必要條件:
  繼承或實現: 總之有上下關係
  重寫: 子類中重寫同名方法
  父類的引用指向子類: 子類賦給父類，例如List list = new ArrayList()
    動態綁定: 在編譯期虛擬調用，在執行期才確定調用的方法</description>
    </item>
    
    <item>
      <title>保存sku、spu，feign遠程調用</title>
      <link>https://yoziming.github.io/post/220123-gulimall-06-feign/</link>
      <pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220123-gulimall-06-feign/</guid>
      <description>銷售屬性  AttrController.java  獲取的API跟先前幾乎一樣，所以改造之前的queryBasePageCatelogId，順便換名字    /** * 規格參數列表 */ @GetMapping(&amp;#34;/{attrType}/list/{catelogId}&amp;#34;) //@RequiresPermissions(&amp;#34;product:attr:list&amp;#34;) public R baseAttrList(@RequestParam Map&amp;lt;String, Object&amp;gt; params,  @PathVariable(&amp;#34;catelogId&amp;#34;) Long catelogId,  @PathVariable(&amp;#34;attrType&amp;#34;) String attrType ) {  PageUtils page = attrService.queryBaseAttrPage(params, catelogId, attrType);  return R.ok().put(&amp;#34;page&amp;#34;, page); }  AttrServiceImpl.java  @Override public PageUtils queryBaseAttrPage(Map&amp;lt;String, Object&amp;gt; params, Long catelogId, String attrType) {  QueryWrapper&amp;lt;AttrEntity&amp;gt; qw = new QueryWrapper&amp;lt;&amp;gt;();  // 判斷是要銷售還是基本屬性，1=基本，0=銷售  qw.eq(&amp;#34;attr_type&amp;#34;, &amp;#34;base&amp;#34;.equalsIgnoreCase(attrType) ? 1 : 0);  順便修改保存方法   為了不留技術債(只有自己知道的神秘代號)，新增一個枚舉類來表示   把剛剛用的1、0都換成ProductConstant.</description>
    </item>
    
    <item>
      <title>Java中finally與return的順序</title>
      <link>https://yoziming.github.io/post/220122-java-try-finally-return/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220122-java-try-finally-return/</guid>
      <description>直接上結論 總之finally都會在最後執行  不管有沒有出現異常，finally塊中代碼都會執行 當try和catch中有return時，finally仍然會執行 finally是在return後面的運算式運算之後執行的  return的先後涉及值改變的情況 try語句在返回前，將其他所有的操作執行完，保留好要返回的值，而後轉入執行finally中的語句，而後分為以下三種情況
  情況一：如果finally中有return語句，則會將try中的return語句“覆蓋”掉，直接執行finally中的return語句，得到返回值，這樣便無法得到try之前保留好的返回值。
  情況二：如果finally中沒有return語句，也沒有改變要返回值，則執行完finally中的語句後，會接著執行try中的return語句，返回之前保留的值。
  情況三：如果finally中沒有return語句，但是改變了要返回的值，這裡有點類似與引用傳遞和值傳遞的區別，又分以下兩種情況
  如果return的資料是基底資料型別或文本字串，則在finally中對該基本資料的改變不起作用，try中的return語句依然會返回進入finally塊之前保留的值
  如果return的資料是引用資料類型，而在finally中對該引用資料類型的屬性值的改變起作用，try中的return語句返回的就是在finally中改變後的該屬性的值
    </description>
    </item>
    
    <item>
      <title>後台-商品屬性，多對多非外鍵表操作</title>
      <link>https://yoziming.github.io/post/220122-gulimall-05-sku-spu/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220122-gulimall-05-sku-spu/</guid>
      <description>後台-商品屬性  先認識名詞
  SPU（Standard Product Unit）  「標準產品單位」，是商品資訊聚合的最小單位，是一組可複用、易檢索的標準化資訊的集合，該集合描述了一個產品的特性，例如: 「iPhone 13」   SKU（Stock Keeping Unit）  「最小庫存單位」，對應具體規格的商品，即貨號（或料號），例如: 「iPhone 13(256G)」、「潮男衝鋒衣-M-Blue」   既然是商城項目，現在需要呈現幾種關聯:  選中一個品牌，他有哪些品項的產品，例如: 蘋果:手機、平板&amp;hellip; 選中一個品項(分類)，裡面有他的規格等參數，例如: 手機{CPU:高通880, 尺寸:6吋&amp;hellip;} 選中一個SPU，他有那些共通屬性，例如: iPhone 13的廠商都是蘋果、作業系統都是IOS&amp;hellip; 選中一個SKU，有哪些獨特屬性，例如: 顏色、有多少庫存&amp;hellip; 以上有些是多對多的關係，還挺複雜的，一一拆解來實現  標題大綱是學習的知識點      資料庫表的名詞對應  我直到跟著做完整個商品管理，才弄清他資料庫設計背後的商業邏輯，因為沒有外鍵又要多對多關聯，整個挺複雜的，這塊是難點
  brand = 品牌，一個品牌之下可能存在多個category  蘋果 有 手機、平板   在品牌中操作關聯 = 操作pms_category_brand_relation   category = 分類，品項   attr_group = 屬性分組  隸屬於某個category之下 例如: 手機的基本信息集合(裡面有長寬、大小、材質等等)     attr = 屬性  隸屬於某個category之下，例如: 手機的外殼有白色、黑色 其中attr_type = 1 表示基本屬性(規格參數)，例如: 三星S21的充電口是typeC(每個型號都一樣) 其中attr_type = 0 表示銷售屬性，例如哀鳳13的顏色(有多種對應的貨號)     屬性不一定有分組，因為他建立的時候不一定要填 建立關聯就是操作pms_attr_attrgroup_relation這張表  可以在規格參數頁面中對某條參數修改，指定他屬於某分組 也可以在分組頁面中將同品項未納入分組的屬性關聯到旗下    父子節點訊息傳遞  首先從品項出發，要呈現的效果是這樣    左邊的品項三級分類直接拿先前做好的來用</description>
    </item>
    
    <item>
      <title>node版本對應、NVS快速切換</title>
      <link>https://yoziming.github.io/post/220121-npm-sass-webpack/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220121-npm-sass-webpack/</guid>
      <description>node版本一環套一環  webpack中有sass-loader，用途是載入 Sass/SCSS 檔並將他們編譯為 CSS 這玩意版本太高會有相容問題，目前大部分用的是7開頭，用最新的容易出錯  npm install sass-loader@7.3.1 --save-dev  然後sass-loader又是基於node-sass，也要求版本，比如七版sass-loader對應4版以上的node-sass  npm install node-sass@4.14.1 --save-dev   然後node-sass又又需要對應Node JS版本，關係如下:
  官網: https://github.com/sass/node-sass
  Node JS版本   官網: https://nodejs.org/en/download/releases/
  目前2022年1月，14或12版是相對妥的，選擇使用LTS版本
 Node.js 16.13.2	Gallium Node.js 14.18.3	Fermium Node.js 12.22.9	Erbium    然而切換Node JS版本很麻煩，所以又有人做了工具
  Node Version Switcher  官網: https://github.com/jasongin/nvs  # 安裝(有choco，沒的話自己手動載) choco install nvs # 安裝node nvs add 版本號 # 移除 nvs rm 版本號  使用超簡單，輸入nvs就會跳出互動介面   方向鍵選擇 + Enter就切換好了 但是注意每次新開一個CMD要npm之前要先nvs指定使用的版本，否則會找不到npm的bin報錯無法辨識 &#39;npm&#39; 詞彙是否為 Cmdlet、函數 詳細可以參考這篇 https://www.</description>
    </item>
    
    <item>
      <title>逆向生成前端頁面、JSR303、雲儲存圖片</title>
      <link>https://yoziming.github.io/post/220121-gulimall-04-jsr303/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220121-gulimall-04-jsr303/</guid>
      <description>逆向生成前端頁面  首先一樣造出側邊欄   找到當初生成器產的那些，好樣的原來當初都一併造了，通通複製過去   另外去前端把權限驗證先暫時關了，全部返回true   查看效果，什麼新增修改基本的CRUD人家全做好了，哭阿  簡單修飾 顯示狀態換成開關  去餓了嗎找模板  :active-value，:是v-bind縮寫 相當於把showStatus的值在1跟0切換，而showStatus本就是pojo的屬性，所以直接傳給後端API就完事     &amp;lt;el-table-column  prop=&amp;#34;showStatus&amp;#34;  header-align=&amp;#34;center&amp;#34;  align=&amp;#34;center&amp;#34;  label=&amp;#34;顯示狀態&amp;#34;  &amp;gt;  &amp;lt;template slot-scope=&amp;#34;scope&amp;#34;&amp;gt;  &amp;lt;el-switch  v-model=&amp;#34;scope.row.showStatus&amp;#34;  active-color=&amp;#34;#13ce66&amp;#34;  inactive-color=&amp;#34;#ff4949&amp;#34;  :active-value=&amp;#34;1&amp;#34;  :inactive-value=&amp;#34;0&amp;#34;  @change=&amp;#34;updateBrandStatus(scope.row)&amp;#34;  &amp;gt;&amp;lt;/el-switch&amp;gt;  &amp;lt;/template&amp;gt;  &amp;lt;/el-table-column&amp;gt;  下面綁定一個監聽@change的方法，調用後端API更新   updateBrandStatus(data) {  console.log(&amp;#34;最新信息&amp;#34;, data);  let { brandId, showStatus } = data;  //發送請求修改狀態  this.</description>
    </item>
    
    <item>
      <title>後台:商品分類、網關轉發微服務、跨域</title>
      <link>https://yoziming.github.io/post/220120-gulimall-03-gateway/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220120-gulimall-03-gateway/</guid>
      <description>後台頁面  別的項目學過了，這邊快速跳過，只記幾個新知識
 計算屬性與監聽器 過濾器 組件化  可以復用的模板
  沒有el屬性，不與頁面中的元素綁定 template就是他的HTML模板 data()必須是一個函數而非物件   局部組件  用componments聲明，其中的key名就是標簽名    生命週期  參考 https://book.vue.tw/CH1/1-7-lifecycle.html  腳手架創建表單  之前這邊手動要先去router創建右邊的導航欄，腳手架可以用可視化工具直接創造，非常方便 自己要實現的部分只剩接後端API的網址與資料呈現  javax問題  啟動renren-fast服務時因為引用了common模組(為了讓後台的server也能上nacos服務發現)，又出了點問題，排查了半天  package javax.validation.constraints does not exist 解法: &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-validation&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  我感覺人人開源這個項目已經跟不上時代了，網路上目前2022年1月比較推薦的是若依腳手架，他這個star超高全站第2，也有一直在維護，issue處理很積極，有機會嘗試看看 https://gitee.com/y_project/RuoYi  後端  現在要實現在後台檢視商品列表功能，進到product模組的controller，寫查詢的控制器與服務、實現類 要返回的資料是這種表格   三級樹形列表，老師這邊一次sql查出全部資料然後用stream工具類操作賦好值，實在太強。我想看懂就花了大半天，還是老實for循環，或是多查幾次SQL吧&amp;hellip;   /** * 三級樹型列表 * * @return */  @Override  public List&amp;lt;CategoryEntity&amp;gt; listTree() {  // 查所有分類  List&amp;lt;CategoryEntity&amp;gt; entities = baseMapper.</description>
    </item>
    
    <item>
      <title>服務註冊nacos、feign、Gateway</title>
      <link>https://yoziming.github.io/post/220119-gulimall-02-nacos/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220119-gulimall-02-nacos/</guid>
      <description>SpringCloud自由配 結合SpringCloud Alibaba最終的技術搭配方案
 SpringCloud Alibaba - Nacos: 註冊中心 (服務發現/註冊) SpringCloud Alibaba- Nacos: 配置中心 (動態配置管理) SpringCloud Ribbon: 負載均衡 SpringCloud Feign: 聲明式HTTP客户端(調用遠程服務) SpringCloud Alibaba - Sentinel: 服務容錯(限流、降級、熔斷) SpringCloud Gateway: API 網關 (webflux 編程模式) SpringCloud Sleuth: 調用鏈監控 SpringCloud Alibaba - Seata: 原Fescar, 即分佈式事務解決方案  版本需求關係  SpringCloud 版本配不上，開都開不起來
 https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E
Nacos註冊  https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html
  導依賴  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.6.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  docker啟動nacos  --env 配置環境 MODE=standalong 單節點 --name nacos 映象名稱為nacos -d 背景啟動    # 拉映像 docker pull nacos/nacos-server # 啟動容器 docker run --env MODE=standalone --name nacos -d -p 8848:8848 -e JVM_XMS=256m -e JVM_XMX=256m -e JVM_XMN=256m -e JVM_MMS=256m nacos/nacos-server  這東西不限制會吃超多記憶體 預設網址為localhost:8848/nacos，帳號密碼都是nacos  註冊服務 在應用的 /resource /application.</description>
    </item>
    
    <item>
      <title>項目簡介 &amp; 環境搭建</title>
      <link>https://yoziming.github.io/post/220118-gulimall-01/</link>
      <pubDate>Tue, 18 Jan 2022 12:00:00 +0800</pubDate>
      
      <guid>https://yoziming.github.io/post/220118-gulimall-01/</guid>
      <description>項目簡介  市面上常見的電商模式
   B2B(Business to Business)是指商家和商家建立的商業關係
  B2C(Business to Consumer)就是我們經常看到的供應商直接把商品賣個用户，也就是商業零售，直接面向消費銷售產品和服務
  C2B(Customer to Business)即消費者對企業，先有消費者需求產生而後有企業生產，即先有消費者提出需求，後又生產企業按需求組織生產
  C2C(Customer to Consumer)客户之間把自己的東西放到網上去賣
  O2O(Online To Offline)將線下商務的機會與互聯網結合在一起，讓互聯網成為線下交易前台，線上快速支付線下優質服務，如UBER
    穀粒商城是一個B2C模式的電商平台
  項目架構圖  微服務劃分圖  項目技術&amp;amp;特色  前後分離開發，並開發基於 vue 的 後台管理系統 SpringCloud 全新的解決方案 應用監控、限流、網關、熔斷降級、等分佈式方案，全方位涉及 透徹講解分佈式事務，分佈式鎖等分佈式系統的難點 壓力測試與性能優化 各種集群技術的區別以及使用 CI/CD 使用  環境搭建 安裝linux虛擬機   下載VirtualBox
 https://www.virtualbox.org/    下載Vagrant
 https://www.vagrantup.com/downloads.html    使用Vagrant快速建立linux虛擬機，打開window cmd或power shell</description>
    </item>
    
    <item>
      <title>醫院管理API &amp; 服務註冊與發現</title>
      <link>https://yoziming.github.io/post/220118-agg-spring-08/</link>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220118-agg-spring-08/</guid>
      <description>醫院管理系統  hospital-manage醫院管理系統，是一個已經完成的模組，功能是提供給醫院方操作，讓醫院管理人員上傳醫院的科室、排班資訊等等的一個小系統 我們的項目是預約掛號平台，要實現求診者與醫院的配對 現在就要模擬實際業務，參考提供的API文檔完成對接  連接MongoDB  練習點，這邊把醫院方上傳的資料存到mongoDB
  回到service-hosp模組，先去application.properties設定資料庫連線地址 建立接口繼承MongoRepository  @Repository public interface HospitalRepository extends MongoRepository&amp;lt;Hospital, String&amp;gt; {}  建立HospitalServiceImpl接口與實現類、ApiController開始對接API  上傳醫院  控制層知識點:  request.getParameterMap()拿到的是String[]，最好轉成Obj方便後續操作 這邊用了base64編碼傳了一張圖片，&amp;quot;+&amp;ldquo;變成了&amp;rdquo; &amp;ldquo;空白要還原 之後用&amp;lt;img src=&amp;quot;data:image/png;base64,編碼串&amp;quot;/&amp;gt;可以把圖片還原顯示出來    @ApiOperation(&amp;#34;上傳醫院&amp;#34;) @PostMapping(&amp;#34;saveHospital&amp;#34;) public Result saveHospital(HttpServletRequest request) {  Map&amp;lt;String, String[]&amp;gt; parameterMap = request.getParameterMap();  // 調用工具類把map中的string[]轉成obj  Map&amp;lt;String, Object&amp;gt; stringObjectMap = HttpRequestHelper.switchMap(parameterMap);  // base64編碼傳送過程中把&amp;#34;+&amp;#34;變成了&amp;#34; &amp;#34;空白，要轉換回來  String logoData = (String) stringObjectMap.get(&amp;#34;logoData&amp;#34;);  logoData = logoData.</description>
    </item>
    
    <item>
      <title>MongoDB</title>
      <link>https://yoziming.github.io/post/220117-agg-spring-07-mongodb/</link>
      <pubDate>Mon, 17 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220117-agg-spring-07-mongodb/</guid>
      <description>MongoDB  茫狗DB
  屬於NoSQL，非關聯式 以JSON的格式儲存資料 強處:高併發讀寫、巨量資料、擴展好 弱點:交易  前置 # 拉取鏡像 docker pull mongo:latest  # 創建和啓動容器 docker run --name mymongo -p 27017:27017 -d mongo  # 進入容器 docker exec -it mymongo /bin/bash  # 使用MongoDB客户端進行操作 mongo 庫操作 //Help查看命令提示db.help()//切換/創建資料庫(如果不存在就創建)usetest//查詢所有資料庫showdbs//刪除當前使用資料庫db.dropDatabase()//查看當前使用的資料庫db或db.getName()//顯示當前db狀態db.stats()//當前db版本db.version()//查看當前db的鏈接機器地址db.getMongo() 剛建立的db在show看不到，直到其中存了實際的資料才算數  命名限制  不能是空字符串&amp;quot;&amp;quot; 不得含有&#39; &#39;(空格)、.、$、/、\和\0 (空字符) 避免用_下畫線開頭 應全部小寫 最多64字節  名詞對應    SQL Mongo 解釋/説明     table collection 表/集合   row document 行/文檔，即一筆資料(如:張三&amp;hellip;)   column field 字段/域，欄位(如:姓名)   index index 索引   join embedded 表連接，MongoDB叫嵌入但略有不同   primary key _id 主鍵，MongoDB自動將_id當主鍵，沒指定就自動創    集合操作  相當於操作&amp;quot;表&amp;quot;</description>
    </item>
    
    <item>
      <title>字典檔模組、Spring Cache&#43;Redis、Nginx</title>
      <link>https://yoziming.github.io/post/220116-agg-spring-06/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220116-agg-spring-06/</guid>
      <description>字典檔  暫時不知道作來幹嘛，就是放一些縣市級分區的資本資料
  一樣分前、後端實現功能  顯示列表 後端-建模組  建立service-cmn子模組  複習一下過程，在父節點service右鍵新增 選maven，無原型，用-命名，選Parent，其他不動 到pom.xml中    刪除 &amp;lt;properties&amp;gt;  &amp;lt;maven.compiler.source&amp;gt;8&amp;lt;/maven.compiler.source&amp;gt;  &amp;lt;maven.compiler.target&amp;gt;8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt;  加入描述 &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;service-cmn&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;service-cmn&amp;lt;/description&amp;gt;  把servicehosp整包複製過來，取完整新包名yoziming.ad.servicecmn，開始改造名稱 可以用重命名功能與大量取代，注意大小寫與範圍   查到mybatis plus有自動生成功能，但看了一下有點亂，用複製的挺穩也快，先將就吧 最後記得對子模組右鍵，引入框架支援  看到application.properties裡面是灰的就要想到這點  裡面連的庫名與服務端口、服務名要改       swagger的@Api註解value與tags的區別  value用於描述 tags用於分組，類的tag會覆蓋方法的    後端-寫接口 // DictController @Api(value = &amp;#34;數據字典&amp;#34;, tags = &amp;#34;數據字典&amp;#34;) @RestController @RequestMapping(&amp;#34;/admin/cmn/Dict&amp;#34;) @CrossOrigin public class DictController {  @Autowired  private DictService dictService;   @ApiOperation(&amp;#34;根據id查詢子數據列表&amp;#34;)  @GetMapping(&amp;#34;getAllChildDictById/{id}&amp;#34;)  public Result getAllChildDictById(@PathVariable Long id) {  return Result.</description>
    </item>
    
    <item>
      <title>RESTful API</title>
      <link>https://yoziming.github.io/post/220115-restful-api/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220115-restful-api/</guid>
      <description>RESTful API  一種設計風格，以資源為核心，用HTTP請求方法傳達動作意涵
  HTTP協議的常見請求，對應的資料庫操作為:     HTTP SQL 意義     GET SELECT 從Server讀取資源   POST CREATE 往Server建立(或更新)資源   PUT UPDATE 使Server更新(全覆蓋)指定資源   PATCH UPDATE 使Server更新(局部)指定資源   DELETE DELETE 使Server刪除指定資源     URI: Uniform Resource Identifier，統一資源定位，一個URI表示一個確切的資源  為URL的子集   範例:      格式 範例     URL 協議://域名/路徑?查詢#HASH http://abc.com/users?action=delete&amp;amp;id=1   URI 協議://域名/路徑 http://abc.</description>
    </item>
    
    <item>
      <title>前端:後臺模板vue-admin-template</title>
      <link>https://yoziming.github.io/post/220115-agg-spring-05/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220115-agg-spring-05/</guid>
      <description>後臺模板  非常經典的模板，被用的很廣泛
  倉庫 https://github.com/PanJiaChen/vue-admin-template 解壓縮下載來的vue-admin-template-master，取個好名字放到自己的專案路徑下 進到資料夾，執行npm install安裝依賴  依賴除錯  課件給的老板本用起來很多錯誤，需要手動排查
 // 載都沒載直接報錯停止，可能是npm版本太高，降版本: npm install npm@6.14.10 -g /* node-sass問題，報錯為 node-sass@4.14.1 postinstall: `node scripts/build.js` node-sass跟Node.js版本有很大關係，不相容的時候可以這樣 */ npm install gulp-sass --save-dev npm install node-sass@latest // 清除緩存 npm cache clean --force  都沒問題使用npm run dev就能啟動了  後來我是去它倉庫抓4.4版本的，依賴都沒報錯，也不用修改登入接口那些    開始搭建 新增側邊欄  左邊那些表在vue中對應叫router，修改/src/router/index.js綁定要顯示的項目 @/是設定好的別名，表示/src路徑之下 然後在view中添加要顯示的內容，新增檔案後輸入veu+table就能產生模板  串接api  到@/api下編輯接口，複製一個預設的來改，點進去發現第一行import request from &#39;@/utils/request&#39;是已經引用好axios了  但是他這邊request.js裡面成功代號預設是20000，如果與後端用的不同要自己修改  改這個最好用全局取代，因為還有其他比如登入也用到這個代碼，要統一改     修改下面的請求方法，與後端api的URL對接  import request from &amp;#39;@/utils/request&amp;#39;  export default {  findPageHospitalSet(current, limit, searchObj) {  return request({  // ES6特性，反引號包裹強化字串  url: `http://localhost:8201/admin/hosp/hospitalSet/findPageHospitalSet/${current}/${limit}`,  // url: `/admin/hosp/hospitalSet/findPageHospitalSet/${current}/${limit}`,  method: &amp;#39;post&amp;#39;,  // data表示使用json傳遞給後端的@RequestBody  data: searchObj  })  } }  暫時先用完整的url跳過需要關閉mock與跨域問題  修改請求端口號  留坑，暫時先用完整的url跳過需要關閉mock與跨域問題</description>
    </item>
    
    <item>
      <title>前端:ES6、Vue、Node.js</title>
      <link>https://yoziming.github.io/post/220114-agg-spring-04/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220114-agg-spring-04/</guid>
      <description>ES6  ECMAScript 6(簡稱ES6)，是 JavaScript 語言新一代的標準，在 2015 年 6 月正式發佈 泛指 ES5.1 版以後的新一代 JavaScript 語言標準 Ecma International:歐洲一個定標準的組織，比較出名的有CD-ROM格式  特性  與傳統javascript的差別
  聲明變量用let取代var  有作用域，在{}之間 不可重複聲明   常量用const，且須顯式聲明 快速解構、快速定義:  let user = {name: &amp;#39;Helen&amp;#39;, age: 18} let { name, age } = user console.log(name, age)  let money=100 let type=&amp;#34;cat&amp;#34; let kitty={type,money} console.log(kitty)  模板字串:用反引號包裹，其中可以換行，可以用${}，{}中可以有運算  let name = &amp;#34;lucy&amp;#34; let age = 17 let info = `My name is ${name}, I am ${age+1}` console.</description>
    </item>
    
    <item>
      <title>醫院設定模組、swagger2、統一返回/異常/日誌</title>
      <link>https://yoziming.github.io/post/220113-agg-spring-03/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220113-agg-spring-03/</guid>
      <description>搭建醫院設定模組  service-hosp，提供查詢與管理醫院設定
  首先父節點service的pom已經將model設為依賴，可以引用其下的實體類model   進到service-hosp修改pom，引用spring-boot-maven-plugin，讓maven打包的時候把依賴也包進去，包成一個可以直接執行的jar包   添加application.properties，指定服務連接的名稱、端口、資料庫連接等等  # 服務端口 server.port=8201 # 服務名 spring.application.name=service-hosp # 環境設置：dev、test、prod spring.profiles.active=dev # mysql資料庫連接 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/yygh_hosp?characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=1234 #返回json的全局時間格式 spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8  創建當前包servicehosp，加入啟動類  package yoziming.ad.servicehosp @SpringBootApplication public class ServiceHospApplication {  public static void main(String[] args) {  SpringApplication.run(ServiceHospApplication.class, args);  } }  在yoziming.ad.servicehosp包下新增三個包controller、mapper、service，實現mybatis+的要求以執行CRUD操作  mapper下新增接口，繼承BaseMapper&amp;lt;bean&amp;gt; @Mapper public interface HospitalSetMapper extends BaseMapper&amp;lt;HospitalSet&amp;gt; { } service下新增接口，繼承IService&amp;lt;bean&amp;gt; public interface HospitalSetService extends IService&amp;lt;HospitalSet&amp;gt; { }  service下再增加impl包，放實現類，繼承ServiceImpl&amp;lt;剛創的Mapper,bean&amp;gt;，實現接口 @Service public class HospitalSetServiceImpl extends ServiceImpl&amp;lt;HospitalSetMapper, HospitalSet&amp;gt; implements HospitalSetService { } Controller綁定網址，注入service，即可開始業務邏輯 @RestController @RequestMapping(&amp;#34;/admin/hosp/hospitalSet&amp;#34;) public class HospitalSetController {   // 注入service  @Autowired  private HospitalSetService hospitalSetService;   // 查詢醫院表所有訊息  @GetMapping(&amp;#34;findAll&amp;#34;)  public List&amp;lt;HospitalSet&amp;gt; findAllHospitalSet(){  return hospitalSetService.</description>
    </item>
    
    <item>
      <title>MyBatis-Plus快速上手</title>
      <link>https://yoziming.github.io/post/220112-agg-spring-02-mybatis-plus/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220112-agg-spring-02-mybatis-plus/</guid>
      <description>MyBatis-Plus  非常好用的ORM框架
  https://baomidou.com/ 它官網目前2022年1月是最新3.5.0版本，以下基於此版本與MySQL 8演示  依賴 &amp;lt;!--mybatis-plus--&amp;gt; &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;3.5.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--mysql依賴--&amp;gt; &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok用來簡化實體類--&amp;gt; &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;  &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring-boot-starter 如果沒有要加--&amp;gt; &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; application.properties #MySQL 8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=1234 #mybatis日誌，開啟後更好查看SQL操作 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 綁定Mapper  最傳統是在xml中一個一個綁定bean的屬性與資料庫的表格，Mapper就是他們的映射關係。
在MyBatis-Plus中只要繼承他封裝好的BaseMapper就能直接開始CRUD
 在實體類(pojo/bean/entity)的包下先建立對應的實體類(例如User.java)，用@Data標記讓Lombok快速生成，不用Lombok就自己手動生成setter那些
@Data public class User { 創建包名mapper，下面建立對應的Mapper接口，繼承BaseMapper&amp;lt;User&amp;gt;，泛型&amp;lt;&amp;gt;中放bean，並用@Repository標記(為了後面測試生成實例時不泛紅報錯)，例如:</description>
    </item>
    
    <item>
      <title>Spring框架、預約就醫項目</title>
      <link>https://yoziming.github.io/post/220112-agg-spring-01/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220112-agg-spring-01/</guid>
      <description>本筆記基於:尚医通项目:尚硅谷Java微服务+分布式+全栈项目【尚医通】 https://www.bilibili.com/video/BV1V5411K7rT
 Spring  輕量(檔案才幾MB)的開源框架，用以簡化開發過程 最主要目的就是降低耦合 非侵入式:框架的API不會出現在業務邏輯中，業務邏輯本身是乾淨的方便轉移 容器:用容器管理物件的生命週期與依賴關係 Spring的核心為IoC與Aop  IoC  Inversion of Control，直譯控制反轉不好理解，其實就是一種依賴關係的轉移 傳統方法例如&amp;quot;貓叫&amp;quot;，我要先造一隻貓，然後讓貓執行叫方法 現在反過來，我從&amp;quot;叫&amp;quot;出發，告訴容器要執行叫的是一隻貓，這個貓由容器來提供  如果想換成&amp;quot;狗叫&amp;quot;，我一樣是從叫出發，只是跟容器說現在要給我狗   如此一來，降低了耦合(不需要親自造貓用貓)，提高了復用性(一個叫不僅貓狗，雞豬牛羊都行) 傳統依賴關係是需要先主動造貓或造狗之後用來叫，現在反過來從&amp;quot;叫&amp;quot;讓容器造對應的物件去想叫的地方，所以說是控制反轉  DI  IoC算是一個思想，實作上Spring使用DI將其實現
   Dependency Injection，依賴注入，是IOC思想的具體實現，即由容器建立物件，並且把物件注入到要用的地方
  被依賴物件透過外部注入至依賴物件的地方使用
  就是把物件實例化交給框架管理
  本來Book book = new Book()
  現在用工廠代理+反射交給框架創建，降低耦合
    Bean管理   Spring的Bean管理，流程分為創建物件與注入屬性
  想造物件首先要有一個工廠，Spring提供有兩種:
  BeanFactory:框架內部用的接口，在獲取物件時才創物件
  ApplicationContext:是BeanFactory的子接口，在加載時就創好物件，一般用的都是這個
    AOP  Aspect-Oriented Programming 切面導向程式設計，它的目的在於將許多的共同方法抽離出來，與物件導向程式設計類似，但AOP 與OOP 不同的地方就在於，AOP 不用原方法呼叫共同方法，只需要指定執行共同方法的時機點即可。 不好理解，看專業的說明吧  https://ithelp.</description>
    </item>
    
    <item>
      <title>JSON、AJAX、i18n</title>
      <link>https://yoziming.github.io/post/220111-agg-javaweb-11/</link>
      <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220111-agg-javaweb-11/</guid>
      <description>JSON  JavaScript Object Notation
  輕量(相較於xml)的資料交換格式 用一對大括號{}包裹，中間以:分隔鍵值對，用,分隔多對 裡面可以放:  數字(整數或浮點數，可用e表示指數)，不能是NaN 字串(用&amp;quot;&amp;quot;包裹) 布林值(boolean) (true 或 false) 陣列(用[]包裹) 物件 (用{ }套娃) null    javaScript中 &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt;  var jsonObj = {  &amp;#34;key1&amp;#34;: 123,  &amp;#34;key2&amp;#34;: &amp;#34;abc&amp;#34;,  &amp;#34;ket3&amp;#34;: [&amp;#34;中&amp;#34;, &amp;#34;文&amp;#34;]  };  alert(jsonObj.ket3)   var jsonString = JSON.stringify(jsonObj);  alert(jsonString);  var jsonObj2 = JSON.parse(jsonString); &amp;lt;/script&amp;gt;  JSON可以是:  物件，用於操作 字串，用於傳遞   用JSON.stringify()與JSON.parse()方法互相轉換  Java中  要引用第三方包，例如Gson或Jackson Gson範例:  @Test public void test1() {  User user = new User(&amp;#34;zhung3&amp;#34;, &amp;#34;pass123&amp;#34;, &amp;#34;zhung3@goo.</description>
    </item>
    
    <item>
      <title>Filter過濾器、ThreadLocal</title>
      <link>https://yoziming.github.io/post/220110-agg-javaweb-10/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220110-agg-javaweb-10/</guid>
      <description>Filter過濾器  用來修飾請求或響應
   在Web資源被訪問前，檢查request物件，修改請求頭和請求正文，或對請求進行預處理操作
  將請求傳遞到下一個過濾器或目標資源
  在Web資源被訪問後，檢查response物件，修改回應頭和回應正文
  常用來做權限控管、設定統一編碼等等
  方法  Filter都是接口，用起來跟servlet一樣需要實現方法
前面都是偷雞造一個base去實現基本的方法然後繼承
   init (FilterConfig filterConfig):初始化，由web容器調用
  doFilter(ServletRequest request,SeivletResponse response, FilterChain chain):主要方法，在這邊對req或resp毛手毛腳，或是chain.doFilter再傳到下一個過濾器
  destroy():釋放被這個filter物件占用的資源，由web容器調用
  生命週期  構造、init():跟隨web工程而啟動，被執行一次 doFilter():在每次攔截請求都調用 destrory():跟隨web工程結束而消亡，也只執行一次  FilterConfig  跟Servlet基本一樣
   每個Filter都有自己伴生的FilterConfig實例物件，當web容器啟動時一併被創造出來，其中包含了它Filter的訊息
  filterconfig.getFilterName():
  filterconfig.getInitParameter():取得初始參數(例如寫在web.xml中的&amp;lt;init-param&amp;gt;
  filterconfig.getServletContext():也能獲得ServletContext
 記住取出的ServletContext context是整個web工程共用的唯一一個 複習:可以用來從url網址取到對應的硬碟路徑， 例如context.getRealPath(&amp;quot;/&amp;quot;) 也可以當map用存setAttribute，與取getAttribute    FilterChain  串聯多個過濾器，直到沒有chain.</description>
    </item>
    
    <item>
      <title>Cookie與Session，書城訂單模組</title>
      <link>https://yoziming.github.io/post/220109-agg-javaweb-09/</link>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220109-agg-javaweb-09/</guid>
      <description>Cookie  因為HTTP是無狀態(stateless)的，當我們想保存資訊就要用到Cookie
  伺服器通知客戶端保存鍵值對的技術  白話:叫用戶保存住某個值   應用舉例:記住用戶名 由用戶的瀏覽器維護，視生命週期存在記憶體或硬碟中 單個最多4 KB  使用  很簡單就不多說了
  在Java中是Cookie類  protected void doCookie(HttpServletRequest request, HttpServletResponse response) throws ServletException,  IOException {  // 設定編碼  request.setCharacterEncoding(&amp;#34;UTF-8&amp;#34;);  response.setContentType(&amp;#34;text/html; charset=UTF-8&amp;#34;);  // 在Java造Cookie類物件  Cookie cookie1 = new Cookie(&amp;#34;key1&amp;#34;, &amp;#34;value1&amp;#34;);  // 增，注意是response叫客戶端造cookie  response.addCookie(cookie1);  response.getWriter().write(&amp;#34;cookie創建成功!&amp;#34;);   // 取  Cookie[] cookies = request.getCookies();  // 取來的是所有cookies構成的數組  for (Cookie cookie2 : cookies) {  response.</description>
    </item>
    
    <item>
      <title>書城項目:Maven管理依賴、圖書模塊</title>
      <link>https://yoziming.github.io/post/220108-agg-javaweb-08/</link>
      <pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220108-agg-javaweb-08/</guid>
      <description>Maven管理依賴   傳統作法是建一個lib資料夾然後手動引入
  項目越多就越麻煩，打包的時候還要注意引用的有沒有包到
  專案重構  把專案整個重構，可以先把src下做的那些頁面跟java檔複製出來
   第一層最好先造一個空的專案方便命名與分類
 如果直接拿第一層的project當同名的module用，我的IDEA偶爾會有奇怪的BUG，生出兩個同名的module 後來知道原因了，就是模組根目錄下的.iml檔案裡面有重復的句子導致，備份後把它刪了讓IDEA重創一份就可    我這邊放尚硅谷課程的練習，所以project就叫atguigu
   因為是空的專案，進去之後IDEA馬上會叫你建一個Module，選javaEE，模板選到webapp    如果不想重造，在專案設定 &amp;gt; Facets
 右上設定部屬的描述檔案，就是那些web.xml之類 右下決定資源根目錄，如果顯示紅字可以點它自動生成    由於管理選的maven，造出來會自帶一個pom.xml，這個就是maven的設定檔，一個maven專案的標準目錄結構是這樣
   點開pom.xml，裡面有一些描述，往下拉到&amp;lt;dependencies&amp;gt;標籤，在這邊告知項目要引用那些包   不像golang在終端輸入go get xxx就完事，maven導包需要寫標籤代碼，但還是能偷懶的，點開中央庫搜尋頁面 https://search.maven.org/#browse   查到想要找的包，對他一通按，點進去要引用的版本   看到右邊，貼心的代碼已經準備好了   愉快的一頓複製貼上之後，回到IDEA刷新maven，他會把這些從中央倉庫引用的jar包下載一份到(預設是我的文件中.m2資料夾)放好  所以第一次可能會比較久一點     之後有引用都是同理，從此不需要手動把jar包放進lib目錄，部屬打包的時候它也會自動去準備配菜  路徑優化  現在Servlet用註解方式引用，解放了web.xml 前端頁面用共通的head.</description>
    </item>
    
    <item>
      <title>檔案上傳與下載、書城項目優化</title>
      <link>https://yoziming.github.io/post/220107-agg-javaweb-07/</link>
      <pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220107-agg-javaweb-07/</guid>
      <description>檔案上傳  讓用戶從前端上傳一個檔案給伺服器
   要有一個 form 標籤，method=post 請求
 因為get有長度限制    form標籤的 encType 屬性值必須為 multipart/form-data 值
  在 form 標籤中使用 input type=file 添加上傳的檔
  編寫伺服器代碼(Servlet 程式)接收，處理上傳的資料
  encType=multipart/form-data 表示提交的資料以多段(每一個表單項一個資料段)的形式進行拼接，然後整個以二進位流的形式發送給伺服器
  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;#34;http://localhost:8080/book/uploadServlet&amp;#34; method=&amp;#34;post&amp;#34;  enctype=&amp;#34;multipart/form-data&amp;#34;&amp;gt;  用戶名：&amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;username&amp;#34; /&amp;gt; &amp;lt;br&amp;gt;  頭像：&amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;photo&amp;#34; &amp;gt; &amp;lt;br&amp;gt;  &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;上傳&amp;#34;&amp;gt; &amp;lt;/form&amp;gt;  &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  創一個UploadServlet用於接收，並且到web.</description>
    </item>
    
    <item>
      <title>Listener監聽器、EL表達式、JSTL標籤庫</title>
      <link>https://yoziming.github.io/post/220106-agg-javaweb-06/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220106-agg-javaweb-06/</guid>
      <description>Listener監聽器  是一個接口，用於監聽某種事物的變化  ServletContextListener 監聽器  ServletContextListener 它可以監聽 ServletContext 物件的創建和銷毀。 ServletContext 物件在 web 工程啟動的時候創建，在 web 工程停止的時候銷毀。 監聽到創建和銷毀之後都會分別調用 ServletContextListener 監聽器的方法回饋 兩個方法分別是:  public interface ServletContextListener extends EventListener {  // 在ServletContext 物件創建之後馬上調用，做初始化 public void contextInitialized(ServletContextEvent sce);  // 在ServletContext 物件銷毀之後調用 public void contextDestroyed(ServletContextEvent sce); 使用步驟   編寫一個類去實現 ServletContextListener
  實現其兩個回檔方法
  到 web.xml 中去配置監聽器
  監聽器實現類 public class MyServletContextListenerImpl implements ServletContextListener {  @Override public void contextInitialized(ServletContextEvent sce) { System.</description>
    </item>
    
    <item>
      <title>JSP</title>
      <link>https://yoziming.github.io/post/220105-agg-javaweb-05/</link>
      <pubDate>Wed, 05 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220105-agg-javaweb-05/</guid>
      <description>JSP  Java Server Page
  接收請求、處理請求已經了解，現在來到響應的部分 當有人來請求，我們用servlet接收並動態回應，比如想輸出一個html頁面作為結果，servlet可以做到但實現的辦法很蠢，就是靠out.print拼接硬刻出標籤文本格式，改進辦法就是JSP JSP將java &amp;gt; html 的過程包裝起來，可以更好的處理View的部分  底層代碼其實也是拼接，不過Java就是這樣，一層套一層   轉換過程  a.jsp &amp;gt;(被web容器翻譯成servlet) &amp;gt; a_jsp.java &amp;gt; a_jsp.class 然後類似一個servlet的生命週期，不過jsp轉來的有自己的方法名 構造 &amp;gt; _jspInit() &amp;gt; _jspService() &amp;gt; _jspDestroy()    JSP與Servlet的異同  引用 https://ithelp.ithome.com.tw/articles/10133506
  兩者都是HttpServlet(Servlet API)的子類  URL對應  Servlet的URL對應是需要設定的 但是JSP的對應就是它的實體路徑  如何被載入  Servlet一開始就是被編譯成class檔案，然後被http request的時候在被Web Container掛載進來 JSP是在被第一次呼叫的時候才會被Web Container先翻譯成為Servlet的java寫法，才編譯成為class檔案，放在Web Container一個 暫時的資料夾。雖然第一次執行會比Servlet慢，不過掛載以後就一樣了(因為JSP和Servlet一樣，只會掛載一次)  更新方式  Servlet如果有修改，需要重新編譯，因此需要重啟Web Container的服務 JSP頁面因為Web Container有在監控，因此，只要有修改，他會重新翻譯、編譯然後掛載。因此不需要重啟Web Container就能看到最新修改  JSP過氣? 到了2021年現在技術已經傾向前後端分離，JSP這種從後端響應結果到前端的技術確實已經少用了，但學javaweb作為基礎知識還是很有必要的，畢竟框架例如springMVC也是基於這些技術搭建，夯實地基才能建高樓</description>
    </item>
    
    <item>
      <title>JavaWeb架構、Servlet頁面轉發</title>
      <link>https://yoziming.github.io/post/220104-agg-javaweb-04/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220104-agg-javaweb-04/</guid>
      <description>JavaWeb的實現 一個web程式分成用戶端(瀏覽器)B與服務端S，搭建代碼實現彼此的請求溝通，要上線一個網站簡單可分成3大步驟
 架構:就是寫程式碼，決定用戶端發送怎樣的請求，服務端如何處理、業務邏輯，回應 打包:包成war 部屬:使用web容器(例如tomcat)執行war包，在瀏覽器中訪問指定的網址  MVC架構  MVC是一種設計模式，目的是讓HTML代碼和業務邏輯代碼分開
  Model模型，處理應用程式中資料與業務邏輯部分，就是跟資料庫打交道 View檢視，資料顯示部分，給人看的 Controller控制，負責從檢視中讀取資料並向模型傳送資料等。看前台(View)點了啥菜，叫廚房(Model)料理然後擺盤送餐  套用到Java中  用戶端發送請求 服務端的servlet或controller接收請求（路由規則由後端制定，整個專案開發的權重大部分在後端） 調用service、dao代碼完成業務邏輯 返回jsp jsp展現一些動態的代碼   java中的MVC = JavaBean + JSP + Servlet  MVC是一個分類的方法，一種設計模式；而實作WEB專案中我們的路徑劃分、包的管理通常是使用三層架構  三層架構  基於業務邏輯來分層
 表現層(Presentation Layer)  User Show Layer，USL、Client Application，用戶層、UI層
  表現層前台:  介面顯示、與用戶互動 JSP、JS、HTML…Web前端技術(通常位於WebContent資料夾)   表現層後台(也有人稱為控制層，但嚴格意義上不能這樣說):  用於控制頁面跳轉、調用業務邏輯層 Servlet、SpringMVC的Controller、Struts2…(xxx.servlet包中)    業務邏輯層(Business Logic Layer)  簡稱BLL或Application Server，AP層、應用層、manage
  承上啟下，完成業務邏輯、事務的操作也是在這 工程路徑、包名例如:  com.</description>
    </item>
    
    <item>
      <title>XML、Servlet</title>
      <link>https://yoziming.github.io/post/220103-agg-javaweb-03/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220103-agg-javaweb-03/</guid>
      <description>XML  Extensible Markup Language 可延伸標記式語言 常用於:  保存資料 作為配置文件 傳輸(但現在json為主)    特性  格式:&amp;lt;標籤名&amp;gt;夾住的值&amp;lt;/標籤名&amp;gt;  或單標籤內用空格分開屬性&amp;lt;book id=&amp;quot;SN65421&amp;quot; name=&amp;quot;小王子&amp;quot;/&amp;gt;   標籤名不可以數字或符號開始 標籤名不可包含空格 所有標籤都必須關閉 大小寫敏感 必須正確嵌套，例如a元素在b元素中打開，也必須在b元素中關閉 屬性值必須用&amp;quot;&amp;quot;引號包住  範例 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!-- xml 聲明 version 是版本的意思 encoding 是編碼 --&amp;gt; &amp;lt;books&amp;gt; &amp;lt;!-- 這是 xml 注釋 --&amp;gt;  &amp;lt;book id=&amp;#34;SN123123413241&amp;#34;&amp;gt; &amp;lt;!-- book 標籤描述一本圖書 id 屬性描述 的是圖書 的編號 --&amp;gt;  &amp;lt;name&amp;gt;java 程式設計思想&amp;lt;/name&amp;gt; &amp;lt;!-- name 標籤描述 的是圖書 的資訊 --&amp;gt;  &amp;lt;author&amp;gt;華仔&amp;lt;/author&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>jQuery</title>
      <link>https://yoziming.github.io/post/220102-agg-javaweb-02/</link>
      <pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220102-agg-javaweb-02/</guid>
      <description>jQuery  輔助JavaScript的類庫
  用於簡化HTML與JavaScript之間的操作  引用  下載jquery-1.7.2.js，放到指定位置，通常在static/script/之下  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=UTF-8&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt;  &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;/static/script/jquery-1.7.2.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt;  $(function () { // 表示頁面載入完成 之後，相當 window.onload = function () {}  var $btnObj = $(&amp;#34;#btnId&amp;#34;); // 表示按 id 查詢標籤物件  $btnObj.click(function () { // 綁定按一下事件  alert(&amp;#34;jQuery 的按一下事件&amp;#34;);  });  });  &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button id=&amp;#34;btnId&amp;#34;&amp;gt;SayHello&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 核心函數$ $ 是jQuery 的核心函數，能完成jQuery 的很多功能。$()就是調用$這個函數</description>
    </item>
    
    <item>
      <title>Web前端:HTML、CSS與JavaScript基礎知識</title>
      <link>https://yoziming.github.io/post/220101-agg-javaweb-01/</link>
      <pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220101-agg-javaweb-01/</guid>
      <description>本筆記基於2020-02-26 尚硅谷最新版JavaWeb全套教程
https://www.bilibili.com/video/BV1Y7411K7zz
 Web前端三劍客  HTML(超文本標記語言):負責網頁的結構 CSS(層疊樣式表):負責網頁的樣式(比如顏色/字體/邊框等屬性設置) JavaScript(腳本語言):負責網頁的行為(點擊/輸入輸出/滾動等等)   他前端的課程幾乎都是過眼了解的程度而已，我也就沒做詳盡的筆記了
 HTML  用標籤表示語法，有幾點特性:  標籤無視大小寫 標籤要正確閉合 標籤不可嵌套使用 標籤中的屬性必須有值，屬性值必須加引號    &amp;lt;!-- 註釋 --&amp;gt; &amp;lt;標籤名&amp;gt;封裝的數據&amp;lt;/標籤名&amp;gt;  &amp;lt;!--屬性必須有值，屬性值必須加引號 --&amp;gt; 正確：&amp;lt;font color=&amp;#34;blue&amp;#34;&amp;gt;Hello world&amp;lt;/font&amp;gt;  &amp;lt;!--標籤的演示 div 標籤 預設獨佔一行 span 標籤 它的長度是封裝資料的長度 p 段落標籤 預設會在段落的上方或下方各空出一行來（如果已有就不再空） --&amp;gt; &amp;lt;div&amp;gt;div 標籤 1&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;div 標籤 2&amp;lt;/div&amp;gt; &amp;lt;span&amp;gt;span 標籤 1&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;span 標籤 2&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;p 段落標籤 1&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;p 段落標籤 2&amp;lt;/p&amp;gt;  &amp;lt;!-- 圖片 --&amp;gt; &amp;lt;img src=&amp;#34;1.</description>
    </item>
    
    <item>
      <title>事務、DAO、連接池、Dbutils工具包</title>
      <link>https://yoziming.github.io/post/211230-agg-jdbc-02/</link>
      <pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211230-agg-jdbc-02/</guid>
      <description>事務Transaction  Transaction，台灣:交易，中國:事務
   在MySQL中只有使用了Innodb資料庫引擎的資料庫或表才支援事務
  事務 = 一組操作資料庫的動作集合，使資料從一種狀態變換為另一種狀態
  一個事務保證一組SQL語句要嘛全部執行，要嘛全部不執行
 要嘛提交Commit，要嘛回滾Rollback    數據一旦提交，就不可回滾
  那些操作會自動提交?
 DDL(刪庫建表之類的操作):必定自動提交 DML(操作某筆資料):預設會自動提交，但可以set autocommit = false 關閉連接時，預設也會自動提交    事務的相關方法  由java.sql.Connection包提供，顯然這些方法都是由Connection物件調用
 public void setAutoCommit(boolean) public boolean getAutoCommit() public void commit() public void rollback() 事務實作流程  關閉自動提交 執行事務語句，可能有多行 commit()手動提交，並還原自動提交設定 於catch (Exception e) 區塊使用rollback()回滾  // 範例 public String delete(String id) {  String ID = id;  db = new getConnection(); 　Connection con = db.</description>
    </item>
    
    <item>
      <title>JDBC基礎、PreparedStatement增刪改查</title>
      <link>https://yoziming.github.io/post/211229-agg-jdbc-01/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211229-agg-jdbc-01/</guid>
      <description>本筆記基於2019年9月的 尚硅谷JDBC核心技术(新版jdbc)
https://www.bilibili.com/video/BV1eJ411c7rf
 JDBC  JDBC，全稱Java Database Connectivity 為java用來統一管理連接資料庫的接口 JDBC挺短的，且為JavaWeb的前置知識，我就歸到同一個筆記分類了  教學用資料庫  他官方的有編碼問題，這個是修正版的，用工具自己導入
PS1.DataGrip的導入常常出問題，針對導入最好用別款GUI
PS2.少了一個BLOB學到那邊自己插入即可
 -- -------------------------------------------------------- -- 主机: 127.0.0.1 -- 服务器版本: 8.0.22 - MySQL Community Server - GPL -- 服务器操作系统: Win64 -- HeidiSQL 版本: 11.1.0.6116 -- -------------------------------------------------------- /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET NAMES utf8 */;/*!50503 SET NAMES utf8mb4 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&amp;#39;NO_AUTO_VALUE_ON_ZERO&amp;#39; */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;-- 导出 jdbc_learn 的数据库结构 DROPDATABASEIFEXISTS`jdbc_learn`;CREATEDATABASEIFNOTEXISTS`jdbc_learn`/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci *//*!</description>
    </item>
    
    <item>
      <title>MySQL8新特性</title>
      <link>https://yoziming.github.io/post/211229-agg-mysql-14/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211229-agg-mysql-14/</guid>
      <description>MySQL8新特性概述  一樣跳過
 MySQL從5.7版本直接跳躍發佈了8.0版本，可見這是一個令人興奮的里程碑版本。MySQL 8版本在功能上做了顯著的改進與增強，開發者對MySQL的原始程式碼進行了重構，最突出的一點是多MySQL Optimizer優化器進行了改進。不僅在速度上得到了改善，還為使用者帶來了更好的性能和更棒的體驗。
1.1 MySQL8.0 新增特性 1. 更簡便的NoSQL支持 NoSQL泛指非關係型資料庫和資料存儲。隨著互聯網平臺的規模飛速發展，傳統的關係型資料庫已經越來越不能滿足需求。從5.6版本開始，MySQL就開始支援簡單的NoSQL存儲功能。MySQL 8對這一功能做了優化，以更靈活的方式實現NoSQL功能，不再依賴模式（schema）。
2. 更好的索引 在查詢中，正確地使用索引可以提高查詢的效率。MySQL 8中新增了隱藏索引和降冪索引。隱藏索引可以用來測試去掉索引對查詢性能的影響。在查詢中混合存在多列索引時，使用降冪索引可以提高查詢的性能。
3.更完善的JSON支援 MySQL從5.7開始支援原生JSON資料的存儲，MySQL 8對這一功能做了優化，增加了彙總函式JSON_ARRAYAGG()和JSON_OBJECTAGG()，將參數聚合為JSON陣列或物件，新增了行內操作符 -&amp;raquo;，是列路徑運算子 -&amp;gt;的增強，對JSON排序做了提升，並優化了JSON的更新操作。
4.安全和帳戶管理 MySQL 8中新增了caching_sha2_password 授權外掛程式、角色、密碼歷史記錄和FIPS模式支援，這些特性提高了資料庫的安全性和性能，使資料庫管理員能夠更靈活地進行帳戶管理工作。
5.InnoDB的變化 InnoDB是MySQL預設的存儲引擎，是事務型資料庫的首選引擎，支援事務安全表（ACID），支持行鎖定和外鍵。在MySQL 8 版本中，InnoDB在自增、索引、加密、鎖死、共用鎖等方面做了大量的改進和優化，並且支援原子資料定義語言（DDL），提高了資料安全性，對事務提供更好的支援。
6.資料字典 在之前的MySQL版本中，字典資料都存儲在中繼資料檔和非事務表中。從MySQL 8開始新增了交易資料字典，在這個字典裡存儲著資料庫物件資訊，這些資料字典存儲在內部事務表中。
7. 原子資料定義語句 MySQL 8開始支援原子資料定義語句（Automic DDL），即原子DDL。目前，只有InnoDB存儲引擎支援原子DDL。原子資料定義語句（DDL）將與DDL操作相關的資料字典更新、存儲引擎操作、二進位日誌寫入結合到一個單獨的原子事務中，這使得即使伺服器崩潰，事務也會提交或回滾。 使用支援原子操作的存儲引擎所創建的表，在執行DROP TABLE、CREATE TABLE、ALTER TABLE、 RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作時，都支援原子操作，即事務要麼完全操作成功，要麼失敗後回滾，不再進行部分提交。 對於從MySQL 5.7複製到MySQL 8 版本中的語句，可以添加IF EXISTS或IF NOT EXISTS語句來避免發生錯誤。
8.資源管理 MySQL 8開始支援創建和管理資源組，允許將伺服器內運行的執行緒分配給特定的分組，以便執行緒根據組內可用資源執行。組屬性能夠控制組內資源，啟用或限制組內資源消耗。資料庫管理員能夠根據不同的工作負載適當地更改這些屬性。 目前，CPU時間是可控資源，由&amp;quot;虛擬CPU&amp;quot;這個概念來表示，此術語包含CPU的核心數，超執行緒，硬體執行緒等等。伺服器在啟動時確定可用的虛擬CPU數量。擁有對應許可權的資料庫管理員可以將這些CPU與資源組關聯，並為資源組分配執行緒。 資源組元件為MySQL中的資源組管理提供了SQL介面。資源組的屬性用於定義資源組。MySQL中存在兩個預設組，系統組和使用者組，預設的組不能被刪除，其屬性也不能被更改。對於用戶自訂的組，資源組創建時可初始化所有的屬性，除去名字和類型，其他屬性都可在創建之後進行更改。 在一些平臺下，或進行了某些MySQL的配置時，資源管理的功能將受到限制，甚至不可用。例如，如果安裝了執行緒池外掛程式，或者使用的是macOS系統，資源管理將處於不可用狀態。在FreeBSD和Solaris系統中，資源執行緒優先順序將失效。在Linux系統中，只有配置了CAP_SYS_NICE屬性，資源管理優先順序才能發揮作用。
9.字元集支援 MySQL 8中預設的字元集由latin1更改為utf8mb4，並首次增加了日語所特定使用的集合，utf8mb4_ja_0900_as_cs。
10.優化器增強 MySQL優化器開始支援隱藏索引和降冪索引。隱藏索引不會被優化器使用，驗證索引的必要性時不需要刪除索引，先將索引隱藏，如果優化器性能無影響就可以真正地刪除索引。降冪索引允許優化器對多個列進行排序，並且允許排序順序不一致。
11.公用表運算式 公用表運算式（Common Table Expressions）簡稱為CTE，MySQL現在支持遞迴和非遞迴兩種形式的CTE。CTE通過在SELECT語句或其他特定語句前使用WITH語句對臨時結果集進行命名。</description>
    </item>
    
    <item>
      <title>觸發器Trigger</title>
      <link>https://yoziming.github.io/post/211228-agg-mysql-13/</link>
      <pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211228-agg-mysql-13/</guid>
      <description>觸發器Trigger  一樣跳過
 在實際開發中，我們經常會遇到這樣的情況：有 2 個或者多個相互關聯的表，如商品資訊和庫存資訊分別存放在 2 個不同的資料表中，我們在添加一條新商品記錄的時候，為了保證資料的完整性，必須同時在庫存表中添加一條庫存記錄。
這樣一來，我們就必須把這兩個關聯的操作步驟寫到程式裡面，而且要用事務包裹起來，確保這兩個操作成為一個原子操作，要麼全部執行，要麼全部不執行。要是遇到特殊情況，可能還需要對資料進行手動維護，這樣就很容易忘記其中的一步，導致資料缺失。
這個時候，咱們可以使用觸發器。**你可以創建一個觸發器，讓商品資訊資料的插入操作自動觸發庫存資料的插入操作。**這樣一來，就不用擔心因為忘記添加庫存資料而導致的資料缺失了。
1. 觸發器概述 MySQL從5.0.2版本開始支持觸發器。MySQL的觸發器和存儲過程一樣，都是嵌入到MySQL伺服器的一段程式。
觸發器是由事件來觸發某個操作，這些事件包括INSERT、UPDATE、DELETE事件。所謂事件就是指用戶的動作或者觸發某項行為。如果定義了觸發程式，當資料庫執行這些語句時候，就相當於事件發生了，就會自動激發觸發器執行相應的操作。
當對資料表中的資料執行插入、更新和刪除操作，需要自動執行一些資料庫邏輯時，可以使用觸發器來實現。
2. 觸發器的創建 2.1 創建觸發器語法 創建觸發器的語法結構是：
CREATETRIGGER觸發器名稱{BEFORE|AFTER}{INSERT|UPDATE|DELETE}ON表名FOREACHROW觸發器執行的語句塊;說明：
  表名：表示觸發器監控的物件。
  BEFORE|AFTER：表示觸發的時間。BEFORE 表示在事件之前觸發；AFTER 表示在事件之後觸發。
  INSERT|UPDATE|DELETE：表示觸發的事件。
 INSERT 表示插入記錄時觸發； UPDATE 表示更新記錄時觸發； DELETE 表示刪除記錄時觸發。    觸發器執行的語句塊：可以是單條SQL語句，也可以是由BEGIN…END結構組成的複合陳述式塊。
  2.2 代碼舉例 舉例1：
1、創建資料表：
CREATETABLEtest_trigger(idINTPRIMARYKEYAUTO_INCREMENT,t_noteVARCHAR(30));CREATETABLEtest_trigger_log(idINTPRIMARYKEYAUTO_INCREMENT,t_logVARCHAR(30));2、創建觸發器：創建名稱為before_insert的觸發器，向test_trigger資料表插入資料之前，向test_trigger_log資料表中插入before_insert的日誌資訊。
DELIMITER//CREATETRIGGERbefore_insertBEFOREINSERTONtest_triggerFOREACHROWBEGININSERTINTOtest_trigger_log(t_log)VALUES(&amp;#39;before_insert&amp;#39;);END//DELIMITER;3、向test_trigger資料表中插入資料
INSERTINTOtest_trigger(t_note)VALUES(&amp;#39;測試 BEFORE INSERT 觸發器&amp;#39;);4、查看test_trigger_log資料表中的資料
mysql&amp;gt;SELECT*FROMtest_trigger_log;+----+---------------+|id|t_log|+----+---------------+|1|before_insert|+----+---------------+1rowinset(0.00sec)舉例2：
1、創建名稱為after_insert的觸發器，向test_trigger資料表插入資料之後，向test_trigger_log資料表中插入after_insert的日誌資訊。
DELIMITER//CREATETRIGGERafter_insertAFTERINSERTONtest_triggerFOREACHROWBEGININSERTINTOtest_trigger_log(t_log)VALUES(&amp;#39;after_insert&amp;#39;);END//DELIMITER;2、向test_trigger資料表中插入資料。
INSERTINTOtest_trigger(t_note)VALUES(&amp;#39;測試 AFTER INSERT 觸發器&amp;#39;);3、查看test_trigger_log資料表中的資料
mysql&amp;gt;SELECT*FROMtest_trigger_log;+----+---------------+|id|t_log|+----+---------------+|1|before_insert||2|before_insert||3|after_insert|+----+---------------+3rowsinset(0.00sec)**舉例3：**定義觸發器&amp;quot;salary_check_trigger&amp;quot;，基於員工表&amp;quot;employees&amp;quot;的INSERT事件，在INSERT之前檢查將要添加的新員工薪資是否大於他領導的薪資，如果大於領導薪資，則報sqlstate_value為&amp;rsquo;HY000&amp;rsquo;的錯誤，從而使得添加失敗。
DELIMITER//CREATETRIGGERsalary_check_triggerBEFOREINSERTONemployeesFOREACHROWBEGINDECLAREmgrsalaryDOUBLE;SELECTsalaryINTOmgrsalaryFROMemployeesWHEREemployee_id=NEW.manager_id;IFNEW.salary&amp;gt;mgrsalaryTHENSIGNALSQLSTATE&amp;#39;HY000&amp;#39;SETMESSAGE_TEXT=&amp;#39;薪資高於領導薪資錯誤&amp;#39;;ENDIF;END//DELIMITER;上面觸發器聲明過程中的NEW關鍵字代表INSERT添加語句的新記錄。
3. 查看、刪除觸發器 3.1 查看觸發器 查看觸發器是查看資料庫中已經存在的觸發器的定義、狀態和語法資訊等。</description>
    </item>
    
    <item>
      <title>變量、流程控制與游標</title>
      <link>https://yoziming.github.io/post/211227-agg-mysql-12/</link>
      <pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211227-agg-mysql-12/</guid>
      <description>變量、流程控制與游標  一樣先跳過了
 1. 變數 在MySQL資料庫的存儲過程和函數中，可以使用變數來存儲查詢或計算的中間結果資料，或者輸出最終的結果資料。
在 MySQL 資料庫中，變數分為系統變數以及使用者自訂變數。
1.1 系統變數 1.1.1 系統變數分類 變數由系統定義，不是使用者定義，屬於伺服器層面。啟動MySQL服務，生成MySQL服務實例期間，MySQL將為MySQL伺服器記憶體中的系統變數賦值，這些系統變數定義了當前MySQL服務實例的屬性、特徵。這些系統變數的值要麼是編譯MySQL時參數的預設值，要麼是設定檔（例如my.ini等）中的參數值。大家可以通過網址 https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html 查看MySQL文檔的系統變數。
系統變數分為全域系統變數（需要添加global 關鍵字）以及會話系統變數（需要添加 session 關鍵字），有時也把全域系統變數簡稱為全域變數，有時也把會話系統變數稱為local變數。**如果不寫，預設會話級別。**靜態變數（在 MySQL 服務實例運行期間它們的值不能使用 set 動態修改）屬於特殊的全域系統變數。
每一個MySQL客戶機成功連接MySQL伺服器後，都會產生與之對應的會話。會話期間，MySQL服務實例會在MySQL伺服器記憶體中生成與該會話對應的會話系統變數，這些會話系統變數的初始值是全域系統變數值的複製。如下圖：
 全域系統變數針對於所有會話（連接）有效，但不能跨重啟 會話系統變數僅針對於當前會話（連接）有效。會話期間，當前會話對某個會話系統變數值的修改，不會影響其他會話同一個會話系統變數的值。 會話1對某個全域系統變數值的修改會導致會話2中同一個全域系統變數值的修改。  在MySQL中有些系統變數只能是全域的，例如 max_connections 用於限制伺服器的最大連接數；有些系統變數作用域既可以是全域又可以是會話，例如 character_set_client 用於設置用戶端的字元集；有些系統變數的作用域只能是當前會話，例如 pseudo_thread_id 用於標記當前會話的 MySQL 連接 ID。
1.1.2 查看系統變數  查看所有或部分系統變數  #查看所有全域變數 SHOWGLOBALVARIABLES;#查看所有會話變數 SHOWSESSIONVARIABLES;或SHOWVARIABLES;#查看滿足條件的部分系統變數。 SHOWGLOBALVARIABLESLIKE&amp;#39;%識別字%&amp;#39;;#查看滿足條件的部分會話變數 SHOWSESSIONVARIABLESLIKE&amp;#39;%識別字%&amp;#39;;舉例：
SHOWGLOBALVARIABLESLIKE&amp;#39;admin_%&amp;#39;; 查看指定系統變數  作為 MySQL 編碼規範，MySQL 中的系統變數以兩個&amp;quot;@&amp;quot;開頭，其中&amp;quot;@@global&amp;quot;僅用於標記全域系統變數，&amp;quot;@@session&amp;quot;僅用於標記會話系統變數。&amp;quot;@@&amp;ldquo;首先標記會話系統變數，如果會話系統變數不存在，則標記全域系統變數。
#查看指定的系統變數的值 SELECT@@global.變數名;#查看指定的會話變數的值 SELECT@@session.變數名;#或者 SELECT@@變數名; 修改系統變數的值  有些時候，資料庫管理員需要修改系統變數的預設值，以便修改當前會話或者MySQL服務實例的屬性、特徵。具體方法：
方式1：修改MySQL設定檔，繼而修改MySQL系統變數的值（該方法需要重啟MySQL服務）
方式2：在MySQL服務運行期間，使用&amp;quot;set&amp;quot;命令重新設置系統變數的值
#為某個系統變數賦值 #方式1： SET@@global.變數名=變數值;#方式2： SETGLOBAL變數名=變數值;#為某個會話變數賦值 #方式1： SET@@session.</description>
    </item>
    
    <item>
      <title>預存程序Procedure與自訂函數Function</title>
      <link>https://yoziming.github.io/post/211226-agg-mysql-11/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211226-agg-mysql-11/</guid>
      <description>存儲過程與函數  就是巨集Macro啦，這部分我暫時用不到，先直接貼上筆記過眼完事了，以後有用到再回來補
 MySQL從5.0版本開始支援存儲過程和函數。存儲過程和函數能夠將複雜的SQL邏輯封裝在一起，應用程式無須關注存儲過程和函數內部複雜的SQL邏輯，而只需要簡單地調用存儲過程和函數即可。
1. 存儲過程概述 1.1 理解 含義：存儲過程的英文是 Stored Procedure。它的思想很簡單，就是一組經過預先編譯的 SQL 語句的封裝。
執行過程：存儲過程預先存儲在 MySQL 伺服器上，需要執行的時候，用戶端只需要向伺服器端發出調用存儲過程的命令，伺服器端就可以把預先存儲好的這一系列 SQL 語句全部執行。
好處：
1、簡化操作，提高了sql語句的重用性，減少了開發程式師的壓力 2、減少操作過程中的失誤，提高效率 3、減少網路傳輸量（用戶端不需要把所有的 SQL 語句通過網路發給伺服器） 4、減少了 SQL 語句暴露在網上的風險，也提高了資料查詢的安全性
和視圖、函數的對比：
它和視圖有著同樣的優點，清晰、安全，還可以減少網路傳輸量。不過它和視圖不同，視圖是虛擬表，通常不對底層資料表直接操作，而存儲過程是程式化的 SQL，可以直接操作底層資料表，相比于面向集合的操作方式，能夠實現一些更複雜的資料處理。
一旦存儲過程被創建出來，使用它就像使用函數一樣簡單，我們直接通過調用存儲過程名即可。相較於函數，存儲過程是沒有返回值的。
1.2 分類 存儲過程的參數類型可以是IN、OUT和INOUT。根據這點分類如下：
1、沒有參數（無參數無返回） 2、僅僅帶 IN 類型（有參數無返回） 3、僅僅帶 OUT 類型（無參數有返回） 4、既帶 IN 又帶 OUT（有參數有返回） 5、帶 INOUT（有參數有返回）
注意：IN、OUT、INOUT 都可以在一個存儲過程中帶多個。
2. 創建存儲過程 2.1 語法分析 語法：
CREATEPROCEDURE存儲過程名(IN|OUT|INOUT參數名參數類型,...)[characteristics...]BEGIN存儲過程體END類似於Java中的方法：
修飾符返回類型方法名(參數類型參數名,...){方法體;}說明：
1、參數前面的符號的意思
  IN：當前參數為輸入參數，也就是表示入參；
存儲過程只是讀取這個參數的值。如果沒有定義參數種類，預設就是 IN，表示輸入參數。
  OUT：當前參數為輸出參數，也就是表示出參；
執行完成之後，調用這個存儲過程的用戶端或者應用程式就可以讀取這個參數返回的值了。
  INOUT：當前參數既可以為輸入參數，也可以為輸出參數。</description>
    </item>
    
    <item>
      <title>視圖View</title>
      <link>https://yoziming.github.io/post/211225-agg-mysql-10/</link>
      <pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211225-agg-mysql-10/</guid>
      <description>視圖View  視圖 = 存儲起來的select語句
  就是創建一張專門用來看的虛擬表 涉及的表稱為基表，基表也可以是視圖(可以嵌套作圖) 對視圖進行DML操作，會影響基表中的資料，反之亦然  但通常不會在視圖對資料進行操作，並且可以指定關閉這種權限   刪除視圖不影響基表  創建視圖 CREATE[ORREPLACE][ALGORITHM={UNDEFINED|MERGE|TEMPTABLE}]VIEW視圖名稱[(欄位清單)]AS查詢語句[WITH[CASCADED|LOCAL]CHECKOPTION]-- 如果查詢基表時用了別名，那創出來的視圖欄位名稱就會是別名 createviewemployees_viewasselectlast_name&amp;#39;姓名&amp;#39;,employee_id&amp;#39;員工編號&amp;#39;fromatguigudb.employees;-- 年薪 createviewyear_salary(name,year_salary)asselectemployees.last_name,salary*12*(1+ifnull(commission_pct,0))fromatguigudb.employees;-- 多表聯合 CREATEVIEWdept_sum_vu(name,minsal,maxsal,avgsal)ASSELECTd.department_name,MIN(e.salary),MAX(e.salary),AVG(e.salary)FROMemployeese,departmentsdWHEREe.department_id=d.department_idGROUPBYd.department_name;-- 格式化輸出 CREATEVIEWemp_departASSELECTCONCAT(last_name,&amp;#39;任職於&amp;#39;,department_name,&amp;#39;ㄅ&amp;#39;)ASemp_deptFROMemployeeseJOINdepartmentsdWHEREe.department_id=d.department_id查看視圖屬性 DESC/DESCRIBE視圖名稱;-- 查看視圖的屬性資訊 SHOWTABLESTATUSLIKE&amp;#39;視圖名稱&amp;#39;;-- 查看視圖的詳細定義資訊 SHOWCREATEVIEW視圖名稱;修改視圖內的資料  一般來說不會這麼做，了解即可
  如果是一對一關係的視圖，且有權限的話，可以使用INSERT、UPDATE和DELETE語句去修改其中的資料 有以下情況則不可修改:  在定義視圖的時候指定了&amp;quot;ALGORITHM = TEMPTABLE&amp;quot;，視圖將不支援INSERT和DELETE操作 視圖中不包含基表中所有被定義為非空又未指定預設值的列，視圖將不支援INSERT操作 在定義視圖的SELECT語句中使用了JOIN聯集查詢，視圖將不支援INSERT和DELETE操作 在定義視圖的SELECT語句後的欄位清單中使用了數學運算式或子查詢，視圖將不支援INSERT，也不支援UPDATE使用了數學運算式、子查詢的欄位值 在定義視圖的SELECT語句後的欄位清單中使用DISTINCT、彙總函式、GROUP BY、HAVING、UNION等，視圖將不支持INSERT、UPDATE、DELETE 在定義視圖的SELECT語句中包含了子查詢，而子查詢中引用了FROM後面的表，視圖將不支援INSERT、UPDATE、DELETE 視圖定義基於一個不可更新視圖 常量視圖    刪改視圖 -- 修改方法1 CREATEORREPLACEVIEW視圖名稱AS-- ...查詢語句 -- 修改方法2 ALTERVIEW視圖名稱AS-- ...查詢語句 -- 刪除 DROPVIEWIFEXISTS視圖名稱小結   視圖的優點:
  簡化操作:能夠分解複雜的查詢操作</description>
    </item>
    
    <item>
      <title>限制約束Constraint</title>
      <link>https://yoziming.github.io/post/211224-agg-mysql-09/</link>
      <pubDate>Fri, 24 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211224-agg-mysql-09/</guid>
      <description>限制約束Constraint  為了資料的完整性，對表訂下的各種強制規定
 所謂資料的完整性可以體現為4個方向:
 實體完整性(Entity Integrity):同一個表中，不能存在兩條完全相同無法區分的記錄 域完整性(Domain Integrity):年齡範圍0-120，性別範圍&amp;quot;男/女&amp;quot; 參考完整性(Referential Integrity):員工所在部門，在部門表中要能找到這個部門 用戶自訂完整性(User-defined Integrity):用戶名唯一、密碼不能為空等，本部門經理的工資不得高於本部門職工的平均工資的5倍。  管理約束  在create table時添加約束:  createtabletest01(idintnotnull,namevarchar(15)notnull,emailvarchar(25)); 用alter table添加或刪除約束:  altertabletest01modifyemailvarchar(25)notnull; 查看表中約束:直接desc 表名，或:  #information_schema資料庫名（系統庫）#table_constraints表名稱（專門存儲各個表的約束）SELECT*FROMinformation_schema.table_constraintsWHEREtable_name=&amp;#39;表名稱&amp;#39;;約束的分類  根據列  單列 多列:複合約束，綜合多列的值判斷   根據作用範圍  列級:只作用於一個列，跟在列的定義之後 表級:單獨定義        位置 支持的約束類型 是否能起約束名     列級約束 列之後 支持所有語法，但不可外鍵 不可   表級約束 所有列之下 除了預設與非空不支持，其他皆可 可，但主鍵無效     根據效用:下面一一說道  NOT NULL非空  限定某列的值不能為空 一個表可以有多列分別限定非空 只能跟在某列之後，只能單獨限定該列非空，不能組合限定  例如限定id非空，而不能限定id與name只要一個非空就合格   &#39;&#39;空字串、0數值不等於null  UNIQUE唯一  限制某列的值不能重複 可以是某個列的值唯一，也能是多列組合的值唯一  例如   允許null且允許多個null 創建時若不給唯一約束命名，則預設與列名相同 MySQL會給唯一約束的列預設創建唯一索引  -- 添加列約束範例 createtabletest02(idintunique,-- 列級 namevarchar(15),emailvarchar(25),constraintuk_test02_emailunique(email)-- 表級 );-- 方式2 altertabletest02addconstraintuk_test02_nameunique(name);-- 方式3 altertabletest02modifynamevarchar(25)unique;-- 複合唯一約束範例 createtablestudent_course(idint,sidint,cidint,scoreint,uniquekey(sid,cid)-- 複合唯一 );刪除唯一約束  只能通過刪除唯一索引的方式刪除 刪除時需要指定唯一索引名，唯一索引名就和唯一約束名一樣 如果創建唯一約束時未指定名稱:  如果是單列，就預設和列名相同 如果是組合列，那麼預設和()中排在第一個的列名相同 也可以自訂唯一性約束名    -- 方法1，查看表的所有約束 select*frominformation_schema.</description>
    </item>
    
    <item>
      <title>MySQL資料類型詳述</title>
      <link>https://yoziming.github.io/post/211223-agg-mysql-08/</link>
      <pubDate>Thu, 23 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211223-agg-mysql-08/</guid>
      <description>資料類型詳述  這節為了解型的知識點，有些筆記我直接複製貼上了 康師父這節講得太細，趕時間直接看最底的結論(對應教學影片p65) 用語注意:byte = 8 bit = 字節 = 位元組  MySQL中的資料類型    類型 類型舉例     整數類型 TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT   浮點類型 FLOAT、DOUBLE   定點數類型 DECIMAL   位類型 BIT   日期時間類型 YEAR、TIME、DATE、DATETIME、TIMESTAMP   文本字串類型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT   枚舉類型 ENUM   集合類型 SET   二進位字串類型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB   JSON類型 JSON物件、JSON陣列   空間資料類型 單值:GEOMETRY、POINT、LINESTRING、POLYGON；集合:MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION     常見資料類型的屬性，如下:     MySQL關鍵字 含義     NULL 數據列可包含NULL值   NOT NULL 資料列不允許包含NULL值   DEFAULT 預設值   PRIMARY KEY 主鍵   AUTO_INCREMENT 自動遞增，適用於整數類型   UNSIGNED 無符號   CHARACTER SET name 指定一個字符集    整數類型   整數類型一共有 5 種，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</description>
    </item>
    
    <item>
      <title>資料的增/刪/改</title>
      <link>https://yoziming.github.io/post/211222-agg-mysql-07/</link>
      <pubDate>Wed, 22 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211222-agg-mysql-07/</guid>
      <description>資料的操作  常說的CRUD，引用維基百科表格
    中文 英文 意思 SQL HTTP 資料分散服務 MongoDB     增加 Create 建立 INSERT PUT / POST WRITE Insert   刪除 Delete 刪除 DELETE DELETE DISPOSE Remove   查詢 Read 讀取 SELECT GET READ / TAKE Find   改正 Update 更新 UPDATE PUT / POST / PATCH WRITE Update    新增資料  使用INSERT INTO語句  插入一條完整的資料  完整即是此筆資料包含所有欄位的意思</description>
    </item>
    
    <item>
      <title>資料庫的具體結構、創建與管理</title>
      <link>https://yoziming.github.io/post/211221-agg-mysql-06/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211221-agg-mysql-06/</guid>
      <description>資料庫的結構  所謂資料庫的具體結構層級如下:  DBMS資料庫管理系統 &amp;gt; database資料庫 &amp;gt; table表 &amp;gt; column欄位   創建database、table、column都需要自己命名  命名規則  庫名、表名不得超過30字符；變量限制為29字符 只能包含大小寫英數字與_下劃線 不可包含空格 同一DBM中庫不可重名，同一庫中表不可重名，同一表中字段不可重名 不可與關鍵字、保留字等衝突 命名與資料類型須保持一致性  常用的幾類類型:       資料類型 描述     INT 從-2^31到2^31-1的整型數據。存儲大小為 4個位元組   CHAR(size) 定長字元資料。若未指定，預設為1個字元，最大長度255   VARCHAR(size) 可變長字元資料，根據字串實際長度保存，必須指定長度   FLOAT(M,D) 單精確度，佔用4個位元組，M=整數位元+小數位，D=小數位。 D&amp;lt;=M&amp;lt;=255,0&amp;lt;=D&amp;lt;=30，預設M+D&amp;lt;=6   DOUBLE(M,D) 雙精度，佔用8個位元組，D&amp;lt;=M&amp;lt;=255,0&amp;lt;=D&amp;lt;=30，預設M+D&amp;lt;=15   DECIMAL(M,D) 高精度小數，佔用M+2個位元組，D&amp;lt;=M&amp;lt;=65，0&amp;lt;=D&amp;lt;=30，最大取值範圍與DOUBLE相同。   DATE 日期型資料，格式&amp;rsquo;YYYY-MM-DD&#39;   BLOB 二進位形式的長文本資料，最大可達4G   TEXT 長文本資料，最大可達4G     database庫的指令  必須具備相應權限</description>
    </item>
    
    <item>
      <title>子查詢Subquery</title>
      <link>https://yoziming.github.io/post/211220-agg-mysql-05/</link>
      <pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211220-agg-mysql-05/</guid>
      <description>子查詢Subquery  查中有查，以某查完的結果作為比較項目來查
  用一對()括號包起來 子查詢在主查詢之前先執行了一次 子查詢放在比較條件的右側 多行操作就對應多行子查詢  分類   依照內查詢返回的條目數:
 單行:返回一條結果 多行:返回多行結果    依照內查詢是否被執行多次:
  相關:查詢工資是否大於其部門平均(每個人部門不同，都要查各自的)
  不相關:查詢工資是否大於2000(每個人固定跟2000比較)
    單行子查詢  內查詢返回一條結果，外查詢跟這條結果比較 比較符:=等於、大小於等於、不等於 舉例:  -- 查詢薪水比&amp;#34;員工ID143號的薪水&amp;#34;還多的 selectsalary,job_id,employee_idfromemployeeswheresalary&amp;gt;(selectsalaryfromemployeeswhereemployee_id=143);-- 返回&amp;#34;job_id與141號員工相同&amp;#34;且&amp;#34;salary比143號員工多的&amp;#34; selectsalary,job_id,employee_idfromemployeeswheresalary&amp;gt;(selectsalaryfromemployeeswhereemployee_id=143)andjob_id=(selectjob_idfromemployeeswhereemployee_id=141);-- 查詢工資最少的 selectlast_name,job_id,salaryfromemployeeswheresalary=(selectmin(salary)fromemployees);-- 查詢管理人與部門ID跟編號141相同的 selectemployee_id,manager_id,department_idfromemployeeswheremanager_id=(selectmanager_idfromemployeeswhereemployee_id=141)anddepartment_id=(selectdepartment_idfromemployeeswhereemployee_id=141)andemployee_id!=141;-- 注意排除自己本身 -- 返回每個部門的最低工資，條件限制&amp;#34;比部門編號50的最低薪資&amp;#34;還高 selectdepartment_id,min(salary)fromemployeesgroupbydepartment_idhavingmin(salary)&amp;gt;(selectmin(salary)fromemployeeswheredepartment_id=50); HAVING、CASE也都可以使用 如果子查詢結果為null，那不返回任何東西 (與null比較必為null)  多行子查詢  也稱為集合比較子查詢 內查詢返回多行結果 使用多行比較操作符，因為返回很多條所以沒得等於，不然要等於哪個?     操作符 含義     IN 等於列表中的任意一個   ANY 需要和單行比較操作符一起使用，和子查詢返回的某一個值比較   ALL 需要和單行比較操作符一起使用，和子查詢返回的所有值比較   SOME 實際上是ANY的別名，作用相同，一般常使用ANY     舉例:  -- 返回其它job_id中比job_id為IT_PROG任一工資低的員工的員工號、job_id 以及salary** -- 其實相當於&amp;lt; IT_PROG中工資的max selectemployee_id,job_id,salaryfromemployeeswheresalary&amp;lt;any(selectsalaryfromemployeeswherejob_id=&amp;#39;IT_PROG&amp;#39;)andjob_id!</description>
    </item>
    
    <item>
      <title>常用函數:數值/字串/時間/流程控制...等</title>
      <link>https://yoziming.github.io/post/211219-agg-mysql-04/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211219-agg-mysql-04/</guid>
      <description>函數  日後有需要用到的函數大多可以在這裡查到
  根據輸入的資訊，返回某種結果 函數在不同的DBMS(資料庫軟體)之間的差距很大，使用時要注意移植性， 以下都是基於MySQL  常見分類  依照資料類型:數值、字符串、時間日期 依照功能:流程控制、加密解密、獲取信息 依照輸入資料的行數:單行、多行(聚合)  單行函數  對一行資料進行變換、每行返回一個結果  例如:想知道每個員工的工作年資，具體作法為現在時間減去員工入職時間，就可以調用時間相關的函數   單行函數可以嵌套使用   範例太多我就複製貼上了，先過眼了解，有用到時不熟悉再來查
 1. 數值    函數 用法     ABS(x) 返回x的絕對值   SIGN(X) 返回X的符號。正數返回1，負數返回-1，0返回0   PI() 返回圓周率的值   CEIL(x)，CEILING(x) 返回大於或等於某個值的最小整數   FLOOR(x) 返回小於或等於某個值的最大整數   LEAST(e1,e2,e3…) 返回列表中的最小值   GREATEST(e1,e2,e3…) 返回列表中的最大值   MOD(x,y) 返回X除以Y後的餘數   RAND() 返回0~1的隨機值，每次都不同   RAND(x) 返回0~1的隨機值，其中x的值用作種子值，相同的X值會產生相同的亂數   ROUND(x) 返回一個對x的值進行四捨五入後，最接近於X的整數   ROUND(x,y) 返回一個對x的值進行四捨五入後最接近X的值，並保留到小數點後面Y位   TRUNCATE(x,y) 返回數字x截斷為y位元小數的結果   SQRT(x) 返回x的平方根。當X的值為負數時，返回NULL    2.</description>
    </item>
    
    <item>
      <title>多表查詢、JOIN ON連接</title>
      <link>https://yoziming.github.io/post/211218-agg-mysql-03/</link>
      <pubDate>Sat, 18 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211218-agg-mysql-03/</guid>
      <description>多表查詢  從多張表格的查詢結果，連結彙整成一個表
 前提  需要有連接條件  沒有正確的連接條件，則會變成每個元素都相乘得出超爆量的結果，數學上稱這種集合為笛卡爾積，例如貓、狗X黑、白、黃的排列組合   正確連接舉例:員工表中有部門ID，部門表有部門ID，用其串聯顯示部門名稱  SELECTe.employee_id,d.department_id,d.department_nameFROMemployeese,departmentsdWHEREe.department_id=d.department_idORDERBYemployee_id; 如果查詢的表中，多個表都有同一字段，必須指明所在的表，此例中d.department_id就是必須指明的，否則報錯  為了提高效率與可讀性，使用字段最好都指明來源表   最好使用別名，並且一但起了別名就必須使用別名，否則報錯 當想實現N個表的多表查詢，必須至少有N-1個連接條件，例如:  SELECTe.employee_id,d.department_id,d.department_name,l.cityFROMemployeese,departmentsd,locationslWHEREe.department_id=d.department_id&amp;amp;&amp;amp;d.location_id=l.location_idORDERBYemployee_id;分類 等值 vs 非等值 -- 非等值舉例，比如在某個範圍之內 SELECTe.employee_id,e.last_name,j.grade_levelFROMemployeese,job_gradesjWHEREe.salary&amp;gt;=j.lowest_sal&amp;amp;&amp;amp;e.salary&amp;lt;=j.highest_salORDERBYemployee_id;自連接 vs 非自連接 -- 自連接舉例，將同一張表拆成2個別名 SELECTemp.employee_id,emp.last_name,mgr.employee_id,mgr.last_nameFROMemployeesemp,employeesmgrWHEREemp.`manager_id`=mgr.`employee_id`;內連接 vs 外連接  內連接:就是小時候excel用的VLOOKUP，返回的是兩個表都有匹配到的項目 外連接:返回包含不匹配的部分，又分左、右、全，還是上圖吧  當看到描述為查詢&amp;quot;所有&amp;ldquo;的XXX就要想到應該是外連接      這個用(+)實現左外連是SQL92語法，但MySQL不認，必須使用JOIN ... ON，下面詳述
  又MySQL不支援FULL OUTER JOIN，還需要關鍵字UNION輔助
  實現  這張圖基本上已經說明一切
 JOIN &amp;hellip; ON  用來取代WHERE a=b的用法 舉例:  select*fromemployeesinnerjoindepartmentsdond.department_id=employees.department_id; 通常把列數較多的放在A然後使用left join  UNION  可以合併多個SELECT的結果，前提是他們的列數與對應的數據類型相同 格式:  SELECTcolumn,.</description>
    </item>
    
    <item>
      <title>SQL語言基本關鍵字、排序與分頁</title>
      <link>https://yoziming.github.io/post/211217-agg-mysql-02/</link>
      <pubDate>Fri, 17 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211217-agg-mysql-02/</guid>
      <description>SQL  Structured Query Language，是一種通用的資料庫查詢語言
 分類  DDL:數據定義語言，定義資料庫或表本身，例如  CREATE、ALTER、DROP、RENAME、TRUNCATE   DML:數據操作語言，即增刪改查，針對的是具體的某條資料，例如  INSERT、DELETE、UPDATE、SELECT   DCL:數據控制語言，事務操作或權限控制等等，例如  COMMIT、ROLLBACK、SAVEPOINT、GRANT、REVOKE    標準  最經典的版本是SQL92與SQL99，一般也稱為SQL-2與SQL-3標準  SQL92形式簡單但語句長，難讀 SQL99版可讀性好，但語法較複雜    規則與規範   可以一行或多行，子句分行縮進增加可讀性
  每條命令用;、\G或\g結束
  標點符號
 必定成對，例如&#39;&#39;、() 必定是半形符號 字串和時間日期用&#39;&#39;單引號表示 列的別名盡量使用&amp;quot;&amp;quot;雙引號，且不建議省略as    大小寫
 Windows不分，Linux區分且規則如下:  資料庫名、表名、表別名、變數名區分 關鍵字、函數名、列名是忽略大小寫   建議規範  資料庫名、表名、表別名、字段名都用小寫 SQL關鍵字、函數名、綁定變數都大寫    註釋 單行:-- 註釋體，注意--後面有一個空格 多行:*/註釋體*/MySQL特有:#  關鍵字 SELECT  功能:查、列出 格式:  SELECT列名FROM表名;SELECT*FROM表名;-- 列出全部  FROM:來源表 FROM DUAL;返回一個偽表(暫時的)  AS  功能:暫時將返回的列名顯示成別名 格式:  SELECT列名AS&amp;#34;想顯示的別名&amp;#34;from表名;SELECT列名&amp;#34;想顯示的別名&amp;#34;from表名;-- 省略AS SELECT列名想顯示的別名from表名;-- 省略&amp;#34;&amp;#34;，但注意別名不能有空格  注意:並不是真的給某資料庫的某表某列賦了別名，只是暫時顯示來看而已  DISTINCT  功能:去重複 格式:  SELECTDISTINCT列名FROM表名;-- 聯合去重複，須滿足所有列的元素都不重複 SELECTDISTINCT列名1,列名2FROM表名;null  null不等於0 當null參與運算，結果必然也是空 解決方案:IFNULL(列名,備胎)  ‘‘單引號  注重符  功能:如果表名或字段名跟關鍵字衝突了，用其避開 格式:SELECT * FROM order;   查詢常數  功能:可以用作分隔之類的，沒多大意義 格式:    SELECTemp_no,&amp;#39;分隔&amp;#39;,first_name,&amp;#39;間隔&amp;#39;FROMemployees;DESCRIBE  功能:返回表的詳細結構與說明 格式:DESCRIBE 表名;、DESC 表名;  WHERE  功能:過濾 格式:  SELECT*FROM表WHERE條件;-- 範例 SELECT*FROMemployeesWHEREfirst_name=&amp;#39;georgi&amp;#39;; 注意WHERE必定聲明在FROM之後 MySQL中，篩字串不分大小寫  運算符號  先乘除後加減，沒特別的就不提了，與常規經驗一致</description>
    </item>
    
    <item>
      <title>MySQL簡介、環境配置、編碼與GUI</title>
      <link>https://yoziming.github.io/post/211216-agg-mysql-01/</link>
      <pubDate>Thu, 16 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211216-agg-mysql-01/</guid>
      <description>本筆記基於這份2021年11月的公開教學影片 【宋红康】MySQL数据库（安装/基础/高级/优化） https://www.bilibili.com/video/BV1iq4y1u7vj?p=1
 MySQL簡介  MySQL是開源且免費的資料庫 常用版本5.7、8.0 NoSQL為關聯式資料庫(Relational Database Management System)  想像成最傳統意義的表格，像Excel那樣 非關聯式資料庫(NoSQL)則例如以key-value形式儲存的redis    表與表的關聯關係  以下討論都是基於關聯式資料庫
 一對一   通常可以直接建成一張表，但也是有應用場景
  例如以使用頻率拆分兩表(為了降低IO讀取提高效率):
  學生常用訊息表:學號、姓名、手機、班級
  學生其他訊息表:學號、住址、身分證號、緊急聯絡人
 兩張表的學號是唯一且相同的      建表原則:
 外鍵唯一:主表的主鍵和從表的外鍵(唯一)，形成主外鍵關係 外鍵為主鍵:主表的主鍵和從表的主鍵，形成主外鍵關係    一對多  舉例:  員工表:員工編號、員工姓名、所屬部門 部門表:部門編號、部門名   建表原則:從表(多方，這裡就是員工表)創建一個字段，字段作為外鍵指向主表(一方，這裡就是部門表)的主鍵  多對多  必須創建第三張表，通常將該表稱為關聯表，此關聯表以兩個一對多關係，將兩個表的主鍵都插到第三個表中 舉例:  學生訊息表:學號、姓名 課程訊息表:課程編號、課程內容 選課訊息表(關聯表):可以看到學號與對應的課程編號，一個課程編號必定對應多個學號；一個學號也可以選有多門課程   建表原則:關聯表中至少有2個字段，分別作為外鍵個指向一方的的主鍵  自我引用   表中的某個字段指向同張表的另一個字段</description>
    </item>
    
    <item>
      <title>JDK8新特性:Lambda表達式、StreamAPI、Optional類</title>
      <link>https://yoziming.github.io/post/211215-agg-ja-30/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211215-agg-ja-30/</guid>
      <description>Lambda表達式  可以簡略表達接口的匿名函數部份
  用於函數式接口，即只有一個抽象方法的接口  因為當你使用這個接口就必定要實現這個唯一的方法，所以很多東西可以省略    結構 // 舉例 Comparator&amp;lt;Integer&amp;gt; com = (o1, o2) -&amp;gt; o1.compareTo(o2);  -&amp;gt;:Lambda符號、箭頭符號 左邊:Lambda形參列表，就是接口中抽象方法的形參列表  參數類型可以省略(類型推斷) 如果只有一個參數，可以省略()括號   右邊:Lambda體，就是重寫的方法體，應該用{}大括號包裹  如果只有一行語句，可以省略{}大括號  如果省略{}大括號也必須省略return      應用  其實不用特別去記，IDEA寫出來他就會提示自動修改了
 一. // 無參無返回 Runnable r1 = new Runnable() {  @Override  public void run() {  System.out.println(&amp;#34;hello&amp;#34;);  } }; // Lambda省略後 Runnable r1 = () -&amp;gt; System.</description>
    </item>
    
    <item>
      <title>反射Reflection、動態代理</title>
      <link>https://yoziming.github.io/post/211214-agg-ja-29/</link>
      <pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211214-agg-ja-29/</guid>
      <description>反射Reflection  反射Reflection是Java被視為動態語言的關鍵，可以在運行時獲取類的內部訊息  動態語言:程式運行時，代碼可以根據某些條件改變自身結構   具體來說，當我們加載完某類之後，在記憶體中堆的方法區就產生了一個該類的Class物件，此物件包含了完整的該類的結構訊息 因此我們能透過反射的API，從一個物件取得他所屬類的屬性與方法並進行各種操作  主要API  java.lang.Class:代表一個類 java.lang.reflect.Method:代表類的方法 java.lang.reflect.Field:代表類的成員變數 java.lang.reflect.Constructor:代表類的構造器  Class類  Class類即是&amp;quot;類的類&amp;quot;，為反射的源頭 Object類中定義了getClass()方法，此方法被所有類繼承 Class類的實例物件只能由系統建立，當一個.class檔案被JVM載入執行時系統在堆的方法區產生唯一對應的物件 通過Class物件可以完整獲取類的結構並進行各種操作，所以要使用反射必須先獲取Class物件 萬物皆物件、萬物皆有Class類  數組的話只要元素類型與維度相同，視為同一個Class，例如int[5]與int[20]    獲取Class實例物件  已知具體類名:Class clazz = String.class 已知全類名:Class clazz = Class.forName(&amp;quot;java.lang.String&amp;quot;)  可能拋出錯誤ClassNotFoundException 也可以透過ClassLoader  ClassLoader cl = this.getClass().getClassLoader() Class clazz4 = cl.loadClass(&amp;quot;全類名&amp;quot;)     已有某類的實例物件:Class clazz = obj01.getClass()  ClassLoader  補充知識點，有印象就好
 類的加載實際步驟  Load:將.class檔案讀入記憶體、創建Class物件 Link:將類的二進位數據合併到JRE中、引入常量 Initialize:初始化，執行類構造器&amp;lt;clinit&amp;gt;()方法，進行static屬性或指定初始值的賦值   如果一個類的父類還沒初始化，會先進行父類的初始化 JVM會保證&amp;lt;clinit&amp;gt;()方法在多線程環境中的加鎖與同步  加載器的分類  Bootstrap:引導類，由C語言編寫，負責Java平台核心庫，無法直接獲取 Extension:擴展類，負責載入jre/lib/ext或指定目錄下的jar包 System(APPs):系統類，負責載入java.</description>
    </item>
    
    <item>
      <title>通訊協定:URL、IP與網路編程</title>
      <link>https://yoziming.github.io/post/211213-agg-ja-28/</link>
      <pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211213-agg-ja-28/</guid>
      <description>通訊協定  物理層:網路線、電話線 網路層:IP、ICMP、ARP 傳輸層:TCP、UDP 應用層:HTTP、FTP、DNS、Telnet 一般來說所謂&amp;quot;下層&amp;quot;是越靠近物理層面的那層  網路層(IP)   InetAddress類
 實例化  getByName(String host):host可以是IP，也可以是域名再透過DNS找到IP  IP  本機:127.0.0.1或localhost 內部IP:192.168.0.0~192.168.255.255 外部IP:其他的都是   域名:www.google.com、zh.wikipedia.org&amp;hellip;等等 DNS:Domain Name System，負責找出對應的IP   getLocalHost():返回本地IP   調用  getHostName():顧名思義 getHostAddress():顧名思義      port:連接埠、端口號，每個程序各自占用的通道，介於0~65536
 公認端口:0~1023，例如:http=80、ftp=21、telnet=23 註冊端口:1024~49151，約定成俗的，例如MySQL=3306    IP+port=Socket
 Socket才是真正實現程序間網路通信的基礎 主動發起通信的為客戶端Client，等待請求的為服務端Server    傳輸層  TCP  可靠，連接時需進行三次握手:  第一次:A發給B說&amp;quot;B 在嗎?&amp;quot; 第二次:B收到並返回&amp;quot;在，我是B，請說&amp;quot; 第三次:A收到B返回的&amp;quot;請說&amp;quot;，就認為傳輸是可靠的    適合用在大量的傳輸 傳輸完需釋放連接、效率低。四次揮手:  第一次:A發給B說&amp;quot;B 我們分手吧?</description>
    </item>
    
    <item>
      <title>IO流:物件流、序列化、隨機讀寫流與NIO</title>
      <link>https://yoziming.github.io/post/211212-agg-ja-27/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211212-agg-ja-27/</guid>
      <description>標準輸出/入流  System.in:標準輸入字節流，預設是從鍵盤輸入，類型是InputStream System.out:標準輸出流，預設輸出到控制台，類型是PrintStream，繼承自FilterOutputStream，繼承自OutputStream  重定向方法  public static void setIn(InputStream in) public static void setOut(PrintStream out)  範例-讀取輸入  不使用scanner
 public static void main(String[] args) {  // 把標準輸入字節流先轉換成字符流  BufferedReader bufferedReader = null;  try {  InputStreamReader isr = new InputStreamReader(System.in);  // 把字符流用bufferedReader包起來，為了調用readline方法  bufferedReader = new BufferedReader(isr);  for (; true; ) {  System.out.println(&amp;#34;輸入要轉換成大寫的字串...&amp;#34;);  String str = bufferedReader.readLine();  if (&amp;#34;exit&amp;#34;.equalsIgnoreCase(str)) { // &amp;#34;exit&amp;#34;放前面防空指針  System.</description>
    </item>
    
    <item>
      <title>IO流:基礎、緩衝流、轉換流與Unicode編碼</title>
      <link>https://yoziming.github.io/post/211211-agg-ja-26/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211211-agg-ja-26/</guid>
      <description>File類  位於 java.io之下 File類的一個物件，代表一個實際的文件檔案或一個資料夾 File類只涉及檔案或資料夾的創建、刪除、改名&amp;hellip;等方法，只能碰到外殼；讀取或寫入需要IO流才能做到 File類的物件通常做為參數傳到流的構造器中，作為讀取或寫入的終點  實例化  構造器的幾種參數
  File(String filepath):一般路徑 File(String parentPath, String childPath):分成父目錄與子目錄，再拼接起來 File(FileA parentFile, String childPath):相當於以 FileA為父目錄下的子目錄  路徑   不指明就是相對路徑，在IDEA中若使用 JUnit單元測試位置是 Module下(與 src資料夾同層)；若 main()方法則是在 Project下
  指明則是絕對路徑，例如 &amp;quot;G:\\Java\\code\\guigu\\day26IO\\src\\hi.txt&amp;quot;
  關於正反、雙斜槓等疑惑可以參考這篇:
https://yoziming.github.io/post/211212-slash-file-name/
  File類中有一個常量 File.separator可以根據系統自動變換分隔符
  常用方法  預設以一個File類的實例物件.調用以下方法
  String getAbsolutionPath():獲取絕對路徑 String getPath():獲取相對路徑 String getName():獲取檔案名稱 String getParent():獲取上層文件夾目錄路徑(需本身是絕對路徑)，若無則返回null Long Length():獲取檔案大小，單位位元組 Long LastModified():獲取最後修改時間戳 file1.boolean renameTo(File file2):將file1搬到file2的路徑並改名成file2，必須有file1無file2(他是一個移動+改名，無法覆蓋) String[] List():獲取指定目錄下的所有資料夾名與檔案名，類似dir與ls，只適用於資料夾目錄 File[] ListFiles():獲取指定目錄下的所有資料夾與檔案的File數組，只適用於資料夾目錄 boolean isDirctory():判斷是否為文件夾 boolean isFile():判斷是否為檔案 boolean exists():判斷是否存在 boolean canRead():判斷是否能讀 boolean canWrite():判斷是否能寫 boolean isHidden():判斷是否隱藏  創建/刪除檔案  不是實例化，而是真正在硬碟中創建檔案</description>
    </item>
    
    <item>
      <title>泛型Generic</title>
      <link>https://yoziming.github.io/post/211210-agg-ja-25/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211210-agg-ja-25/</guid>
      <description>泛型Generic  泛型是JDK5新增的項目
 特性  帶泛型的結構在實例化時，可以指明具體的泛型類型，類似於貼&amp;lt;標籤&amp;gt; 指明完後，使用到類的地方全都換成該泛型 用一個比喻，我自訂一個帶&amp;lt;&amp;gt;泛型的校車類，當實例化具體的校車A時，在&amp;lt;&amp;gt;中指明上裝的都是&amp;lt;北一女學生&amp;gt;，那裝進去的就只能是北一女學生， 當我對這台校車A進行各種操作時，就不用考慮裡面人是啥種類(以前都用Object盛裝，然後操作時還要先instanceOf確認種類再強轉)，現在跟校車A牽扯的通通都是&amp;lt;北一女學生&amp;gt;不用囉嗦 承上例，我也可以實例化另一台校車B&amp;lt;建中男學生&amp;gt;。一個優勢在於我規劃校車這個類時，先不用考慮具體要裝的是啥類而用泛型，用這個泛型先寫好通用的方法，留著空給實例化時再去決定實際調用的類  使用範例 // 造一個指明泛型為Integer, String的Map HashMap&amp;lt;Integer, String&amp;gt; stringHashMap = new HashMap&amp;lt;Integer, String&amp;gt;(); stringHashMap.put(1, &amp;#34;小名&amp;#34;); stringHashMap.put(2, &amp;#34;老王&amp;#34;); stringHashMap.put(3, &amp;#34;阿洲&amp;#34;); // 此時如果想放進非Integer,String的東西則報錯  // 轉成EntrySet，叫Map.Entry是因為Entry是一個內部接口 Set&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; entries = stringHashMap.entrySet(); // 通通都自動帶入泛型，而不用再去判斷種類或強轉 // 試著遍歷 Iterator&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; iterator = entries.iterator(); while (iterator.hasNext()) {  Map.Entry&amp;lt;Integer, String&amp;gt; next = iterator.next();  Integer key = next.getKey();  String value = next.getValue();  System.out.println(key + &amp;#34;=&amp;gt;&amp;#34; + value); } 聲明  集合接口或集合類都天生帶有泛型的結構，自建的類或接口也能聲明泛型 泛型類可能有多個參數，可以都放在&amp;lt;&amp;gt;內用&amp;quot;,&amp;ldquo;隔開，例如:&amp;lt;E1, E2, E3&amp;gt; 聲明構造器時不用寫泛型 靜態方法不能使用類的泛型(因為泛型在實例化時才決定，當能不能跟static共存) 異常類不能聲明為泛型(因為它祖宗就沒有&amp;lt;&amp;gt;，繼承再怎樣都生不出來)  實例化  實例化時，指定的泛型必須是一個實際類，不能是基本數據類型(有需要就用包裝類) 泛型可以嵌套使用 帶泛型的接口或類在實例化時如果不指定泛型，就當作Object處理，但不等價於Object 要嘛一路都用泛型，要嘛都不要用  泛型方法   在方法中出現了泛型的結構，泛形參數與類的泛型無關</description>
    </item>
    
    <item>
      <title>路徑、正反斜槓與檔名的一些規則</title>
      <link>https://yoziming.github.io/post/211210-slash-file-name/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211210-slash-file-name/</guid>
      <description>正反斜槓  引用IrisAndMimi的解釋
  這個符號 「/」就是斜槓slash，呈現上右下左 而 「\」是反斜槓backslash，呈現上左下右 斜線的方向有時候容易搞混，其實只要回想一下手寫幾月幾日的時候，劃斜槓習慣往哪個方向就好了  路徑 Windows系統   只有Windows系統會用反斜槓\表達路徑，原因是上古時代DOS把正斜&amp;quot;/&amp;ldquo;當作參數命令用走了，於是就把反斜槓這個惡魔放了出來，用它表示路徑，記憶法:Windows的W第一筆畫就是\
  常見的Windows系統系統下的路徑:
  除開DOS，Windows大多數情況下，用正斜槓甚至正反斜槓混著用，也都能識別路徑
  玩日文遊戲的人可能注意過，日文的路徑是長這樣c:￥windows￥fonts￥，其實不僅日本還有韓國的₩，他們的鍵盤反斜槓\的位置就是￥與₩
    這個是編碼的歷史遺留問題，總之在日韓文系統\=￥=₩，系統會自動轉換，不用太在意
  MAC、Linux系統  不論是網址、MAC系統、Linux系統都是用&amp;rdquo;/&amp;ldquo;表達路徑   雙斜槓   //雙斜槓：協議和主機名之間的分隔符 （比如http://localhost:8080）
  \\雙反斜線 ：在windows里表示絕對地址的第一項，比如后面跟上IP地址的話，就是需要打開這個IP地址的網絡共享資源，舉例windows使用網路芳鄰會看到這樣:
  在大部分的程式語言中，把\反斜槓當作轉譯字符使用了，比如\n、\t，單用一個反斜槓很容易引起錯誤。最好還是用/正斜槓表達路徑
  檔名的大小寫規則   檔名不分大小寫:Windows系統、MAC系統
  檔名區分大小寫:Linux系統
  Git則可以自己手動設定，使用命令:
git config core.ignorecase true   資料夾的命名建議   大寫開頭的通常是系統預設的資料夾，Windows系統、MAC系統、Linux系統都有這個特性，舉例:</description>
    </item>
    
    <item>
      <title>LeetCode Easy: 14、20、21</title>
      <link>https://yoziming.github.io/post/211209-leetcode-easy-14-21/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211209-leetcode-easy-14-21/</guid>
      <description>\14. Longest Common Prefix  找最長共通前綴
  .substring(0, j) 左閉右開  public String longestCommonPrefix(String[] strs) {  // 當字符串數組長度為 0 時則公共前綴為空，直接返回  if (strs.length == 0) {  return &amp;#34;&amp;#34;;  }  // 令最長公共前綴 ans 的值為第一個字符串(&amp;#34;flower&amp;#34;)，進行初始化  String ans = strs[0];  // 與全部的字符串{&amp;#34;flower&amp;#34;, &amp;#34;flow&amp;#34;, &amp;#34;flight&amp;#34;}開始比較  for (int i = 1; i &amp;lt; strs.length; i++) {  // 從切出字符串的第一個字開始循環  int j = 0;  // 開始比較有幾位一樣，直到自己的長度，或其他字串的長度  for (; j &amp;lt; ans.</description>
    </item>
    
    <item>
      <title>集合:Map、HashMap、Collections工具類</title>
      <link>https://yoziming.github.io/post/211209-agg-ja-24/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211209-agg-ja-24/</guid>
      <description>Map Map接口:雙列數據，保存具有映射關係(key-value)成對的物件
分類  HashMap:主要實現類，線程不安全、效率高、可以存null  LinkedHashMap:遍歷時可以按照添加順序排列   TreeMap:可以按照key(必須都是同類)來排序，底層是紅黑樹 Hashtable:古老的實現類，注意t是小寫，線程安全、效率低、不能存null  Properties:常用來處理配置文件，key跟value都是String類型    結構  key:無序、不可重複的，使用Set儲存。key決定存放位置，key的所在類必須重寫equals()與hashCode() value:無序，可重複的，使用Collection儲存，value的所在類必須重寫equals() 一對key與value構成一個Entry物件，使用Set儲存，當然也是無序、不可重複的  HashMap源碼分析  以JDK7為例
  HashMap map = new HashMap();實例化時，底層創建了一個長度16的一維數組Entry[] table map.put(key1, value1);:放數據時，調用key1所在類的hashcode()方法算出哈希值，以此哈希值再經過某些位運算，得到在Entry[] table數組中的存放位置，此時:  若位置是空的，放入成功 若已經有人(可能有一個數據或鏈表)，就來比較key1跟佔位者(可能有多個，全都要比一遍)的哈希值  如果哈希值都不同，添加成功(放成鏈表) 如果key1的哈希值跟已存在的某數據(舉例為key2, value2)哈希值相同，此時再比較key1所在類的equals()方法，根據返回值:  如果equals()返回false，表示key不同只是恰好哈希值一樣，添加成功(放成鏈表) 如果equals()返回true，表示兩者key真的一樣，那就進入至尊對決，此時把put()方法理解為覆蓋，將舊的value2換成新的value1   所謂放成鏈表跟前面Set提到的一樣，類似於&amp;quot;卜&amp;quot;字的概念，從該位置延伸出去存放新的元素     擴容:超過臨界值(容量*負載因子)且要存的位置非空，就會進行擴容，預設的擴容方式為造一個新的兩倍長數組，然後將原有的複製過來  預設容量:16 預設負載因子:0.75 擴容的邏輯是這樣的，為了減少哈希碰撞(就是不希望分支的鏈表太多太長)，所以不會等他裝到滿才擴容。 假如負載因子0.9可能老是撞車導致分支很多，負載因子0.2可能一直在擴容，折衷就定負載因子為0.75效率最高    JDK8的改動  new HashMap():實例化時，底層沒有創建數組，首次調用put()方法才創建，類似懶漢式 底層數組用Node[]取代Entry[] 當數組某一個位置上的元素以鏈表形式存在的數據&amp;gt;8，且當前數組長度&amp;gt;64時，將鏈表改為紅黑樹儲存，提高查找效率  白話:分支長度&amp;gt;8且主幹長度&amp;gt;64轉紅黑樹    LinkedHashMap 繼承了HashMap的Node，但又多了before跟after兩個屬性，所以形成雙向鏈表，可以在添加時記錄前後順序</description>
    </item>
    
    <item>
      <title>集合:Collection接口、疊代器、List與Set</title>
      <link>https://yoziming.github.io/post/211208-agg-ja-23/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211208-agg-ja-23/</guid>
      <description>集合概述  集合、數組都是用來儲存多個數據(在記憶體中)的結構，簡稱Java容器 數組在聲明時長度跟數據類型就定死了，還強制是有序的，增刪改查都不變 Java集合分成兩種體系，有各種接口與實現類:  Collection接口:單列數據，用來存一個一個的物件  List接口:元素有序、可重複，又稱為&amp;quot;動態數組&amp;quot;  ArrayList LinkedList Vector   Set接口:元素無序、不可重複  HashSet LinkedHashSet TreeSet     Map接口:雙列數據，保存具有映射關係(key-value)成對的物件  HashMap  LinkedHashMap   TreeMap Hashtable  Properties        Collection Collection接口本身沒有直接的實現類，而是要通過其子類List與Set各自的實現類來完成物件的實例化
方法  用一個實現Collection接口的實例物件調用，例如:Collection coll = new ArrayList();
   add(Object e):將Object e加入集合中
  size():返回元素個數
  addAll(Collection c):將集合c的內容全加進來
  clear():清空元素，注意不是刪除集合本身，只是清掉其中的元素
  isEmpty():判定是否為空</description>
    </item>
    
    <item>
      <title>枚舉類enum、註解annotation</title>
      <link>https://yoziming.github.io/post/211207-agg-ja-22/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211207-agg-ja-22/</guid>
      <description>枚舉類(enum)  當類的物件數量是有限定的、確定的，例如:星期、性別、季節、支付方式、XX狀態 需要定義一組常量時，強烈建議使用枚舉類 如果類中只有一個物件，可以用單例模式 enum，發音&amp;quot;衣-囊&amp;quot;，名詞枚舉 enumerate，發音&amp;quot;以-new-merate&amp;quot;，動詞枚舉  自訂枚舉類  JDK 5以前
   聲明物件的屬性，用private final修飾
  將構造器私有化，給物件屬性賦上預想好的值
  在本類中預先創立好物件，用public static final修飾
  提供toSting方法
  提供其他訴求，例如:get屬性等等
  範例:
class PayMethod {  private final String name;  private final String desc;   private PayMethod(String name, String desc) {  this.name = name;  this.desc = desc;  }   public static final PayMethod CASH = new PayMethod(&amp;#34;現金&amp;#34;, &amp;#34;真金白銀&amp;#34;);  public static final PayMethod VISA = new PayMethod(&amp;#34;VISA卡&amp;#34;, &amp;#34;VISA金融卡&amp;#34;);  public static final PayMethod ONLINE = new PayMethod(&amp;#34;電子支付&amp;#34;, &amp;#34;街口支付&amp;#34;);   @Override  public String toString() {  return &amp;#34;PayMethod{&amp;#34; +  &amp;#34;name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; +  &amp;#34;, desc=&amp;#39;&amp;#34; + desc + &amp;#39;\&amp;#39;&amp;#39; +  &amp;#39;}&amp;#39;;  } }  // 調用，因為是靜態，直接類名.</description>
    </item>
    
    <item>
      <title>常用類:日期時間、比較器、其他</title>
      <link>https://yoziming.github.io/post/211206-agg-ja-21/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211206-agg-ja-21/</guid>
      <description>日期時間(JDK 8前)  提前說下，這些過時的類型跟方法實際95%用不上，了解一下就夠了
  System類中的currentTimeMillis():返回當下與1970年1月1日之間的時間差，單位毫秒  這一長串的數字稱為時間戳    java.util.Date類   創建
  使用空參構造器:創建一個當前時間的物件，格式為Wed Dec 01 13:35:20 CST 2021
  形參傳入時間戳，創建一個該時間戳的物件
    方法
 toString():顯示時間 getTime():返回時間戳    java.sql.Date類  本身是java.util.Date的子類，用來對應資料庫中的日期變量  為了區分，最好使用全類名例如:java.sql.Date d2 = new java.sql.Date(d1.getTime()); 創建:形參必須傳入時間戳 方法:  toString():顯示時間，格式只有日期，如:2021-12-01 getTime():返回時間戳     java.util.Date與java.sql.Date轉換:形參中填入getTime()即可互轉  SimpleDateFormat類   顧名思義，把Date類格式化成String用的
  創建一個形參為你想要的格式(如常見的yyyy-MM-dd hh:mm:ss)的SimpleDateFormat物件
  用此物件調用format(date物件)方法返回想要的String，舉例:
Date d1 = new Date();  SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd hh:mm:ss&amp;#34;); String s1 = sdf.</description>
    </item>
    
    <item>
      <title>常用類:String相關類與方法</title>
      <link>https://yoziming.github.io/post/211205-agg-ja-20/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211205-agg-ja-20/</guid>
      <description>String類 String類特性  表示字符串，內容以&amp;quot;&amp;quot;包裹表示，稱為字面量的定義方式 是一個final類，不可被繼承 實現了Serializable接口，可以序列化 實現了Comparable接口，表示可以比較大小 內部定義了一個final char[] value數組來實際儲存數據，代表不可變的字符序列  當我們用字面量(區別於new)定義了一個String str1=&amp;quot;abc&amp;quot;，相當於在方法區的字符串常量池中新增了一個&amp;quot;abc&amp;quot;序列，其為不可變的 字符串常量池中不會儲存內容相同的字符串，比如我再新增一個str2=&amp;quot;abc&amp;quot;，則他們指向同一地址。  延伸str6=&amp;quot;a&amp;quot;+&amp;quot;bc&amp;quot;，在聲明時字面量相加，等於常量跟常量拼接，都是在常量池，所以指向同樣位置   而當我把str1=&amp;quot;hello&amp;quot;，或是用+拼接了其他內容，或是用replace取代了其中某一位的字，都是在常量池重新開闢空間，所謂不可變是這個意思   如果是用String str3=new String(&amp;quot;abc&amp;quot;);方法生成，則是創在堆中，str3本身是指向堆的地址，去比==都是false。這個動作實際開闢了2個記憶體空間，它在堆中的value才指向常量池  如果是new一個構造器生成時賦予的name傳入形參則跟new String是不同的，傳入形參也是類似於字面量的方法(因為顯然多在堆中開闢位置是毫無必要的) 若是用+拼接有任何涉及到變量的，例如str4=str1+&amp;quot;def&amp;quot;，都是相當於在堆空間new的操作，==去比較時全都false 但如果變量被final修飾(正常不會有人這麼做)，相當於這個變量存在常量池，又會是常量跟常量拼接，所以指向同樣位置 若是用intern()方法，例如str5=str1.intern();，返回值是在常量池中，==比較是true    面試題-判斷結果 public class StringTest {  String str = new String(&amp;#34;good&amp;#34;);  char[] ch = {&amp;#39;t&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;};   public void change(String str, char[] ch) {  str = &amp;#34;bad&amp;#34;;  ch[0] = &amp;#39;b&amp;#39;;  }   public static void main(String[] args) {  StringTest ex = new StringTest();  ex.</description>
    </item>
    
    <item>
      <title>多線程:安全&amp;通信、Callable接口與線程池</title>
      <link>https://yoziming.github.io/post/211204-agg-ja-19/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211204-agg-ja-19/</guid>
      <description>線程安全 線程的生命週期 Thread.State類中定義了:
 新建:Thread類的物件被創建 就緒:start()後等待分配CPU資源的階段，可能是獲取了同步鎖、被notify() 運行:拿到實際資源、開始執行run()方法 阻塞:被暫時掛起，可能是sleep()或是被join()、或等待同步鎖、wait() 死亡:跑完或提前stop()、出錯了  同步代碼塊   解決多線程安全問題
  格式:
synchronized (同步器) { // 需要同步的代碼 }   同步器可以是任何物件，只需要滿足&amp;quot;它是多個線程共用的&amp;quot;，比如同類中的一個變量
 若是靠實現Runnable接口方法的多線程，可以用this，因為只有一個該類，當前對象是同一個 如果是繼承類實現的多線程，則可以用static變量，或是考慮&amp;quot;類名.class&amp;quot;(這玩意也是唯一的)    但這樣做實質等於單線程了，效率不高
  同步方法   解決多線程安全問題
  舉例:
public class SynTest implements Runnable {  int ticket = 100;   @Override  public void run() {  show();  }   private synchronized void show() {  for (; ticket &amp;gt; 0; ) {  try {  Thread.</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA Live Templates</title>
      <link>https://yoziming.github.io/post/211203-idea-live-templates/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211203-idea-live-templates/</guid>
      <description>IntelliJ IDEA Live Templates  盤點IDEA中Tab的實用招式，再配上alt+insert就能橫著走了
 基本聲明 psvm或main ▶ main 方法  st ▶ String  prsf ▶ private static final  psf ▶ public static final  psfi ▶ public static final int  psfs ▶ public static final String 創立物件 類名.new ▶ new 類名()  new 類名().var或.val ▶ 類 物件名 = new 類();  new 類名().field ▶ 在方法外聲明一個成員變量，並在這裡初始化一個 print sout ▶ System.out.println();  souf ▶ System.out.printf(&amp;#34;&amp;#34;);  &amp;#34;say something&amp;#34;.</description>
    </item>
    
    <item>
      <title>多線程:基礎、Thread類、用法</title>
      <link>https://yoziming.github.io/post/211203-agg-ja-18/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211203-agg-ja-18/</guid>
      <description>多線程 名詞解釋    英文 台灣 中國 意義     Program 程式 程序 靜態的程式碼集合   Process 程序(進程) 進程 動態、被執行中且載入記憶體的program，也是 OS 分配資源的最小單位。打開工作管理員看到的就是這個   Thread 執行緒 線程 一個進程裡至少會有一個線程，表示內部的一條執行路徑。把進程比喻為一個工廠，線程則是工廠裡面的工人，負責任務的實際執行。同一個Process內的Thread使用相同的Memory Space，但這些Thread各自擁有其Stack。換句話說，Thread能透過reference存取到相同的Object，但是local variable卻是各自獨立的。白話:共享方法區跟堆，獨立棧跟計數器   Coroutine 協程 協程 輕量級的執行緒，由使用者掌控，例如GO的goroutine   Concurrent 並行 並發 一個 CPU 會去做多件事，但是同一個時間點之內只會做一件事，像是早上做 Job1、下午做 Job2、晚上做 Job3不斷的切換，目標是希望能做更多的事   Parallel 平行 並行 多個 CPU 在同一個時間點內會去做多件事，例如會有三個人同時分別在做 Job1、Job2、Job3 的事情。目標是希望能把事情更快速的做完。    需求來源  希望同時執行複數的任務，例如一邊執行main方法，GC一邊收垃圾 需要等待的狀況，例如等用戶輸入、等IO、等網路連接  Java多線程-方法一   造一個類，繼承Thread</description>
    </item>
    
    <item>
      <title>項目練習3-開發團隊調度系統</title>
      <link>https://yoziming.github.io/post/211202-agg-ja-17/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211202-agg-ja-17/</guid>
      <description>項目練習3-開發團隊調度系統  雖然不是特別難，實做一遍還是會遇到不少坑，以下個人復盤的筆記
  A類中用到B類的物件，引包後可以直接&amp;quot;private B類 物件名=new B類();&amp;ldquo;一個預設的來用 忽略大小寫可用equalsIgnoreCase 繼承的子類重複用到結構類似的方法，提取出相同因子在父類做一個public的然後去子類各自重寫，也能用來解決孫子super不到爺爺的困境 遍歷時注意.length的長度是在數組建立時就定死了，絕對不等於當前數組內的元素個數，如果遍歷.length有可能去遍歷到後面null的指針而報錯 單純只是想遍歷最好用foreach 手動複製數組使用System.arraycopy 方法形參是父類，想篩選傳進來的是否為某具體子類，用if(!(物件 instanceof 子類))可以優雅的判斷 switch-case如果沒有return記得break  </description>
    </item>
    
    <item>
      <title>利用bat一鍵更新HugoBlog</title>
      <link>https://yoziming.github.io/post/211201-blog-one-key-update/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211201-blog-one-key-update/</guid>
      <description>一鍵更新  透過.bat批次執行檔，一鍵打包+發布
  首先要安裝git用來推送，這個很基本就不多說 接著要有權限，讓本機電腦的git可以連上遠端的github的個人倉庫並允許上傳 具體作法是在本機電腦生成一個key(一串暗號)，然後到個人的github網頁上設定，約好拿這個key來的人就允許上傳，步驟如下:  生成本機key  隨便開一個cmd，輸入ssh-keygen後enter執行，開始產生金鑰，沒有想特別設定的可以無腦enter  $ ssh-keygen # 產生金鑰 Generating public/private rsa key pair. Enter file in which to save the key : # 金鑰存放路徑，預設會放到我的文件/.ssh # 放哪不是特別重要，有強迫症可以自己改，否則直接按Enter Enter passphrase (empty for no passphrase): # 密碼，可設定可不設定，設定的話每次上傳會多需要輸入一次密碼 Enter same passphrase again: # 再輸入一次密碼 The key fingerprint is: # 之後會顯示你的 fingerprint，到這裡就完成 key 的產生了 將key報備到專案  到生成的路徑，找id_rsa.pub，右鍵筆記本編輯打開，會看到很長一行開頭是&amp;quot;ssh-rsa &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&amp;quot;，全選複製   回你的github專案   內容貼上剛剛複製的那行 自己給這個key起個名，懶得命名可以取剛剛那串最尾的&amp;quot;使用者@電腦&amp;quot;當名稱 記得勾選允許push  建立批次執行檔 起一個.</description>
    </item>
    
    <item>
      <title>異常處理:try-catch、finally與throws</title>
      <link>https://yoziming.github.io/post/211201-agg-ja-16/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211201-agg-ja-16/</guid>
      <description>異常的分類 在Java中，程序執行中的異常分為Exception與Error，他們都繼承自Throwable
(語法錯誤跟邏輯錯誤那不叫異常)
Error   錯誤，JVM系統內部錯誤虛擬機無法解決的問題、資源耗盡等嚴重情況，比如:
  無限迴圈產生堆疊溢位(Stack Overflow)
  寫錯分配導致記憶體不足(Out-Of-Memory)，
    解決方法就是把它寫對
  Exception   例外，發生了出乎預料的事，又依&amp;quot;受不受檢&amp;quot;分成
  Checked Exception:又稱編譯時異常，通常在原始碼中必須顯式地catch並且處理，比如:
  IOException、讀取文件不存在
  ClassNotFoundException
  這部分在compile time就會檢查
    Unchecked Exception:又稱RuntimeException，運行時異常，比如:
 NullPointerException，空指針訪問 ArrayIndexOutOfBoundsException，數組角標越界 ClassCastException，類型轉換異常 NumberFormatException，數字類型不合 InputMismatchException，輸入數據不符合，例如scan int結果來了字串 ArithmeticException，算法異常，例如把某數除以0 通常是透過撰寫相應程式以避免的邏輯錯誤, 可以根據當下的情境來判斷是不是要catch    異常處理 代碼執行時，一旦出現異常，就會在異常處生成一個對應異常類的物件，並將其拋出，拋出後的代碼就不再執行
try-catch   格式:
try {  int num = Integer.</description>
    </item>
    
    <item>
      <title>抽象abstract、接口interface、內部類</title>
      <link>https://yoziming.github.io/post/211130-agg-ja-15/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211130-agg-ja-15/</guid>
      <description>抽象abstract  隨著繼承不斷疊代，子類越來越具體，而父類越來越通用。
類的設計必須保證子類與父類共有特徵，有時候我們將父類設計得非常抽象，以至於它沒有具體的實例，這樣的類稱為抽象類。
 定義  abstract屬於Java中的關鍵字，可以用來修飾類與方法，以下分別說明  abstract修飾類  此類不能實例化 必定有構造器被繼承 開發中都會提供抽象類的子類，讓子類形成實例來調用 不能修飾final類，final類規定不能被繼承，玩毛線  abstract修飾方法  稱為抽象方法，只有聲明，沒有方法體 (就沒要讓你具體用) 此方法不能被調用 包含抽象方法的類，必定是一個抽象類。反之抽象類不一定要有抽象方法 實際開發中的調用必須是被子類繼承後重寫，所有的抽象方法都被重寫後此子類才能實例化(否則，存在繼承來的抽象方法你就是個抽象類) 不能修飾私有private方法，因為抽象就是為了被繼承，抽象與其矛盾 不能修飾靜態static方法，靜態方法跟類共存亡，可以直接被類調用，通常是去弄靜態屬性的，抽象與其矛盾 不能修飾final方法，final方法規定是不能被重寫，抽象與其矛盾  應用-模板方法設計 在軟體開發中，實現某種功能時，整體中很固定、通用的方法，在父類中就寫好了；而其他不確定、易變的就先抽象起來，交給子類去實現
匿名子類的匿名對象  在一次性使用的場合，不想實際造一個匿名類的實體子類，可以在new 匿名類()後面接{}，{內直接重寫方法，範例:
 abstract public class Person {  abstract public void work(); } public class Student extends Person {  @Override  public void work() {  System.out.println(&amp;#34;學生讀書&amp;#34;);  }   public static void main(String[] args) {  method(new Student());  method(new Person() {  @Override  public void work() {  System.</description>
    </item>
    
    <item>
      <title>關鍵字:static/main/final、代碼塊與單例模式</title>
      <link>https://yoziming.github.io/post/211129-agg-ja-14/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211129-agg-ja-14/</guid>
      <description>關鍵字static  意義:靜態的，類中共用的，生命週期跟隨類的 使用對象:屬性、方法、內部類、代碼塊，以下分別說明  使用static修飾屬性   稱為&amp;quot;靜態變量&amp;quot;或&amp;quot;類變量&amp;quot;
  先複習關於變量的知識
   實例變量是每個造出來的物件各自有的，比如:大明跟小明各自的age不同 類變量是整個類共用的，比如:大明跟小明的nation都是TW  類變量隨著類的加載而加載，可以通過&amp;quot;類.靜態變量&amp;quot;進行調用 物件沒創建之前類變量就已經存在 由於類只會加載一次，靜態變量在記憶體中也只存在一份，位於方法區的靜態域   在哪應用靜態屬性:  類中共用的，生命週期跟隨類的  舉例:構造器中自動生成編號的基數(比如從1001開始、1002..)   常量也常聲明為static，再加上final修飾  舉例:Math.PI      使用static修飾方法  稱為靜態方法，規則大致與上面相同 隨著類的加載而加載，可以通過&amp;quot;類.靜態方法&amp;quot;進行調用 不能在靜態方法中調用非靜態的屬性或方法(畢竟沒有物件) 在靜態方法中，不能使用this或super關鍵字(物件都沒出生當然不能用) 在哪應用靜態方法:  操作靜態屬性的方法，通常設為靜態 工具類的方法，比如Math、Array、Collections    單例(singleton)設計模式   定義:整個系統中，強制某個類只存在一個實例，減少資源消耗
  應用場合:
 網站的計數器，只造一個，不然難以同步 日誌:通常是一個日誌文件一直被開著，最好只有一個實例去操作它 資料庫的連接池 Windows的Task Manager跟Recycle Bin也是很典型的單例    &amp;ldquo;餓漢式&amp;quot;實現:
  私有化的構造器</description>
    </item>
    
    <item>
      <title>多態:關鍵字instanceof、Object類與包裝類</title>
      <link>https://yoziming.github.io/post/211128-agg-ja-13/</link>
      <pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211128-agg-ja-13/</guid>
      <description>多態性  類似go接口的概念，就是為了讓子類能調用父類的方法
白話:為了實現代碼的通用性
   一個事物的多種形態
  父類的引用指向子類的物件(子類的物件賦給父類的引用)，舉例:
Father obj = new Child();   使用:虛擬方法調用，編譯期只能調用父類中聲明的方法，但運行時執行的是子類重寫父類的方法。多態只有在運行那一個才知道要調用哪個方法，即多態是個運行時行為，又稱為動態綁定
 白話:編譯看左，運行看右    前提:類的繼承關係、方法的重寫，缺一不可
  目的:避免重複寫很多重載的方法
  體現:
  舉例`Person`類 之下有子類 `Chinese`、`Japanese`、`American` `Person`類有`welcome`方法，被各自子類以該國語言重寫過 我的某功能調用`welcome`時能接受`Person`類，依照實際子類物件呈現不同語言的`welcome`結果 該功能即不需要`Chinese`、`Japanese`、`American`都寫一次   public class Atest {  public static void main(String[] args) {  Atest test = new Atest();  test.func(new Dog()); // 多態體現在這  }   public void func(Animal animal) { //Animal animal=new Dog();  animal.</description>
    </item>
    
    <item>
      <title>繼承:方法重寫、關鍵字super與物件實例化過程</title>
      <link>https://yoziming.github.io/post/211127-agg-ja-12/</link>
      <pubDate>Sat, 27 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211127-agg-ja-12/</guid>
      <description>繼承 目的  減少代碼冗餘、提高復用性 便於功能擴展 為多態鋪路  格式 class A extends B{} // A延展了B A:子類、派生類、subclass B:父類、超類、基類、superclass 繪圖時，通常用空心箭頭從子指向父，例如:Student→Person，表示學生類繼承了人類
特性  A繼承B之後，子類A就獲取了B聲明的所有屬性與方法，包含了私有(private)的，但是由於封裝性的影響，子類無法直接調用父類私有(private)的屬性與方法 不允許多重繼承(一人只能有一個老爸) 可以多層繼承(允許有孫子，孫子也會繼承爺爺的特性) 一個父類可以有多個子類(允許家族開枝散葉) 所有類都繼承自java.lang.Object，換言之所有類都具有Object類的特性  權限修飾符protected的應用  之前提過protected的範圍是不同包的子類也能用，就是應在這了  實際發開中用的比較少一點    方法的重寫   子類繼承父類後，對父類同名同參數的方法，進行覆蓋
  子類重寫的方法權限修飾符必須不小於父類被重寫的方法
 白話:不能把公車私有化，權限範圍不能縮小 注意:不能重寫父類中聲明為private的方法(本身就見不到)，可以在子類中硬寫一個同名的方法，但那就不是構成重寫    若父類被重寫的方法返回值是void，子類重寫的方法也必須返回void
  若父類被重寫的方法返回值是A類型，子類重寫的方法返回值可以是A類或A類的子類
 舉例:父類返回值是動物類，子類可以重寫返回動物類或貓類狗類    若父類被重寫的方法返回值是基本數據類型，子類重寫的方法返回值必須是相同基本數據類
 舉例:父類返回double子類也必須是double，不能是int期待他自動類型提升    拋出異常(throws)的規則與返回值相同
  以上白話小結:權限不能小於爸爸、返回值不能大於爸爸
  補充:子類與父類同名同參數的方法要嘛都聲明為非static的(考慮重寫)，要嘛都聲明為static的(不是重寫，靜態類的方法不能被覆蓋)
  關鍵字super 用來表示父類中的屬性、方法、構造器</description>
    </item>
    
    <item>
      <title>項目練習2-客戶訊息管理系統</title>
      <link>https://yoziming.github.io/post/211126-agg-ja-11/</link>
      <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211126-agg-ja-11/</guid>
      <description>項目練習-客戶訊息管理系統  有點基礎這部分都蠻簡單的
 有個知識點是這邊在&amp;quot;刪除用戶&amp;quot;的功能用到了循環鏈表的概念
public boolean deleteCustomer(int index) {  if (customers[index] != null) {  for (int i = index; i &amp;lt; total - 1; i++) { // 不能搬到total，否則[i+1]會越位  customers[i] = customers[i + 1];  }  customers[total - 1] = null;  total--;   System.out.println(&amp;#34;刪除用戶成功!&amp;#34;);  return true;  }  System.out.println(&amp;#34;索引無效，操作失敗&amp;#34;);  return false; } total表示當前數組中用戶總數，這個i &amp;lt; total - 1蠻關鍵的，我原先沒想到這邊要-1，還想著讓他把後面的null往前搬就好，沒考慮到末尾可能會越位的情況。
搬完再跟customers[total - 1] = null搭配使用，這樣才是健壯的</description>
    </item>
    
    <item>
      <title>封裝性、構造器、關鍵字this、Package包</title>
      <link>https://yoziming.github.io/post/211125-agg-ja-10/</link>
      <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211125-agg-ja-10/</guid>
      <description>封裝的設計思想   高內聚:類的內部數據操作細節自己完成，不允許外部干涉
  低耦合:對外露出少量的方法(API)供使用
   舉例:微波爐，我不需要用戶控制燈光、波照、轉盤等等，只要他放入東西按下&amp;quot;解凍&amp;quot;即可。即所謂的&amp;quot;一鍵XX&amp;quot;功能。
 封裝性的體現  將類的屬性私有化(private)，通過公共的(public)的set與get方法讓外部調用，舉例:  public class Main {  public static void main(String[] args) {  Animal a1 = new Animal();  a1.setAge(10);  System.out.println(a1.getAge());  } }  class Animal {  private int age;   public void setAge(int i) {  age = i;  }   public int getAge() {  return age;  } }  不對外公開的私有方法(比如對外是各種排序方法，內部自己寫了一個交換兩數據位置的&amp;quot;小工具&amp;quot;) 單例模式(將構造器私有化) &amp;hellip;等等 需要權限修飾符來配合  權限修飾符  JAVA中有4種權限修飾符，各自的範圍是: (從小到大，下包含上)</description>
    </item>
    
    <item>
      <title>物件導向:方法的重載與參數的值傳遞</title>
      <link>https://yoziming.github.io/post/211124-agg-ja-09/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211124-agg-ja-09/</guid>
      <description>細說方法 方法的重載(overload)  定義:同一各類中，允許存在一個以上的同名方法，只要他們的參數個數或參數類型不同即可 跟方法的權限修飾符、返回值類型、形參變量名、方法體無關，判斷重點在於參數本身 可能會自動類型提升，舉例:傳入的是int形，方法中沒有int但有double，就會調用double 典型的例子就是內建的println()  可變個數形參  格式:方法名(形參類型 ... 形參名) 調用時傳入的形參數量可以是0到多個，包含數組 與本類中方法名相同，形參不同的方法間構成重載(可共存) 與本類中方法名相同，形參類型也相同的數組之間不構成重載(不可共存)  PS.這是歷史遺留問題，因為可變個數形參是JDK5加入的，以前都是用數組   方法內把它當作數組使用，遍歷itar (i=0;i&amp;lt;形參名.length;i++){} 必須聲明在末尾，且最多只能有一個  方法參數的值傳遞 先複習一下變量的賦值規則  變量是基本數據類型(byte、short、int、long、char、float、double、boolean)，賦值的是變量所保存的數據值 變量是引用類型(引用類型就只有null跟地址值兩種情況)，賦值給的是所保存數據的地址值  名詞解釋  形參:方法定義時，聲明的小括號中的參數 實參:方法調用時，實際傳給形參的數據  傳參規則  跟變量的賦值規則其實相同
  如果參數是基本數據類型，實參賦給形參的是數據值(類似給一份副本) 如果參數是引用類型，實參賦給形參的是地址值(包含變量的數據類型)  陷阱題  println在char[]這有個特例，要避免踩坑就是調用時多看看方法格式
 int[] arr1 = new int[]{1, 2, 3}; System.out.println(arr1); // [I@1b6d3586 char[] arr2 = new char[]{&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;}; System.out.println(arr2); // abc 練習-在方法中引用其他類的方法並調用 public class Main {  public static void main(String[] args) {  PassObject t1 = new PassObject();  Circle c = new Circle();  t1.</description>
    </item>
    
    <item>
      <title>物件導向:基本概念與學習路線</title>
      <link>https://yoziming.github.io/post/211123-agg-ja-08/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211123-agg-ja-08/</guid>
      <description>物件導向  Object-oriented programming中國翻為&amp;quot;面向對象&amp;quot;，台灣則翻為物件導向
我個人也覺得&amp;quot;物件導向&amp;quot;翻的比較信雅達，可以參考這篇知乎問答的解釋
https://www.zhihu.com/question/22515658/answer/120754062
 概念 首先用咖啡機煮咖啡為例:
過程導向(Process-oriented)  過程導向強調的是功能行為，以函數為最小單位，考慮如何做
   執行加咖啡豆方法
  執行加水方法
  執行煮咖啡方法
  執行喝咖啡方法
  物件導向(Object-oriented)  物件導向則是先將功能封裝進物件，強調具備功能的物件，以類/物件為最小單位，考慮誰來做
 在執行煮咖啡操作前要抽象出：人和咖啡機（分類），然後開始執行：
  人.加咖啡豆
  人.加水
  咖啡機.煮
  人.喝咖啡
  物件導向的三大特徵  封裝(Encapsulation) 繼承(Inheritance) 多態(Polymorphism)  類和實例 類(class):抽象的模板、概念上的定義
物件(object):是實際存在的個體，也稱為實例(Instance)
 比如說有輪子、吃汽油跑的是汽車類。小弟的車new march則為實例
 類的設計  設計類其實就是設計類的成員
 屬性(field):成員變量，又稱域、字段、欄位
行為(method):成員方法，又稱函數
舉例:汽車類的屬性有輪子大小、有品牌名稱；汽車的行為有吃汽油跑
練習-在JAVA創建類並實例化 class Car {  // 屬性  String brand;  String owner;  boolean isNew = true; // 可以給預設值   // 行為(方法)  public void crash() {  if (isNew) {  System.</description>
    </item>
    
    <item>
      <title>數組:填值/複製/查找/排序、Arrays工具類</title>
      <link>https://yoziming.github.io/post/211122-agg-ja-07/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211122-agg-ja-07/</guid>
      <description>數組常用算法 數據結構  程序=數據結構+演算法
  數據間的邏輯關係:集合、一對一、一對多、多對多 數據的儲存結構:  線性表:順序表(如:數組)、鏈表、棧、隊列 樹形結構:二叉樹 圖形結構    演算法-Algorithm   排序
  檢索
  加密
  &amp;hellip;
  練習題-帕斯卡三角  形狀不是很漂亮
 int[][] arr = new int[10][]; for (int i = 0; i &amp;lt; arr.length; i++) {  arr[i] = new int[i + 1];  // 兩外邊都是1  arr[i][0] = 1;  arr[i][i] = 1;  if (i &amp;gt; 1) {  for (int j = 1; j &amp;lt; arr[i].</description>
    </item>
    
    <item>
      <title>數組Array</title>
      <link>https://yoziming.github.io/post/211121-agg-ja-06/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211121-agg-ja-06/</guid>
      <description>數組Array  多個相同類型的數據按一定的順序排列的集合
 結構  數組名 元素 下標aka角標/索引 長度(元素的個數)  特性  數組本身是引用數據類型，其中的元素可以是任何類型 數組的排列是有序的 在記憶體中開闢一整塊連續的空間，數組名引用的是這塊連續空間的首地址 長度確定後就不可更改  聲明與初始化  數組必須初始化才能使用
  方法1-靜態初始化，創建時填入已知的元素內容，由系統判定長度  int[] array1; // 聲明 array1 = new int[]{1, 2, 3}; // 靜態初始化:同時對元素賦值了 // 也可以合併成 int[] array1 = new int[]{1, 2, 3}; // 可以再縮寫成 (類型推斷) int[] array1 = {1, 2, 3};  方法2-動態初始化，創建時填入已知的長度，元素內容為0或空(系統預設，後述)  int[] array3 = new int[3]; // 動態初始化，注意後面的[5]是指長度 訪問數組內的元素  沒特別的，一樣從0~長度-1。長度=array.length
 舉例:array[0]、array[1]&amp;hellip;array[array.length-1]</description>
    </item>
    
    <item>
      <title>台灣人常唸錯的IT英文單字</title>
      <link>https://yoziming.github.io/post/211120-it-english-taiwanese-problems/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211120-it-english-taiwanese-problems/</guid>
      <description>台灣人常唸錯的IT英文單字  非母語有一些口音在所難免，我不求最正宗的發音，但至少不太要離譜甚至產生歧意，畢竟能夠順利溝通交流才是最重要的
 cache，錯誤&amp;quot;catch&amp;quot;，正確它和&amp;quot;cash&amp;quot;同音
archive，錯誤&amp;quot;阿起府&amp;quot;，正確&amp;quot;阿-凱f&amp;quot;，f幾乎不發音
SQL，錯誤&amp;quot;circle&amp;quot;，正確&amp;quot;see-qual&amp;quot;
hidden，錯誤&amp;quot;嗨-等&amp;quot;，正確&amp;quot;he-等&amp;quot;
suite，錯誤&amp;quot;訴-特&amp;quot;，正確&amp;quot;sweet&amp;quot;，發音相同都是swēt
virtual，錯誤&amp;quot;V-糗&amp;quot;，正確&amp;quot;ver-秋歐&amp;quot;，虛擬的
visual，正確&amp;quot;V-九歐&amp;quot;，視覺的，微軟的Visual Studio Code是這個
mobile，錯誤&amp;quot;哞比歐&amp;quot;，正確&amp;quot;ㄇㄡ-ㄅㄛˇ&amp;quot;，英式&amp;quot;哞百歐&amp;quot;
maintain，man-ten，動詞維護
maintenance，名詞維護，正確&amp;quot;咩-特-ㄋㄜˇ-死&amp;quot;4個音，重音在特
module，正確&amp;quot;媽-九&amp;quot;
enum，正確&amp;quot;衣-囊&amp;quot;，名詞枚舉
enumerate，正確&amp;quot;以-new-merate&amp;quot;，動詞枚舉
annotation，正確&amp;quot;A-ㄋ-tation&amp;quot;，名詞註解
Azure，正確&amp;quot;阿九兒&amp;quot;，連一起速念
parameter，錯誤&amp;quot;怕拉-咪特&amp;quot;，正確&amp;quot;ㄆ˙-ㄌㄩㄝ-ㄇ˙-ter&amp;quot;4個音，第一是輕聲ㄆ，重音在第二個音節
separator，正確&amp;quot;ㄙㄟ-ㄆ˙-蕊特&amp;quot;，第二是輕聲ㄆ，重音在第三音節
error，錯誤&amp;quot;ㄟ摟&amp;quot;，正確&amp;quot;ㄟ-惹&amp;quot;
local，正確&amp;quot;low-口&amp;quot;
locale，正確&amp;quot;low-考&amp;quot;，不要混為一音
route，正確&amp;quot;辱-特t&amp;quot;
router，錯誤&amp;quot;ㄖㄠ-特&amp;quot;，正確&amp;quot;ㄖㄨ-特er&amp;quot;
servlet，&amp;ldquo;serv-let&amp;rdquo;，重音在let
admin，錯誤&amp;quot;噁的命&amp;quot;，正確&amp;quot;A的-敏&amp;quot;
format，錯誤&amp;quot;否-妹t&amp;quot;，正確&amp;quot;F歐-美t&amp;quot;
Period，正確&amp;quot;P-re-诶&amp;quot;
copy，錯誤&amp;quot;摳比&amp;quot;，正確&amp;quot;咖痞&amp;quot;
lambda，正確&amp;quot;ㄌ一ㄢ-打&amp;quot;
image，錯誤&amp;quot;一美舉&amp;quot;，正確&amp;quot;一米舉&amp;quot;
Algorithm，正確&amp;quot;凹狗-rithm&amp;quot;
width，錯誤&amp;quot;wide&amp;quot;，正確&amp;quot;with&amp;quot;，當作d不存在
lock，錯誤&amp;quot;肉可&amp;quot;，正確&amp;quot;辣可&amp;quot;
query，錯誤&amp;quot;誇-李&amp;quot;，正確&amp;quot;ㄎㄨㄧ-ㄜˇ-ry&amp;quot;3音連速念
confirm，錯誤&amp;quot;康鳳&amp;quot;，正確&amp;quot;ken-firm&amp;quot;，firm=&amp;ldquo;份兒&amp;quot;連念。這是認證、確認的意思
conform，錯誤&amp;quot;康鳳&amp;rdquo;，正確&amp;quot;ken-form&amp;quot;。這是符合的意思，兩字常常誤用誤念
register，錯誤&amp;quot;re-季-ster&amp;quot;，正確&amp;quot;ㄌㄩㄝ-幾-ster&amp;quot;
Arduino，正確&amp;quot;阿督衣no&amp;quot;
result，錯誤&amp;quot;re-造&amp;quot;，正確&amp;quot;re-奏特&amp;quot;，奏特連念
chrome，錯誤&amp;quot;恐龍米&amp;quot;，正確&amp;quot;窟窿&amp;quot;連念到近乎一個音
null，有些人念&amp;quot;怒偶&amp;quot;，正宗應為&amp;quot;鬧&amp;quot;、或&amp;quot;NO&amp;quot;，但這跟區域有關係，就算誤念成nil大概也能懂，不用太強求
record，做名詞紀錄時，正確&amp;quot;ㄌㄩㄝ-渴d&amp;quot;，d幾乎不發音
record，做動詞紀錄時，正確&amp;quot;re-扣d&amp;quot;，規律幾乎都是名詞重音在前，動詞重音在後
resume，做名詞履歷時，正確&amp;quot;ㄌㄩㄝ-su-美&amp;quot;，重音在前
resume，做動詞恢復時，正確&amp;quot;re-zoom&amp;quot;，重音在後
modem，錯誤&amp;quot;某店&amp;quot;，正確&amp;quot;ㄇㄡ-等&amp;quot;
cancel，正確&amp;quot;ken-叟&amp;quot;，取消
cancer，正確&amp;quot;ken-ser&amp;quot;，癌症，兩字常常誤用誤念
guarantee，正確&amp;quot;ㄍㄟ-掄-替&amp;quot;
standard，錯誤&amp;quot;stan-打&amp;quot;，正確&amp;quot;stan-得兒&amp;quot;
execute，正確&amp;quot;ㄟ-ser-cute&amp;quot;
compile，正確&amp;quot;康-派-偶&amp;quot;，動詞編譯
compiler，正確&amp;quot;康-派l-惹&amp;quot;，l幾乎不發音，名詞編譯器
exit，正確&amp;quot;ㄟㄎ-sit&amp;quot;，常誤念成exist
vehicle，正確&amp;quot;V-诶口&amp;quot;</description>
    </item>
    
    <item>
      <title>流程控制:嵌套循環、break與continue</title>
      <link>https://yoziming.github.io/post/211120-agg-ja-05/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211120-agg-ja-05/</guid>
      <description>嵌套循環  就是for中有for，有時候需要多花點時間理解
  內層循環整個遍歷完，外層循環才執行一次 假設外層循環要執行m次，內層循環要執行n次。整個跑完內層循環一共執行了m*n次  練習題-印菱形 Scanner scan = new Scanner(System.in); System.out.println(&amp;#34;輸入想印的菱形邊長n=...&amp;#34;); int n = scan.nextInt(); // 上半部分(含中間最長邊) for (int i = 1; i &amp;lt;= n; i++) {  for (int j = 0; j &amp;lt; n - i; j++) {  System.out.print(&amp;#34; &amp;#34;);  }  for (int k = 0; k &amp;lt; i; k++) {  System.out.print(&amp;#34;* &amp;#34;);  }  System.out.println(); } // 下半部分(從最長-1開始) for (int i = 1; i &amp;lt;= n; i++) {  for (int j = 0; j &amp;lt; i; j++) {  System.</description>
    </item>
    
    <item>
      <title>流程控制:if、switch、for、while</title>
      <link>https://yoziming.github.io/post/211119-agg-ja-04/</link>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211119-agg-ja-04/</guid>
      <description>分支控制 if-else  基礎都一樣不多贅述
   特殊情況有人不加{}，這種情境下就近原則且只控制一行(到第一個;為止)
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); System.out.println(&amp;#34;b&amp;#34;); System.out.println(&amp;#34;c&amp;#34;); 結果為 b c   只有單行時可以接else且也會就近選擇
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); else System.out.println(&amp;#34;d&amp;#34;); 結果為d   多行時直接報錯
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); System.out.println(&amp;#34;b&amp;#34;); System.out.println(&amp;#34;c&amp;#34;); else 報錯   小結:不加{}的全部拖出去打
  switch-case   結構:
switch (表達式) {  case 常量1:  // 執行語句  break;  case 常量2...  ...  default:  // 預設執行語句 }   如果不加break;就不會跳出，而是會穿透且之下的語句全都執行一遍</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA設定與常用快捷鍵</title>
      <link>https://yoziming.github.io/post/211117-idea-shortkey/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-idea-shortkey/</guid>
      <description>IDEA基礎設定   安裝的根目錄，舉例&amp;hellip;\IntelliJ IDEA 2021.2.3\bin\idea64.exe.vmoptions
 編輯這個idea64.exe.vmoptions，改成-Xmx1024m -Xms2048m    ctrl+alt+s開啟設定 -&amp;gt; plugins插件 -&amp;gt; 搜尋chinese -&amp;gt; 安裝重啟 -&amp;gt; 中文化
  plugins插件 -&amp;gt; 搜尋save actions-&amp;gt; 安裝重啟 -&amp;gt; 存檔時自動格式化
  外觀-使用自定義字體打勾-Sarasa mono&amp;hellip;，大小改14
  更紗黑體Sarasa-Gothic
 https://github.com/be5invis/Sarasa-Gothic 特性:融合Iosevka(程式碼常用的等寬字型)跟Source Han Sans(思源黑)，有等距、繁簡中日韓不缺字，簡直完美    編譯器-字體-一樣改，大小我是設18、行高1.1
  插件 常用快捷鍵 視窗  Close All Tabs : alt + w Terminal : ctrl + alt + 0  選取  ctrl + E 最近使用的檔案列表 选中下一个相同内容的快捷键(vs code中的Ctrl+D)：Alt + J 選中匹配的大括號ctrl+] 或 ctrl+[ 快速移動到警告處(黃標或紅標)  以「行」為單位  複製 : ctrl + D 移動 : ctrl + shift + ↑/↓ 註解 : ctrl + / 刪除 : ctrl+x(其實是剪下)  以「區塊」為單位  擴增選取 : ctrl + W 遞減選取 : ctrl + shift + W 更改大小寫 : ctrl + shift + U  自動功能 :  自動補全 : alt + enter 自動產生 : alt + Ins 自動排版 : ctrl + alt + L  其他  顯示形參列表:ctrl+p shift + shift 全域搜索 查找當前文件結構(有哪些方法、屬性):ctrl+F12 ctrl+alt+shift+n 找方法 Ctrl+H查看當前接口或抽象的子類 全部折疊ctrl + shift + -減號  個人設定 快捷鍵 新專案設定  新專案設定，有時候覺得奇怪不是設定過怎又跑掉，原因是在這   比較重要的是這個properties編碼跟save Actions插件的自動格式化、導包等等設定  其他舒適設定  限制開啟視窗數量:File-&amp;gt;Settings-&amp;gt;Editor-&amp;gt;General-&amp;gt;Editor Tab-&amp;gt;Tab limit   過濾顯示檔案  *.</description>
    </item>
    
    <item>
      <title>運算符:邏輯運算、賦值、位運算與三元運算</title>
      <link>https://yoziming.github.io/post/211118-agg-ja-03/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211118-agg-ja-03/</guid>
      <description>運算符 加減乘除  基本都一樣不再贅述
 % 取餘的規則  結果的符號與被取餘的數符號相同，舉例-12%5=-2、12%-5=2、-12%-5=-2 實際開發中取餘常用來判斷是否能除盡  自增自減的規則  ++a，(前++)先運算後取值，舉例a=2;b=++a;結果a=3;b=3 a++，先取值後運算，舉例a=2;b=a++;結果a=3;b=2 --a，先運算後取值，舉例a=2;b=--a;結果a=1;b=1 a--，先取值後運算，舉例a=2;b=a--;結果a=1;b=2 自增減不會改變數據類型(但可能會溢位) 不可連用，舉例a++++會報錯  另外+也能用在字符串聯接，舉例&amp;quot;he&amp;quot;+&amp;quot;llo&amp;quot;=&amp;quot;hello&amp;quot;
= 賦值的規則  可以連續賦值，舉例int i1,i2; i1=i2=10; int i3=10,j3=20; +=、-=、*=、/=、%= 不會改變數據類型 面試題n=10; n+=(n++)+(++n); n=? 解: 拆成 n = n + 10 + 12 =32 寫==則是比較運算符，返回boolean  邏輯運算符  乍看邏輯跟短路結果是一樣，實際使用上差異為短路後的東西就不執行了 舉例: b=false; n=10; b &amp;amp;&amp;amp; (n++&amp;gt;0)=false，但n=10  位運算符  操作的都是整數 &amp;laquo; 向左移一位相當於*2，&amp;raquo;向右移一位相當於/2，有可能溢位  三元運算符  結構: (條件表達式) ? 表達式1 : 表達式2 說明: 條件表達式=boolean，如果是true則執行表達式1，反之執行2 表達式1 與 表達式2 要求類型一致(至少能裝進同一個類型) 其實就是簡易版的if，可以嵌套使用  優先級  基本原則是從上到下，從左到右，括號優先 自增減、賦值運算、三元運算才從右往左看  </description>
    </item>
    
    <item>
      <title>關鍵字、變量、數據類型與轉換</title>
      <link>https://yoziming.github.io/post/211117-agg-ja-02/</link>
      <pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-agg-ja-02/</guid>
      <description>關鍵字 關鍵字  有特殊含意與用途，所有關鍵字都是小寫
 例如:if、new&amp;hellip;等等，後面都會一一接觸到
保留字  未來版本可能會用到而保留
 例如:goto、const
標識符(identifier)  可以自己命名的(類、變量、函數&amp;hellip;等)就叫標識符
   由字母、數字、_、$組成
  數字不可為開頭
  能包含關鍵字但不能純用關鍵字
  嚴格區分大小寫
  不能包含空格
標識符的命名規範  不強制但最好遵守
   包名:多單詞所有字母小寫aaabbbccc
  類名、接口名:大駝峰(首字母大寫)AaaBbbCcc
  變量名、方法名:開頭小寫後面首字母大寫(小駝峰)aaaBbbCcc
  常量名:全大寫，用下畫線相連AAA_BBB_CCC
  命名要有意義，見名知意
  變量(variable)  記憶體中的一個儲存區域，使用的基本單位
  必須先聲明，後使用 作用域在其定義所在的一對{}內，只在其作用域中有效 同一作用域中不可重複  數據類型 基礎數據類型  六種數字類型（四個整數型，兩個浮點型），一種字符類型，還有一種布爾型
 byte  byte數據類型是8位、有符號的，以二進制補碼表示的整數 最小值是-128（-2^7）最大值是127（2^7-1）預設值是0 byte類型用在大型數組中節約空間，主要代替整數，因為byte變量佔用的空間只有int類型的四分之一 例子：byte a = 100，byte b = -50  short  short數據類型是16位、有符號的以二進制補碼表示的整數 最小值是-32768（-2^15）最大值是32767（2^15 - 1）預設值是0 Short數據類型也可以像byte那樣節省空間 一個short變量是int型變量所佔空間的二分之一 例子：short s = 1000，short r = -20000  int  int數據類型是32位、有符號的以二進制補碼表示的整數 最小值是-2,147,483,648（-2^31）最大值是2,147,483,647（2^31 - 1）預設值是0 一般整型變量預設為int類型 例子：int a = 100000, int b = -200000  long  long數據類型是64位、有符號的以二進制補碼表示的整數 最小值是-9,223,372,036,854,775,808（-2^63） 最大值是9,223,372,036,854,775,807（2^63 -1） 這種類型主要使用在需要比較大整數的系統上 必須以L(大小都可)結尾，不加自動被當成int 預設值是0L 例子： long a = 100000L，Long b = -200000L  float  float的儲存結構是1個符號位，8個指數位，23個尾數，符合IEEE 754標準的浮點數 可以看做float只有24位來表示精度，所以int或long轉``float可能會有精度損失 必須以F(大小都可)結尾，不加報錯 預設值是0.</description>
    </item>
    
    <item>
      <title>Java簡介、環境配置、HelloWorld</title>
      <link>https://yoziming.github.io/post/211116-agg-ja-01/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-agg-ja-01/</guid>
      <description>本筆記基於這份2019年4月的公開教學影片 尚硅谷Java入门视频教程(在线答疑+Java面试真题) https://www.bilibili.com/video/BV1Kb411W75N?p=1
 認識Java、環境配置 常用DOS操作  就是windows的cmd，影視中駭客情節常常出現的小黑窗，可以用文字操作基本的軟體功能
   cd=進入指定目錄
  cd..=回上層
  cd=回到根目錄
  變更硬碟目錄=直接輸入d:
  dir=列出當前目錄下的清單
  del=刪除檔案(對文件夾使用=刪除文件內所有檔案)
  md=創建目錄
  rd=刪除目錄
  exit=退出
  Java體系在不同平台的版本演化  Java SE，標準版，桌面級應用等，基礎API Java EE，企業版，主要用於Web開發，包含Servlet、JSP等技術 Java ME，小型版，古老的PDA、手機等，已過時 Java Card，面向小程序(Applets)，運行在小設備(如智能卡)等平台  Java語言特性  由繼承的脈絡可說JAVA是類C語言
  強制物件導向:總是基於&amp;quot;某件東西去做事&amp;quot;，得先搞懂何謂&amp;quot;類&amp;quot;與&amp;quot;物件&amp;quot;  三大特性:封裝、繼承、多態   健壯性:強類型、異常處理、GC(垃圾回收)、丟棄指針等 跨平台:只要平台能跑JVM(虛擬機)就能跑JAVA  Java的運行環境  JDK包含JRE包含JVM
  JDK，Java Development Kit，開發工具包，給開發人員用的，包含了JRE以及編譯工具(javac.</description>
    </item>
    
    <item>
      <title>LeetCode Easy: 1、9、13</title>
      <link>https://yoziming.github.io/post/211116-leetcode-easy-1-13/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-leetcode-easy-1-13/</guid>
      <description>1. Two Sum
 求某數組中哪兩位數的和等於X
 // go // nums []int=傳入的數組；target=X func twoSum(nums []int, target int) []int {   	m := make(map[int]int, len(nums))  	for i, num := range nums { 	if idx, ok := m[target-num]; ok { 	return []int{idx, i} 	} 	m[num] = i 	} 	return []int{0, 0} } 9. Palindrome Number
 判斷是否為迴文數字，例如121
 // java public boolean isPalindrome(int x) {  // 判斷是否迴文，如121、2332、456654  // 負數或尾數是0或&amp;lt;10的顯然可以排除  if (x &amp;lt; 0 || (x !</description>
    </item>
    
    <item>
      <title>修改css或js後瀏覽器快取不更新問題</title>
      <link>https://yoziming.github.io/post/211017-explorer-cache-problems/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211017-explorer-cache-problems/</guid>
      <description>修改css或js後瀏覽器快取不更新問題  當初我真的是被這個整到懷疑人生
 解決方式一：
​ 使用者按Ctrl + F5強制重新整理頁面或者手動清空了瀏覽器的快取。此時瀏覽器會重新向伺服器獲取CSS和JS檔案,新的檔案便會生效。
解決方式二：
​ 但是使用者量過大的時候總不能讓每個使用者一一清理快取吧，於是便從程式碼的角度著手解決這個問題。在js後面新增版本號，讓瀏覽器把這個JS檔案當做新的檔案重新向伺服器獲取資源。
加版本號前：
 &amp;lt;script type=&amp;#34;text/javascript&amp;#34; th:src=&amp;#34;@{/js/test/index.js}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  加版本號後：
 &amp;lt;script type=&amp;#34;text/javascript&amp;#34; th:src=&amp;#34;@{/js/test/index.js?v=1.0}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  實際上這種方法在web也被很廣泛的應用，有時候開網頁看到網址後面一串?t=65412378946之類的，原來就是用時間產生的亂數，專門用來防快取
參考 https://www.itread01.com/content/1548610940.html</description>
    </item>
    
    <item>
      <title>Docker &amp; Hyper-V占用port問題</title>
      <link>https://yoziming.github.io/post/211015-docker-hyper-v-port-problem/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211015-docker-hyper-v-port-problem/</guid>
      <description>Docker &amp;amp; Hyper-V占用port問題 在window下用docker desktop有時候遇上port被莫名佔用 用指令netstat -ano | findstr xxx查詢xxx埠被誰佔用卻又顯示沒有
原來是因為在window下用docker需要依賴hyper-v技術， 而這個hyper-v每次都會隨機搶走一部分tcp埠，使用命令可以得知應避開的範圍:
# powershell / cmd netsh interface ipv4 show excludedportrange protocol=tcp 如果避不開就手動叫Hyper-V讓路   關閉hyper-v
# powershell / cmd dism.exe /Online /Disable-Feature:Microsoft-Hyper-V   配置ipv4動態埠 / 或者配置需要的埠不被佔用
# powershell / cmd 管理員許可權 # start 起始埠 num 表示可用埠數 按自己的需求來 netsh int ipv4 set dynamicport tcp start=30000 num=16383 // 叫他去用30000以後的阜  # 排除ipv4動態埠佔用 startport 起始埠 numberofports 埠數 netsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1 // 或是指定端口50051為要讓路的   重新啟動hyper-v</description>
    </item>
    
    <item>
      <title>Linux常用操作、wsl2相關</title>
      <link>https://yoziming.github.io/post/211010-linux-common-operations/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211010-linux-common-operations/</guid>
      <description>Linux常用操作  ls：顯示檔或目錄資訊 mkdir：目前的目錄下創建一個空目錄 rmdir：要求目錄為空 touch：生成一個空檔或更改檔的時間 cp：複製檔或目錄 mv：移動檔或目錄、檔或目錄改名 rm：刪除檔或目錄 ln：建立連結檔 find：查找文件 cd 移動路徑 “.” 表示 目前的目錄 “..” 表示 上一級目錄 “-” 表示 上一次工作目錄 “~” 表示 用戶主目錄 sudo su root 取得su權限  // 解壓縮XX檔案到/usr/local sudo tar -C /usr/local -xzvf go1.17.1.linux-amd64.tar.gz // 文字編輯器 sudo gedit /home/yoziming/.config/go/env // 檔案總管 sudo nautilus // 啟用go mod go env -w GO111MODULE=on wsl2相關  優文參考: https://blog.csdn.net/qq_38856939/article/details/116528514  使用xfce4圖形介面  windows端  下載 X Server 例如 https://sourceforge.net/projects/vcxsrv/ 安裝後打開XLaunch 第一步 display number 預設可能是-1，改成0 下一步 setart no client 預設不用改 第三步 勾選 no access control 即完成監聽，等待linux來連線 查看IP，使用指令 ipconfig 注意看的是這個: 乙太網路卡 vEthernet (WSL): IPv4 位址 .</description>
    </item>
    
    <item>
      <title>Kubernetes基礎認識</title>
      <link>https://yoziming.github.io/post/211006-k8s/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211006-k8s/</guid>
      <description>Kubernetes基礎認識  自動化地以容器的形式管理你的應用程式 To host your application in the form of containers in a automated fashion
 名詞解釋   Cluster:集群，計算、儲存資源的集合。一個Cluster通常包含一個Controller Plane和數個Node，視需求而定(也可能有Multi-Controller Plane 的集群)
 Controller Plane:(以前叫Mater)控制主節點，調度指揮所  APIserver:管理整個 K8s 所需 API 的接口(Endpoint)，提供HTTP Rest介面的關鍵服務處理程序，是集群中各個節點的溝通橋樑 etcd:存資料 Scheduler:資源調配，例如調度Pod運行在哪個Node Controller-manager:總經理，負責管理並運行 controller ，controller定義各種Pod的部屬特性(如最常用的Deployment)來滿足不同的業務場景   Node:節點，讓物件(resource-objects)運行的實體或虛擬機器  kubelet:對應api-server的接口，可以看成每個Node上的&amp;quot;實際執行者&amp;quot;或&amp;quot;操作者&amp;quot;，負責接收來自api-server的訊息，並做出相對應的動作，例如，負責Pod對應的容器的建立、啟動或停止等。 kube-proxy:維護網路規則(iptables)，這些規則允許從群集內部或外部的與Pod進行通訊。 Container Runtime:容器的運行引擎，預設是Docker，也支援其他滿足CRI標準的。  Pod:可被調度的最小單位，每個Pod包含一或多個容器，Pod內共享生命週期、資源、通信(使用同一個網路namespace，即相同的IP與port)、儲存空間。通常使用是一個Pod中放一個容器；當需要高度共享資源時才會用一個Pod內多個容器的形式      延伸觀念  Deployment:部屬，例如把Pod做橫向擴展，適用自動管理，或達成無停機系統升級 Service:服務，Deployment可以部屬多個Pod，每個Pod都有自己的IP，隨時都在生滅浮動，外界如何訪問? 答案就是透過Service，可以說Controller負責運行Pod，而Service負責訪問Pod。 Ingress:Service 中是將每個 Service 元件對外的 port number 跟 Node 上的 port number 做 mapping，這樣在我們的 Service 變多時，port number 以及分流規則的管理變得相當困難。而 Ingress 可以透過 HTTP/HTTPS，在我們眾多的 Service 前搭建一個 reverse-proxy。這樣 Ingress 可以幫助我們統一一個對外的 port number，並且根據 hostname 或是 pathname 決定封包要轉發到哪個 Service 上 Namespace:命名空間，假如有多個用戶使用同一個Cluster，想把他們創建的Controller、Pod等資源分開，就靠Namespace。Namespace將物理的Cluster從邏輯上切成多個虛擬Cluster，每一個虛擬Cluster就是一個Namespace，不同Namespace中的資源完全隔離。K8s預設創建2個Namespace:  default:如果不指定，資源就預設放這 kube-system:K8s自己創建的系統資源會放在這個Namespace中      </description>
    </item>
    
    <item>
      <title>MySQL常用語句 &amp; Workbench</title>
      <link>https://yoziming.github.io/post/211005-mysql-cmd-workbench/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211005-mysql-cmd-workbench/</guid>
      <description>MySQL 常用語句 資料庫database
create database XXX; show databases; use XXX; drop database XXX; 資料表table
create table mytable(school char(5),name char(10),id int); show tables; describe mytable; // 顯示這表有哪些欄位跟屬性 drop table mytable; select * from mytable; // 顯示mytable中所有資料 insert into mytable(school, name, id) values (&amp;#39;NCTU&amp;#39;,&amp;#39;Jerry&amp;#39;,&amp;#39;123&amp;#39;); insert into mytable values (&amp;#39;NCTU&amp;#39;,&amp;#39;Jerry&amp;#39;,&amp;#39;123&amp;#39;); update mytable set name = &amp;#39;HaHa&amp;#39; where id = &amp;#39;123&amp;#39;; delete from mytable where name = &amp;#39;HaHa&amp;#39;; delete from 表格; // 把表格內資料都刪除(但格式宣告還在) select * from mytable where id = &amp;#39;123&amp;#39; order by name DESC; // 資料表查詢+條件+排序 (DESC 代表由大到小排序) load data local infile &amp;#34;c:\\data.</description>
    </item>
    
    <item>
      <title>Docker啟用Redis</title>
      <link>https://yoziming.github.io/post/211002-docker-redis/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211002-docker-redis/</guid>
      <description>Docker啟用Redis 抓映象檔 docker pull redis:6.0  拉一個6.0版本的redis  執行 Image docker run --name redis6 -p 6379:6379 -d redis:6.0 redis-server --appendonly yes  –name redis6 ：將 Container 取名為 redis6 -p 6379:6379 ：將 Container 的 6379 Port 映射到主機的 6379 Port (前面代表主機，後面代表容器) -d :後台執行 Container ，並返回ID redis-server –appendonly yes : 在 Container 執行 redis-server 啟動命令，並打開redis持久化配置  進入 Container docker exec -it redis6 bash  -i ：即使沒有附加也保持STDIN 打開 -t ：分配一個偽終端  資料庫測試 redis-cli set hello world get hello </description>
    </item>
    
    <item>
      <title>Docker啟用Mysql</title>
      <link>https://yoziming.github.io/post/211001-docker-mysql/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211001-docker-mysql/</guid>
      <description>Docker啟用Mysql 抓映象檔 docker pull mysql/mysql-server:8.0  拉一個8.0版本的mysql  執行 Image docker run -d -it --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=mydb mysql:8 --default-authentication-plugin=mysql_native_password  -d：同--detach，以背景模式執行。 -v ~/mysql-docker-data:/var/lib/mysql：同--volume，掛載host目錄到container目錄，也就是host的~/mysql-docker-data會保存container /var/lib/mysql的資料；windos docker app這樣做的話，資料是暫時的重開機後會不見。 -it：同--interactive加--tty，作用為運行container時可登入其bash操作。 --name mysql8，命名container名稱為mysql8。 -p：同--publish。作用為將container的3306 port對映到&amp;quot;主機(host)&amp;ldquo;的3306 port -e：同--env，設定環境變數。MYSQL_ROOT_PASSWORD設定MySQL root帳號的登入密碼為1234，MYSQL_DATABASE設定資料庫名稱為mydb。 mysql:8：mysql為image名稱，8為image tag。所以運行的是mysql:8的image。 --default-authentication-plugin=mysql_native_password：把儲存密碼的方式改為MySQL 5的mysql_native_password，因為MySQL 8的儲存方式預設為caching_sha2_password，但一些免費的MySQL client圖形工具如Sequel Pro，Navicat等會無法連線，所以設定此參數。  檢視運行中的容器 docker ps 進入 Container docker exec mysql8 mysql -u root -p  docker exec指令的作用為在運行的container執行指令，所以意思就是在mysql8這個container執行mysql -u root -p的指令。  docker container exec -it mysql8 /bin/bash  遇到權限問題用這個  進入Mysql mysql -uroot -p 新增 1 個開放外部連線的帳號 CREATE USER &amp;#39;user01&amp;#39;@&amp;#39;%&amp;#39; IDENTIFIED BY &amp;#39;1234&amp;#39;; GRANT ALL ON your_database.</description>
    </item>
    
    <item>
      <title>Docker常用指令與操作</title>
      <link>https://yoziming.github.io/post/210930-docker-common-operations/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210930-docker-common-operations/</guid>
      <description>Docker常用操作  官方 https://docs.docker.com/engine/reference/run/
 容器運行前  抓映像  docker pull xxx 容器運行中  檢視運行中的容器  docker ps  停止容器  啟動換成 start 重啟換成 restart 強殺換成 kill    docker stop 容器名或ID  批次全部重啟  這個在windows docker也有效，特別適合自己練習專案用 awk &#39;{ print $1}&#39;那種在windows就不行    docker restart $(docker ps -a -q)  刪除容器  docker rm -f 容器名或ID  檢視運行狀態(CPU、記憶體、I/O占用等等)  docker stats -a  顯示運行日誌  docker logs 容器名或ID  查看詳情  docker inspect 容器名或ID  更新運行參數  docker update --restart=always 容器名或ID  進入 Container  -i ：即使沒有附加也保持STDIN 打開 -t ：分配一個偽終端    docker exec -it &amp;lt;container_id&amp;gt; /bin/bash 容器內   就是進到/bin/sh之下，有個$符號的狀態</description>
    </item>
    
    <item>
      <title>Docker啟用MinIO</title>
      <link>https://yoziming.github.io/post/210929-docker-minio/</link>
      <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210929-docker-minio/</guid>
      <description>Docker啟用MinIO儲存 執行 Image docker run -d --name minio -e &amp;#34;MINIO_ROOT_USER=root&amp;#34; -e &amp;#34;MINIO_ROOT_PASSWORD=root1234&amp;#34; -p 9000:9000 -p 9001:9001 minio/minio server /data --console-address &amp;#34;:9001&amp;#34;  --name minio，命名container名稱為minio。 -v /data/minio:/data/minio該命令將主機 /data/minio 目錄對映到容器中的 /data/minio 目錄中 MinIO 還提供了圖形管理介面，在瀏覽器輸入 ip:9001即可檢視 不管是圖形介面操作，還是客戶端操作，預設賬號密碼都為 minioadmin -e環境變數，這裡用了自定義賬號密碼，賬號不能小於 3 字元，密碼不能小於 8 字元  Go初始化 導入github.com/minio/minio-go/v7，注意這個後面的v7，在自動引包時可能會漏掉，導致使用到舊版的同名函數而報錯
func InitMinio() { 	ctx := context.Background() 	endpoint := &amp;#34;localhost:9000&amp;#34; 	accessKeyID := &amp;#34;root&amp;#34; 	secretAccessKey := &amp;#34;root1234&amp;#34; 	useSSL := false  	// Initialize minio client object.</description>
    </item>
    
    <item>
      <title>consul基礎使用練習</title>
      <link>https://yoziming.github.io/post/210928-consul-practice/</link>
      <pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210928-consul-practice/</guid>
      <description>consul基礎使用練習  想像去郵局辦事，consul類似於發號碼牌的那個機器
伺服端(櫃台人員)去找consul註冊服務，比如說櫃台1~3提供儲蓄，櫃台4~6提供郵寄服務
客戶進來透過服務發現，把要辦的事丟給consul，它查看哪個櫃台健康，幫你匹配對應的服務或叫號
(感覺這例子不太完善，就&amp;hellip;類似的理解啦，實際用了才會懂)
   下載
# 官網: https://www.consul.io/downloads # ubuntu shell: (下載&amp;gt;解壓縮&amp;gt;把二進位執行檔丟進去) wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zip unzip consul_1.10.3_linux_amd64.zip sudo mv consul /usr/local/bin/   測試
consul -h   啟動server
consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=192.168.234.128 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0 這個IP=192.168.234.128=ubuntu的ip
*若/etc/consul.d/不存在要先自己創
  查看服務
http://192.168.234.128:8500/   註冊自訂的健康檢查服務，範例:
剛剛自訂的配置檔路徑/etc/consul.d/下新增一個web.json
{&amp;#34;service&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;web&amp;#34;, &amp;#34;tags&amp;#34;: [&amp;#34;extract&amp;#34;, &amp;#34;verify&amp;#34;, &amp;#34;compare&amp;#34;, &amp;#34;idcard&amp;#34;], &amp;#34;address&amp;#34;: &amp;#34;192.168.234.128&amp;#34;, &amp;#34;port&amp;#34;: 9000, &amp;#34;check&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;api&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;HTTP API on port 9000&amp;#34;, &amp;#34;http&amp;#34;: &amp;#34;http://localhost:9000&amp;#34;, &amp;#34;interval&amp;#34;: &amp;#34;10s&amp;#34;, &amp;#34;timeout&amp;#34;: &amp;#34;1s&amp;#34; } } }   重啟server並查看服務</description>
    </item>
    
    <item>
      <title>Golang下透過grpc調用服務案例</title>
      <link>https://yoziming.github.io/post/210927-grpc/</link>
      <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210927-grpc/</guid>
      <description>Golang下透過grpc調用服務案例  grpc簡單說就是跨平台(跨語言)調用各種服務的通用轉接口
 對.proto文件使用轉譯指令:
protoc --go_out=plugins=grpc:. *.proto  案例:透過grpc遠程傳遞一個調用teacher資料類型的服務
 .proto:
syntax=&amp;#34;proto3&amp;#34;; option go_package=&amp;#34;/.;pb&amp;#34;; message Teacher{ int32 age=1; string name=2; } service SayName{ rpc SayHello(Teacher) returns(Teacher); } server:
type Children struct{} // 綁定類方法 func (c *Children) SayHello(ctx context.Context, t *pb.Teacher) (*pb.Teacher, error) { t.Name += &amp;#34;is sleeping&amp;#34; return t, nil } func main() { // 初始一個grpc對象 grpcServer := grpc.NewServer() // 註冊服務 pb.RegisterSayNameServer(grpcServer, new(Children)) // 監聽 listener, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;127.</description>
    </item>
    
    <item>
      <title>Golang中使用ProtoBuf</title>
      <link>https://yoziming.github.io/post/210926-golang-protobuf/</link>
      <pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210926-golang-protobuf/</guid>
      <description>Golang中使用ProtoBuf  protobuf類似json，它體積更小效率更高，規範統一(沒有大小寫等困擾)。
缺點是改動協議就要重新生成、數據本身是二進位沒有可讀性
   下載，window系統選.exe，解壓縮放到$GOPATH/bin
https://github.com/protocolbuffers/protobuf/releases   安裝golang對應的庫跟插件
go get github.com/golang/protobuf/proto go get github.com/golang/protobuf/protoc-gen-go   測試
protoc -h 或 protoc --version 沒報錯就是成功
  消息體舉例，xxx.proto
// 指定版本，不打3就會是2 syntax=&amp;#34;proto3&amp;#34;; // 指定輸出位置&amp;amp;go包名，沒寫轉換不了 // option go_package =&amp;#34;path;name&amp;#34;; option go_package =&amp;#34;/.&amp;#34;; // 放在同一目錄下包名為__(空) // 定義消息體，分配唯一編號 (不能用19000~19999) message Student{ int32 age = 1; // 可以不從1開始，但不可重複 string name = 2; People p=3; repeated int32 score=4; // 數組 Week w=5; // 聯合體 oneof data{ string teacher=6; string class=7; } } // 消息體可以嵌套 message People{ int32 weight=1; } // 定義枚舉類型 enum Week{ Monday=0; // 必須從0開始 Turesday=1; }   生成go文件</description>
    </item>
    
    <item>
      <title>MVC &amp; Microservices</title>
      <link>https://yoziming.github.io/post/210920-mvc-microservices/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210920-mvc-microservices/</guid>
      <description>MVC架構 Model:模型，管理資料庫(增刪改查)、業務邏輯、物件結構定義
View:視圖，使用者實際在看、操作的介面(UI)，前端
Controller:控制，接收請求、回覆結果，決定工作流程，算是Model跟View的中間人
微服務架構（Microservices）  單一職責:把業務邏輯拆分成無數個小區塊(Blocks)，負責單一任務，服務之間透過管道來通訊。 輕量級通訊:使用不依賴語言或平台的格式，例如XML、JSON、protobuf。通常基於HTTP協議、符合REST風格來達成標準化、無狀態化。 獨立開發、測試、部屬:顧名思義，都拆開了就可以分開做，不像傳統架構牽一髮而動全身。 容器化:微服務既然能獨立作業了，就可以放到容器(Container)中，互相隔離互不干擾，達成快速部署、節省資源。Docker是目前最普遍的容器技術，Kubernetes(K8s)是常用來管理容器、協調整合的平台。  </description>
    </item>
    
    <item>
      <title>GoogleSearchConsole</title>
      <link>https://yoziming.github.io/post/211020-blog-ga/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211020-blog-ga/</guid>
      <description>如何讓自己的blog被google搜尋到  首先你要跟google證明這個網站是你的，並且允許google的爬蟲機器人獲取你的網站資料，這樣別人才能在google上搜尋到你的網站 同時也能夠使用google自訂搜尋方便自己查找資料  關於網站驗證  你同意後它才能把觸手深入你的網站，你可以自訂搜尋這個網站的資料權限 google提供多種方法，我是選html標記，放在套用的主題的之下，舉例:   如果你換了主題記得也要重改  Hugo建立sitemap索引  提供sitemap索引讓google機器人更好抓你的網站 Hugo內鍵就有這個功能，修改config.toml，插入:  [sitemap] changefreq = &amp;#39;weekly&amp;#39; filename = &amp;#39;sitemap.xml&amp;#39; priority = 0.5 自訂搜尋 大部分主題都有此功能，一樣修改config.toml即可:
googleSearchCode = &amp;#34;你的SearchCode&amp;#34; </description>
    </item>
    
    <item>
      <title>HugoBlog的圖片插入方式</title>
      <link>https://yoziming.github.io/post/210930-blog-insert-image/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210930-blog-insert-image/</guid>
      <description>插入圖片的方式  常見有2種做法
 方法1  在.\static\images\下放入的圖片會被打包上傳，然後從相對路徑引用那個圖片 適和用在全站通用的資源，比如背景圖、縮圖  方法2   在.\content\post\下，每當有用到圖片一篇文章的就新增一個資料夾
  資料夾可以命名可自訂，然後進去把.md檔改名為&amp;quot;index.md&amp;quot;，圖片放同層
  範例:  這個方法比較好整理，每篇用到的圖片放在自己的資料夾中
  </description>
    </item>
    
    <item>
      <title>用Hugo建立靜態Blog</title>
      <link>https://yoziming.github.io/post/210909-blog-hugo/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210909-blog-hugo/</guid>
      <description>用Github&amp;amp;Hugo建立靜態Blog  程式設計師寫blog再常見不過，好處多多不再贅述，但如何從0開始架出一個blog?
我看了很多教學有各種高級的自動部署、netlify後台等等，照做時卻老是在一些關鍵點卡住。我這個土路雖然蠢笨但確實能做出東西，同樣新手可以試試。
   安裝Chocolatey //程式安裝器，讓你從終端裝各種東西很方便
https://chocolatey.org/install 到這個網址，官方提供很多方法安裝，非常簡單快速一行搞定 安裝hugo，有些佈景主題要用到加強版(extended)
choco install hugo -confirm choco install hugo-extended -confirm   hugo new site &amp;lt;資料夾名稱&amp;gt; //建立一個root，相當於你個人網站的原始資料母巢
  挑主題，到https://themes.gohugo.io/
  套用主題，範例
 cd &amp;lt;資料夾名稱&amp;gt; git init git submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary   依照主題的說明文件修改根目錄下的config.toml 注意，config.toml中的第一項baseURL網址不要有&amp;quot;https://www.ooxx&amp;quot;，否則會造成一些未知的BUG。正確網址應為&amp;quot;https://你的username.github.io/&amp;quot;
  到content/post/下開始寫一篇blog
  開啟本地預覽，指令hugo server -F //防止時差問題用-F
  隨意一個地方開啟網址http://localhost:1313/ 看看網站
  網站沒問題就打包，指令hugo，會在root資料夾下多出一個public資料夾，裡面就是一個完整的網站準備丟去網路上發布
  去gitHub建一個Repository(倉庫)，名稱強制為 你的username.github.io
  下載GitHub Desktop客戶端，可以把他理解成一個雲端，我要把本地public資料夾的內容透過它丟去gitHub上剛剛建的那個Repository(倉庫)裡，之後就能透過網站提供的gitPage功能實現個人網站的搭建</description>
    </item>
    
    <item>
      <title>一次性隊列</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-queue/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-queue/</guid>
      <description>一次性隊列 //用結構體管理隊列 type Queue struct { maxSize int array [3]int front int //隊列首(不包含) rear int //隊尾(含) } //添加數據val到隊列 func (q *Queue) AddQueue(val int) (err error) { //先判斷是否已滿 if q.rear == q.maxSize-1 { return errors.New(&amp;#34;queue full&amp;#34;) } q.rear++ q.array[q.rear] = val return } //取出數據 func (q *Queue) GetQueue() (val int, err error) { //先判斷是否為空 if q.rear == q.front { return -1, errors.New(&amp;#34;queue empty&amp;#34;) } q.front++ val = q.array[q.front] return val, err } //顯示隊列 func (q *Queue) ShowQueue() { fmt.</description>
    </item>
    
    <item>
      <title>二分樹的3種遍歷</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-bi-tree/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-bi-tree/</guid>
      <description>二分樹的3種遍歷 package main import &amp;#34;fmt&amp;#34; type Hero struct { No int Name string Left *Hero Right *Hero } //前序遍歷 先輸出root 再輸出左子樹 再輸出右子樹，會中左右一層層往下 func PreOrder(node *Hero) { if node != nil { fmt.Printf(&amp;#34;no=%d name=%s\n&amp;#34;, node.No, node.Name) PreOrder(node.Left) PreOrder(node.Right) } } //中序遍歷 左子樹 root 右子樹 func InfixOrder(node *Hero) { if node != nil { InfixOrder(node.Left) fmt.Printf(&amp;#34;no=%d name=%s\n&amp;#34;, node.No, node.Name) InfixOrder(node.Right) } } //後序遍歷 左子樹 右子樹 root，會一路到最左最下開始打 func PostOrder(node *Hero) { if node !</description>
    </item>
    
    <item>
      <title>哈希表數據結構</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-hash/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-hash/</guid>
      <description>哈希表數據結構 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) type Emp struct { Id int Name string Next *Emp } func (e *Emp) ShowMe() { fmt.Printf(&amp;#34;链表%d 找到该雇员 %d\n&amp;#34;, e.Id%7, e.Id) } //不帶表頭，即第一個節點就放雇員資料 type EmpLink struct { Head *Emp } func (e *EmpLink) FindByIdEmpLink(id int) *Emp { cur := e.Head for { if cur != nil &amp;amp;&amp;amp; cur.Id == id { return cur } else if cur == nil { break } cur = cur.</description>
    </item>
    
    <item>
      <title>單向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-list/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-list/</guid>
      <description>單向鏈表 type HeroNode struct { no int name string next *HeroNode //表示指向下一個節點 } //給鏈表插入節點 func Insert(head *HeroNode, newHeroNode *HeroNode) { //先找到最後的節點，創建一個輔助 temp := head for { if temp.next == nil { //表示找到最後 break } temp = temp.next //不斷往下找 } //把newHeroNode加到屁股 temp.next = newHeroNode } //根據No從小到大插入 func InsertNo(head *HeroNode, newHeroNode *HeroNode) { //想找到適當的節點，創建一個輔助 temp := head for { if temp.next == nil { //表示找到最後 break } else if temp.next.no &amp;gt; newHeroNode.no { //表示new要插到temp後 break } else if temp.</description>
    </item>
    
    <item>
      <title>插入&amp;選擇&amp;快速排序</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-quick-sort/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-quick-sort/</guid>
      <description>插入&amp;amp;選擇&amp;amp;快速排序 //選擇排序 func SelectSort(array *[6]int) { for j := 0; j &amp;lt; len(array)-1; j++ { min := array[j] minIndex := j //尋找最小的下標 for i := j + 1; i &amp;lt; len(array); i++ { if min &amp;gt; array[i] { min = array[i] minIndex = i } } if minIndex != j { array[j], array[minIndex] = array[minIndex], array[j] } fmt.Printf(&amp;#34;第%d次交換後 %v\n&amp;#34;, j+1, *array) } } //插入排序 func InsertSort(arr *[6]int) { for j := 1; j &amp;lt; len(arr); j++ { //給第二個元素找位置 insertVal := arr[j] insertIndex := j - 1 //下標 //由大到小 for insertIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[insertIndex] &amp;lt; insertVal { arr[insertIndex+1] = arr[insertIndex] //數據後移 insertIndex-- } //插入 if insertIndex+1 !</description>
    </item>
    
    <item>
      <title>模擬棧&amp;四則運算</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-stack/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-stack/</guid>
      <description>模擬棧&amp;amp;四則運算 //模擬棧的使用 type Stack struct { MaxTop int //最大可存個數 Top int //頂 arr [20]int } func (s *Stack) Push(val int) (err error) { //先判斷是否滿 if s.Top == s.MaxTop-1 { fmt.Println(&amp;#34;stack full&amp;#34;) return errors.New(&amp;#34;stack full&amp;#34;) } //放入數據 s.Top++ s.arr[s.Top] = val return } func (s *Stack) Pop() (val int, err error) { //先判斷是否空 if s.Top == -1 { fmt.Println(&amp;#34;stack empty&amp;#34;) return 0, errors.New(&amp;#34;stack empty&amp;#34;) } //彈出數據 val = s.arr[s.Top] s.Top-- return val, nil } //遍歷 func (s *Stack) List() { //先判斷是否空 if s.</description>
    </item>
    
    <item>
      <title>環形單向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-circle-list/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-circle-list/</guid>
      <description>環形單向鏈表 type CatNode struct { no int name string next *CatNode } func Insert(head *CatNode, newCatNode *CatNode) { //判斷是否第一隻貓 if head.next == nil { head.no = newCatNode.no head.name = newCatNode.name head.next = head //構成環形 fmt.Println(*newCatNode, &amp;#34;已初始化並加入環形鏈表&amp;#34;) return } //定義一個變量找到環形最後一個 temp := head for { if temp.next == head { break } temp = temp.next } temp.next = newCatNode fmt.Println(*newCatNode, &amp;#34;已加入環形鏈表&amp;#34;) newCatNode.next = head } func Del(head *CatNode, id int) *CatNode { temp := head helper := head if temp.</description>
    </item>
    
    <item>
      <title>稀疏數組</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-array3/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-array3/</guid>
      <description>稀疏數組 type ValNode struct { row int //橫的 col int //直的 val int } func main() { //創建數組範例 var chessMap [11][11]int chessMap[1][2] = 1 chessMap[2][3] = 2 //輸出看樣子 for _, v := range chessMap { for _, v2 := range v { fmt.Printf(&amp;#34;%d\t&amp;#34;, v2) } fmt.Println() } //轉成稀疏數組，思路:遍歷他，創造一個結構體，發現有值就放進對應的切片 var sparseArr []ValNode //紀錄規模跟預設值 valNode0 := ValNode{ row: 11, col: 11, val: 0, } sparseArr = append(sparseArr, valNode0) for i, v := range chessMap { for j, k := range v { if k !</description>
    </item>
    
    <item>
      <title>約瑟夫問題</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-josephus/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-josephus/</guid>
      <description>約瑟夫問題 type Boy struct { No int Next *Boy //指向下一個小孩的指針 } func addBoy(num int) *Boy { //num表示小孩的個數，*Boy返回第一個小孩的指針 first := &amp;amp;Boy{} temp := &amp;amp;Boy{} if num &amp;lt; 1 { fmt.Println(&amp;#34;num值錯誤&amp;#34;) return first } for i := 1; i &amp;lt;= num; i++ { boy := &amp;amp;Boy{ No: i, } if i == 1 { first = boy //不變 temp = boy temp.Next = first } else { temp.Next = boy temp = boy temp.</description>
    </item>
    
    <item>
      <title>迷宮遞迴</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-recursive/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-recursive/</guid>
      <description>迷宮遞迴 func SetWay(myMap *[8][7]int, a int, b int) bool { //a,b 表示對地圖的那個點測試 //找到出口 if myMap[6][5] == 2 { return true } else { //繼續找 if myMap[a][b] == 0 { //可探測的點 myMap[a][b] = 2 //踩上去了，再探上下左右，但是我知道要往下往右探 if SetWay(myMap, a+1, b) { //下 return true } else if SetWay(myMap, a, b+1) { //右 return true } else if SetWay(myMap, a-1, b) { //上 return true } else if SetWay(myMap, a, b-1) { //左 return true } else { //死路 myMap[a][b] = 3 return false } } else { //不可探測的點 return false } } } func main() { //定義地圖 1=牆壁 0=沒走過的點 2=通路 3=走過的死路 var myMap [8][7]int //四周設置圍牆 for i := 0; i &amp;lt; 7; i++ { myMap[0][i] = 1 myMap[7][i] = 1 } for i := 0; i &amp;lt; 8; i++ { myMap[i][0] = 1 myMap[i][6] = 1 } myMap[3][1] = 1 myMap[3][2] = 1 //看樣子 for i := 0; i &amp;lt; 8; i++ { for j := 0; j &amp;lt; 7; j++ { fmt.</description>
    </item>
    
    <item>
      <title>雙向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-double-chain-list/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-double-chain-list/</guid>
      <description>雙向鏈表 type HeroNode struct { no int name string pre *HeroNode //表示指向前一個節點 next *HeroNode //表示指向下一個節點 } //給鏈表插入節點 func Insert(head *HeroNode, newHeroNode *HeroNode) { //先找到最後的節點，創建一個輔助 temp := head for { if temp.next == nil { //表示找到最後 break } temp = temp.next //不斷往下找 } //把newHeroNode加到屁股 temp.next = newHeroNode newHeroNode.pre = temp } //根據No從小到大插入 func InsertNo(head *HeroNode, newHeroNode *HeroNode) { //想找到適當的節點，創建一個輔助 temp := head for { if temp.next == nil { //表示找到最後 break } else if temp.</description>
    </item>
    
    <item>
      <title>channel通道</title>
      <link>https://yoziming.github.io/post/210810-agg-go-channel/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-channel/</guid>
      <description>channel通道 lock sync與chan基本認識 //階乘1-n 把各個數放到map中 用goroutine完成 var ( myMap = make(map[int]int, 10) //聲明一個全局的互斥鎖 lock sync.Mutex //來點管道 記得要make初始化才能用 intChan chan int = make(chan int, 3) //聲明類型為空接口可以接收任意類型 allChan chan interface{} = make(chan interface{}, 5) //注意後面沒聲明容量則不給用 ) type Cat struct { Name string Age int } func test(n int) { res := 1 for i := 1; i &amp;lt;= n; i++ { res = res * i } //把res放進mayMap //加鎖 lock.Lock() myMap[n] = res //解鎖 lock.</description>
    </item>
    
    <item>
      <title>const常量</title>
      <link>https://yoziming.github.io/post/210810-agg-go-const/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-const/</guid>
      <description>const常量  常量 聲明時必須賦值、不能修改、只能是bool、數值、string，賦值需是一個確定的值
 func main() { const tax int = 10 const x = 9 / 3 // const c = 9 / a //因為a可能是一個變量所以這樣不行 // var a int = 3 fmt.Println(tax, x) const ( a = iota //表示a=0 b //b=a+1 c //c=b+1 ) fmt.Println(a, b, c) const ( d = iota e f, g = iota, iota ) fmt.Println(d, e, f, g) //其他程式語言常量會用全大寫，go中沒限制，且一樣用首字母大小來控制使用範圍 } </description>
    </item>
    
    <item>
      <title>defer臨走前啟用</title>
      <link>https://yoziming.github.io/post/210810-agg-go-defer/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-defer/</guid>
      <description>defer臨走前啟用  退出函數前才執行
 func sum(n1, n2 int) int { defer fmt.Println(&amp;#34;ok1&amp;#34;, n1) defer fmt.Println(&amp;#34;ok2&amp;#34;, n2) //defer棧先入後出 n1++ n2++ res := n1 + n2 fmt.Println(&amp;#34;ok3 res=&amp;#34;, res) return res } func main() { res := sum(10, 20) fmt.Println(&amp;#34;res=&amp;#34;, res) } </description>
    </item>
    
    <item>
      <title>goroutine</title>
      <link>https://yoziming.github.io/post/210810-agg-go-goroutine/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-goroutine/</guid>
      <description>goroutine  進程=程序在操作系統中的一次進行過程
線程=執行實例的最小單位
  一個進程可以創建多個線程且併發執行 一個程序至少包含一個進程，一個進程至少包含一個線程 併發=多線程程序在單核上運行 併行=多線程程序在多核上運行  GO的主線程(可以理解為進程)，一個GO進程上可以起很多協程，協程可以理解為輕量級的線程，協程特點:
 有獨立的棧空間 共享程序堆空間 調度由用戶控制 為輕量級的線程  func test() { for i := 0; i &amp;lt; 10; i++ { fmt.Println(&amp;#34;test()Hello,world&amp;#34; + strconv.Itoa(i)) time.Sleep(time.Second / 10) } } func main() { go test() //開啟一個協程 //如果主線程退出了，即使協程還沒執行完，也會退出 //協程可以自己先結束 for i := 0; i &amp;lt; 10; i++ { fmt.Println(&amp;#34;main()Hello,go&amp;#34; + strconv.Itoa(i)) time.Sleep(time.Second / 10) } go test() //開啟一個協程，主線程退出了，即使協程還沒執行完，也會退出 //查邏輯CPU數量 cpuNum := runtime.NumCPU() fmt.Println(cpuNum) //設置最大線程數量 runtime.</description>
    </item>
    
    <item>
      <title>Go使用mysql與事務操作</title>
      <link>https://yoziming.github.io/post/210810-agg-go-mysql/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-mysql/</guid>
      <description>Go使用mysql與事務操作 基本操作 import ( &amp;#34;database/sql&amp;#34; &amp;#34;fmt&amp;#34; _ &amp;#34;github.com/go-sql-driver/mysql&amp;#34; ) var db *sql.DB // 是一個連接池對象 // user 接收數據 type user struct { id int name string age int } func initDB() (err error) { dsn := &amp;#34;root:root@tcp(127.0.0.1:3306)/sql_test&amp;#34; db, err = sql.Open(&amp;#34;mysql&amp;#34;, dsn) // 這個db要用全局的，重要! if err != nil { return } err = db.Ping() if err != nil { return } else { fmt.Println(&amp;#34;連接成功&amp;#34;) } return } // 查詢一個 func find1() { var u1 user sqlStr := `select id, name, age from user where id=?</description>
    </item>
    
    <item>
      <title>JSON序列化</title>
      <link>https://yoziming.github.io/post/210810-agg-go-json/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-json/</guid>
      <description>JSON序列化  JSON 格式 {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:&amp;ldquo;值2&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:[&amp;ldquo;值2數組&amp;rdquo;,值2數組]}
 type Monster struct { Name string `json:&amp;#34;name&amp;#34;` //反射機制 Age int `json:&amp;#34;age&amp;#34;` Sal float64 `json:&amp;#34;sal&amp;#34;` } func test1() { monster1 := Monster{ Name: &amp;#34;牛魔王&amp;#34;, Age: 50, Sal: 8000.0, } data, err := json.Marshal(&amp;amp;monster1) if err != nil { fmt.Println(err) } fmt.Println(string(data)) } //把map序列化 func testMap() { var mapA map[string]interface{} = make(map[string]interface{}) mapA[&amp;#34;name&amp;#34;] = &amp;#34;紅孩兒&amp;#34; mapA[&amp;#34;age&amp;#34;] = 18 data, err := json.Marshal(&amp;amp;mapA) if err !</description>
    </item>
    
    <item>
      <title>Map集合</title>
      <link>https://yoziming.github.io/post/210810-agg-go-map/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-map/</guid>
      <description>Map集合 func main() { // map[key類型] value類型 var m1 map[int]int = make(map[int]int) //key類型通常是int or string //value 通常是數字 or string or map or struct //只聲明不會給內存，要make才初始化才能用(跟切片一樣) m1[1] = 100 m1[2] = 200 m1[3] = 300 m1[1] = 1000 //key不能重複，後賦予的頂掉前面 fmt.Println(m1) var m2 = make(map[string]string) m2[&amp;#34;AV&amp;#34;] = &amp;#34;sss&amp;#34; fmt.Println(m2) //推薦寫法 m3 := make(map[string]string) m3[&amp;#34;一號&amp;#34;] = &amp;#34;台北&amp;#34; m3[&amp;#34;二奧&amp;#34;] = &amp;#34;桃園&amp;#34; fmt.Println(m3) m4 := map[int]int{1: 10, 2: 20, 3: 30} fmt.Println(m4) //學生姓名+性別 m5 := make(map[string](map[string]string)) m5[&amp;#34;stu01&amp;#34;] = make(map[string]string) //不能少 m5[&amp;#34;stu01&amp;#34;][&amp;#34;name&amp;#34;] = &amp;#34;tom&amp;#34; m5[&amp;#34;stu01&amp;#34;][&amp;#34;sex&amp;#34;] = &amp;#34;男&amp;#34; m5[&amp;#34;stu02&amp;#34;] = make(map[string]string) //不能少 m5[&amp;#34;stu02&amp;#34;][&amp;#34;name&amp;#34;] = &amp;#34;mary&amp;#34; m5[&amp;#34;stu02&amp;#34;][&amp;#34;sex&amp;#34;] = &amp;#34;女&amp;#34; fmt.</description>
    </item>
    
    <item>
      <title>new與make的區別</title>
      <link>https://yoziming.github.io/post/210810-agg-go-new-make/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-new-make/</guid>
      <description>func main() { num1 := 100 fmt.Printf(&amp;#34;類型=%T,值=%v,地址=%v\n&amp;#34;, num1, num1, &amp;amp;num1) num2 := new(int) //*int fmt.Printf(&amp;#34;類型=%T,值=%v,地址=%v\n&amp;#34;, num2, num2, &amp;amp;num2) //new用來分配類型 //make用來分配內存 } </description>
    </item>
    
    <item>
      <title>Redis基本操作</title>
      <link>https://yoziming.github.io/post/210810-agg-go-redis/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-redis/</guid>
      <description>Redis基本操作   本地在cmd輸入redis-cli啟動操作用戶端
  遠端連接:
  $ redis-cli -h host -p port -a password // 範例 $ redis-cli -h 127.0.0.1 -p 6379 -a &amp;#34;mypass&amp;#34;  PING測試連接  數據  數據結構類似JSON都是Key-Value 五大數據類型String、Hash、List、Set、Zset  String   最基本的字串，value最大值=512M
  指令:
  set(如果存在就相當於修改)
  get
  del (很多指令可以用tab協助完成)
  setex(幾秒後自毀)
    Hash 指令:
HSET key field value hget、hdel
一次設多項(空格隔開)hmset、hmget
hlen:統計有幾個元素
hexists:看field是否存在
List 是個有序的鏈表，元素的值可以重複，可以把東西加在頭或尾</description>
    </item>
    
    <item>
      <title>Reflect反射</title>
      <link>https://yoziming.github.io/post/210810-agg-go-reflect/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-reflect/</guid>
      <description>reflect反射 func reflectTest01(b interface{}) { //通過反射獲取傳入的各種訊息 //先拿reflect.Type rType := reflect.TypeOf(b) fmt.Println(&amp;#34;rType=&amp;#34;, rType) rVal := reflect.ValueOf(b) fmt.Println(&amp;#34;rVal=&amp;#34;, rVal) // n1:=10+rVal //rVal他看起來是int但其實是type reflect.Value n1 := 10 + rVal.Int() //用.Int()轉換後就可以了 // n3 := rVal.Float()//像這樣也不行的，一定要確認類型 fmt.Println(&amp;#34;n1=&amp;#34;, n1) // fmt.Println(&amp;#34;n3=&amp;#34;, n3) //把rVal轉回interface{} iV := rVal.Interface() n2 := iV.(int) fmt.Println(&amp;#34;n2=&amp;#34;, n2) } func reflectTest02(b interface{}) { //通過反射獲取傳入的各種訊息 //先拿reflect.Type rType := reflect.TypeOf(b) fmt.Println(&amp;#34;rType=&amp;#34;, rType) rVal := reflect.ValueOf(b) fmt.Println(&amp;#34;rVal=&amp;#34;, rVal) //把rVal轉回interface{} iV := rVal.Interface() //斷言回來 n2, ok := iV.</description>
    </item>
    
    <item>
      <title>RPC</title>
      <link>https://yoziming.github.io/post/210927-rpc/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210927-rpc/</guid>
      <description>server / 用接口，讓服務端註冊RPC的時候，就能確保他合法 type World struct{} func (w *World) HelloWorld(name string, resp *string) error { *resp = name + &amp;#34;你好&amp;#34; return nil // 如果這個return的返回值不為空， // 那無論傳出的參數是否有值，服務端都不會給東西 // (就你給你error) } // 用接口，讓服務端註冊RPC的時候，就能確保他合法 type MyInerface interface { HelloWorld(string *string) error } // 調用方法時，給i傳參，參數是實現HelloWorld方法的對象 func RegsiterService(i MyInerface) { rpc.RegisterName(&amp;#34;hello&amp;#34;, i) } func main() { // 1.註冊RPC服務 綁定對象方法 err := rpc.RegisterName(&amp;#34;hello&amp;#34;, new(World)) if err != nil { fmt.Println(&amp;#34;註冊RPC服務失敗&amp;#34;, err) } // 2.開始監聽 listener, err := net.</description>
    </item>
    
    <item>
      <title>Split切分字串</title>
      <link>https://yoziming.github.io/post/210810-agg-go-split/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-split/</guid>
      <description>Split切分字串 // abc,b=&amp;gt;[a c] func Split(str, sep string) []string { // str=&amp;#34;bsfcvjkhbafs&amp;#34; sep=&amp;#34;b&amp;#34; var ret = make([]string, 0, strings.Count(str, sep)+1) index := strings.Index(str, sep) for index &amp;gt;= 0 { ret = append(ret, str[:index]) str = str[index+len(sep):] index = strings.Index(str, sep) } ret = append(ret, str) return ret } </description>
    </item>
    
    <item>
      <title>Test單元測試</title>
      <link>https://yoziming.github.io/post/210810-agg-go-test/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-test/</guid>
      <description>Test單元測試  單元測試目的是驗證程式碼(例如一個方法)本身的邏輯是否正確 單元測試應排除外部依賴（Database、File System IO） 單元測試應該是隨時隨地都要能正確執行 單元測試的標題需要具備好的可讀性、明確、標題與測試的內容精確吻合 例：「public void GetTest_帶入會員ID＿應回該ID搜尋到的會員資料DTO」，盡量符合：受測方法＿傳入參數意義＿期望得到的結果 一個測試只應該關注一件事情，如果受測目標有多種狀況，應該分成好幾個測試去涵蓋所有邏輯   3A原則
  Arrange = 準備受測物件、參數、預期結果 Act = 執行受測方法 Assert = 驗證執行結果與預測結果是否一致  cal.go func addUpper(n int) int { res := 0 for i := 0; i &amp;lt;= n; i++ { res = +i } return res } func getSub(n1, n2 int) int { return n1 - n2 } cal_test.go func TestAddUpper(t *testing.T) { //調用 res := addUpper(10) if res !</description>
    </item>
    
    <item>
      <title>WaitGroup鎖</title>
      <link>https://yoziming.github.io/post/210810-agg-go-waitgroup/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-waitgroup/</guid>
      <description>WaitGroup鎖 讀寫鎖 var x = 0 var wg sync.WaitGroup var rwlock sync.RWMutex func write() { rwlock.Lock() x = x + 1 time.Sleep(time.Millisecond * 10) rwlock.Unlock() wg.Done() } func read() { // lock.Lock() rwlock.RLock() //鎖讀 time.Sleep(time.Millisecond) rwlock.RUnlock() // lock.Unlock() wg.Done() } func main() { start := time.Now() for i := 0; i &amp;lt; 10; i++ { wg.Add(1) go write() } for i := 0; i &amp;lt; 1000; i++ { wg.Add(1) go read() } wg.</description>
    </item>
    
    <item>
      <title>二維數組</title>
      <link>https://yoziming.github.io/post/210810-agg-go-array/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-array/</guid>
      <description>// 000000 // 001000 // 020300 // 000000 func main() { var arr [4][6]int arr[1][2] = 1 arr[2][1] = 2 arr[2][3] = 3 //遍歷 for i := 0; i &amp;lt; len(arr); i++ { for j := 0; j &amp;lt; len(arr[i]); j++ { fmt.Print(arr[i][j], &amp;#34; &amp;#34;) } fmt.Println() } //遍歷range for i, v := range arr { for j, v2 := range v { fmt.Printf(&amp;#34;arr[%v][%v]=%v \t&amp;#34;, i, j, v2) } fmt.</description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://yoziming.github.io/post/210810-agg-go-bubble-sort/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-bubble-sort/</guid>
      <description>冒泡排序 var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 6} func main() { s1 := arr1[:] bubbleSort(s1) fmt.Println(arr1) } func bubbleSort(x []int) { for j := 1; j &amp;lt; len(x); j++ { for i := 0; i &amp;lt; len(x)-1; i++ { if x[i] &amp;gt; x[i+1] { x[i], x[i+1] = x[i+1], x[i] } } } } </description>
    </item>
    
    <item>
      <title>函數封裝的金字塔</title>
      <link>https://yoziming.github.io/post/210810-agg-go-pyramid/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-pyramid/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; ) var input int func jin(input int) { for i := 1; i &amp;lt;= input; i++ { for k := 1; k &amp;lt;= input-i; k++ { fmt.Print(&amp;#34; &amp;#34;) } for j := 1; j &amp;lt;= 2*i-1; j++ { if j == 1 || j == 2*i-1 || i == input { fmt.Print(&amp;#34;*&amp;#34;) } else { fmt.Print(&amp;#34; &amp;#34;) } } fmt.Println() } } func main() { fmt.</description>
    </item>
    
    <item>
      <title>函數綁定方法</title>
      <link>https://yoziming.github.io/post/210810-agg-go-method/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-method/</guid>
      <description>函數綁定方法  方法:結構體的行為，自訂義的結構都可以有方法，方法是作用在指定類型上(綁定的)
方法就是跟一種類型綁定的函數，因為綁定數據類型了就可以偷雞，具體表現在省指針
定義方法時候寫的是func(a ABC) //後面怎樣調用都是值拷貝
定義方法時候寫的是func(a *ABC)//後面怎樣調用都是真實地址
要調用方法，只能透過那種類型的的數據變量 例如a1.ABC
 package main import ( &amp;#34;fmt&amp;#34; ) type Person struct { Name string } //給Person類型綁定一個方法 func (p Person) test() { p.Name = &amp;#34;jack&amp;#34; fmt.Println(&amp;#34;test()=&amp;#34;, p.Name) } //給Person類型添加一個speak方法，輸出xxx是好人 func (p Person) speak() { fmt.Println(p.Name, &amp;#34;是一個好人&amp;#34;) } //添加一個計算方法算+1...+100 func (p Person) count() { res := 0 for i := 1; i &amp;lt;= 100; i++ { res += i } fmt.Println(p.Name, &amp;#34;計算的結果是&amp;#34;, res) } //添加一個計算方法算+1.</description>
    </item>
    
    <item>
      <title>切片</title>
      <link>https://yoziming.github.io/post/210810-agg-go-slice/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-slice/</guid>
      <description>func main() { //切片的類型是引用(傳遞的時候也是引用地址) //切片長度可變(不像數組) var arr1 = [5]int{1, 2, 3, 4, 5} s1 := arr1[1:3] //表示切arr的[1 2] 左開右閉(含左不含右) //var slice=arr[0:end]簡寫[:end] //[start:len(arr)]=[start:] //[0:len(arr)]=[:] fmt.Println(&amp;#34;s1內容是&amp;#34;, s1) fmt.Println(&amp;#34;s1長度是&amp;#34;, len(s1)) fmt.Println(&amp;#34;s1容量是&amp;#34;, cap(s1)) fmt.Printf(&amp;#34;s1第一個地址是%p\n&amp;#34;, &amp;amp;s1[0]) fmt.Printf(&amp;#34;arr1[1]地址是%p\n&amp;#34;, &amp;amp;arr1[1]) s1[0] = 33 fmt.Println(&amp;#34;arr1內容是&amp;#34;, arr1) //var 切片名[]type=make([]type,len,cap) var s2 []float64 = make([]float64, 5, 10) fmt.Println(s2) //var 變量=make(類型) var s22 = make([]float64, 5, 10) fmt.Println(s22) var s3 []int = []int{1, 2, 3, 4, 5} fmt.Println(s3) //用append動態追加 s3 = append(s3, 6, 7, 8, 9) fmt.</description>
    </item>
    
    <item>
      <title>匿名函數與閉包</title>
      <link>https://yoziming.github.io/post/210810-agg-go-closure/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-closure/</guid>
      <description>匿名函數 func main() { res := func(n1, n2 int) int { return n1 + n2 }(10, 20) fmt.Println(res) a := func(n1, n2 int) int { return n1 - n2 } res = a(10, 5) fmt.Println(res) } 閉包 //累加器 func Add() func(int) int { //Add是一個函數，返回的數據類型是func(int) int var n int = 10 //返回的是一個匿名函數，那這個函數用到函數外的n，因此形成一個整體稱為閉包 return func(x int) int { n = n + x return n //閉包是類，函數是操作，n是字段，函數+使用n構成閉包 //n只初始化一次 } } func main() { a := Add() fmt.</description>
    </item>
    
    <item>
      <title>命令行參數Args&amp;Flag</title>
      <link>https://yoziming.github.io/post/210810-agg-go-args-flag/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-args-flag/</guid>
      <description>命令行參數Args&amp;amp;Flag func main() { fmt.Println(&amp;#34;命令行參數有&amp;#34;, len(os.Args)) //遍歷os.Args切片 得到所有輸入的參數值 for i, v := range os.Args { fmt.Printf(&amp;#34;args[%v]=%v\n&amp;#34;, i, v) } fmt.Println(&amp;#34;=====================&amp;#34;) //flag方法 先定義幾個變量用於接收參數值 var user string var pwd string var host string var port int flag.StringVar(&amp;amp;user, &amp;#34;u&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;帳號 預設為空&amp;#34;) flag.StringVar(&amp;amp;pwd, &amp;#34;pwd&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;密碼 預設為空&amp;#34;) flag.StringVar(&amp;amp;host, &amp;#34;h&amp;#34;, &amp;#34;localhost&amp;#34;, &amp;#34;主機 預設為localhost&amp;#34;) flag.IntVar(&amp;amp;port, &amp;#34;port&amp;#34;, 3306, &amp;#34;端口 預設為3306&amp;#34;) //前面有亂打的字就不行 比如...exe 12354 -u tom會調用預設 flag.Parse() //這個一定要調用 //輸出結果 fmt.Printf(&amp;#34;user=%v pwd=%v host=%v port=%v&amp;#34;, user, pwd, host, port) } </description>
    </item>
    
    <item>
      <title>字串轉換常用函數</title>
      <link>https://yoziming.github.io/post/210810-agg-go-string-conver/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-string-conver/</guid>
      <description>字串轉換常用函數  var str string = &amp;#34;abc123中文&amp;#34; func main() { fmt.Println(&amp;#34;長度=&amp;#34;, len(str)) r := []rune(str) for i := 0; i &amp;lt; len(r); i++ { fmt.Printf(&amp;#34;遍歷=%q\n&amp;#34;, r[i]) } //轉成整數 Atoi n, err := strconv.Atoi(&amp;#34;5421&amp;#34;) if err != nil { fmt.Println(&amp;#34;錯誤,err&amp;#34;) } else { fmt.Println(&amp;#34;轉換成&amp;#34;, n) //整數轉字串 str2 := strconv.Itoa(654231) fmt.Printf(&amp;#34;類型是%T\n&amp;#34;, str2) //轉byte var bytes = []byte(&amp;#34;hello&amp;#34;) fmt.Printf(&amp;#34;bytes=%v \n&amp;#34;, bytes) //byte轉回字串 str3 := string([]byte{97, 98, 99}) fmt.Printf(&amp;#34;str3=%v \n&amp;#34;, str3) //10進制轉2,8,16返回字串 str4 := strconv.</description>
    </item>
    
    <item>
      <title>實作練習-ini解析器</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-ini-parser/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-ini-parser/</guid>
      <description>用來解析.ini文檔格式是否有問題
 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;reflect&amp;#34; &amp;#34;strings&amp;#34; ) type RedisConfig struct { Host string `ini:&amp;#34;host&amp;#34;` Port int `ini:&amp;#34;port&amp;#34;` Password string `ini:&amp;#34;password&amp;#34;` Database int `ini:&amp;#34;database&amp;#34;` } type MysqlConfig struct { Address string `ini:&amp;#34;address&amp;#34;` Port int `ini:&amp;#34;port&amp;#34;` Password string `ini:&amp;#34;password&amp;#34;` Username string `ini:&amp;#34;username&amp;#34;` } type Config struct { MysqlConfig `ini:&amp;#34;mysql&amp;#34;` RedisConfig `ini:&amp;#34;redis&amp;#34;` } func loadIni(fileName string, data interface{}) (err error) { // 0. 參數校驗 // 0.1 傳來的data必須是結構體類型指針 t := reflect.</description>
    </item>
    
    <item>
      <title>實作練習-txt文本批次取代器</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-txt-replace/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-txt-replace/</guid>
      <description>實作練習-txt文本批次取代器  自己寫用來一次取代多個名詞，去除多餘空格或符號等等
 package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;os&amp;#34; &amp;#34;strings&amp;#34; ) var data []string = make([]string, 128) func main() { readByBufio() for _, v := range data { if v == &amp;#34;&amp;#34; { break } fmt.Print(v) } } func readByBufio() { file, err := os.Open(&amp;#34;C:/test.txt&amp;#34;) if err != nil { fmt.Printf(&amp;#34;os.Open err %s\n&amp;#34;, err) return } defer file.Close() reader := bufio.NewReader(file) for i := 0; ; i++ { line, err := reader.</description>
    </item>
    
    <item>
      <title>實作練習-多人聊天室</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-chatroom/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-chatroom/</guid>
      <description>實作練習-多人聊天室  本來很傻的檔案代碼一個一個貼，後來學了github的專案管理就放到那了
 https://github.com/yoziming/go-practice-chatroom</description>
    </item>
    
    <item>
      <title>實作練習-客戶名單管理系統</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-user-list/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-user-list/</guid>
      <description>實作練習-客戶名單管理系統 model type Customer struct { Id int Name string Gender string Age int Phone string Email string } //使用工廠模式返回一個實例 func NewCustomer(id int, name string, gender string, age int, phone string, email string) Customer { return Customer{ Id: id, Name: name, Gender: gender, Age: age, Phone: phone, Email: email, } } //返回用戶訊息 func (c Customer) GetInfo() string { info := fmt.Sprintf(&amp;#34;%v	%v	%v	%v	%v	%v&amp;#34;, c.Id, c.Name, c.Gender, c.Age, c.</description>
    </item>
    
    <item>
      <title>實作練習-家庭收支小app</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-family-count/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-family-count/</guid>
      <description>實作練習-家庭收支小app type MyMoney struct { key string //鍵入值 note string //收支說明 balance float64 //餘額 money float64 //收支 flag bool //判斷是否有明細 details string //詳細 loop bool //循環 } //綁定方法 func (mm *MyMoney) MainMenu() { for { if !mm.loop { break } fmt.Println(&amp;#34;\n-----------------家庭收支记账软件-----------------&amp;#34;) fmt.Println(&amp;#34; 1 收支明细&amp;#34;) fmt.Println(&amp;#34; 2 登记收入&amp;#34;) fmt.Println(&amp;#34; 3 登记支出&amp;#34;) fmt.Println(&amp;#34; 4 退出软件&amp;#34;) fmt.Print(&amp;#34;請選擇(1-4)...&amp;#34;) fmt.Scanln(&amp;amp;mm.key) switch mm.key { case &amp;#34;1&amp;#34;: mm.showDetails() case &amp;#34;2&amp;#34;: mm.income() case &amp;#34;3&amp;#34;: mm.outcome() case &amp;#34;4&amp;#34;: mm.exit() default: fmt.</description>
    </item>
    
    <item>
      <title>實作練習-點對點聊天</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-p2pchat/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-p2pchat/</guid>
      <description>實作練習-點對點聊天 server.go func main() { fmt.Println(&amp;#34;伺服器開始監聽&amp;#34;) listen, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;0.0.0.0:8888&amp;#34;) //0.0.0.0 寫4位ip v4 v6都能用 if err != nil { fmt.Println(&amp;#34;監聽失敗&amp;#34;, err) return } defer listen.Close() //主程式退出後就關閉監聽 // fmt.Printf(&amp;#34;listen succes=%v\n&amp;#34;, listen) for { //開啟監聽端口8888 time.Sleep(time.Microsecond) fmt.Println(&amp;#34;等待連接中...&amp;#34;) conn, err := listen.Accept() if err != nil { fmt.Println(&amp;#34;Accept()err=&amp;#34;, err) } else { fmt.Printf(&amp;#34;conn suc con=%v 客戶端ip=%v\n&amp;#34;, conn, conn.RemoteAddr().String()) } //準備啟動一個協程 go process(conn) } } func process(conn net.Conn) { //循環接收客戶端送來的數據 defer conn.Close() fmt.Printf(&amp;#34;伺服器等待%s客戶端輸入...\n&amp;#34;, conn.</description>
    </item>
    
    <item>
      <title>對有序數列進行二分查找</title>
      <link>https://yoziming.github.io/post/210810-agg-go-binary-search/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-binary-search/</guid>
      <description>//對有序數列進行二分查找 var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 0} func bubble(x []int) { for j := 1; j &amp;lt; len(x); j++ { for i := 0; i &amp;lt; len(x)-1; i++ { if x[i] &amp;gt; x[i+1] { x[i], x[i+1] = x[i+1], x[i] } } } } func bi(x int, s []int, left int, right int) { middle := (right + left) / 2 if left &amp;gt; right { fmt.</description>
    </item>
    
    <item>
      <title>工廠模式</title>
      <link>https://yoziming.github.io/post/210810-agg-go-factory/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-factory/</guid>
      <description>//工廠模式 // 假如有些要公用的東西又不想用大寫讓人隨意改了 例如結構體、結構體內的字段等等 // 我就在那個包裏建一個方法，這個方法本身大寫，在方法中原地調用那些本來是大寫的玩意 // 返回一個相同的值過來，相當於那在那個包里把該封裝的都封好，拿出來的就是產品 import ( &amp;#34;fmt&amp;#34; ) type Student struct { Name string Age int Score float64 } func (s *Student) Say() string { infoStr := fmt.Sprintf(&amp;#34;信息 name=[%v] age=[%v] score=[%v]&amp;#34;, s.Name, s.Age, s.Score) return infoStr } func main() { var s1 = Student{ Name: &amp;#34;tom&amp;#34;, Score: 98, Age: 18, //不依賴順序 } res := s1.Say() fmt.Println(res) //其他創建結構變量同時指定值的方法: stu2 := Student{&amp;#34;Jack&amp;#34;, 20, 100} //項目順序都要有對應 fmt.Println(stu2) //返回結構的指針 var stu3 = &amp;amp;Student{&amp;#34;Mary&amp;#34;, 28, 5} fmt.</description>
    </item>
    
    <item>
      <title>拷貝檔案</title>
      <link>https://yoziming.github.io/post/210810-agg-go-io-copy/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-io-copy/</guid>
      <description>拷貝一個檔案 //定義一個函數接收2個路徑 func CopyFile(dstFileName, srcFileName string) (written int64, err error) { srcFile, err := os.Open(srcFileName) if err != nil { fmt.Println(err) } defer srcFile.Close() //通過srcFile獲取到reader reader := bufio.NewReader(srcFile) //打開dstFileName dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666) if err != nil { fmt.Println(err) } //通過dstFile獲取到writer writer := bufio.NewWriter(dstFile) defer dstFile.Close() return io.Copy(writer, reader) } func main() { src := &amp;#34;C:/01.mkv&amp;#34; //原始檔 dst := &amp;#34;C:/food2.mkv&amp;#34; _, err := CopyFile(dst, src) if err == nil { fmt.</description>
    </item>
    
    <item>
      <title>接口interface</title>
      <link>https://yoziming.github.io/post/210810-agg-go-interface/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-interface/</guid>
      <description>接口interface  例如定義 只要滿足&amp;quot;會跑&amp;quot;且&amp;quot;會叫&amp;quot;的就是&amp;quot;動物&amp;quot;，
那不管你是啥玩意只要實現會跑跟會叫，我就當你是動物，就能用動物的接口去調用
 //接口內不能有變量，方法也不能實現 type Usb interface { //聲明兩個沒實現的方法 Start() Stop() } type Usb2 interface { //接口是不需要顯示聲明，只要能實現就都能調用 Start() Stop() //假如我多聲明一個沒實現的方法在接口內就不能調用 Test() //有方法沒實現，導致Usb2這個接口不能用 } type Phone struct { } //讓Phone實現USB接口的方法 func (p Phone) Start() { fmt.Println(&amp;#34;手機啟動&amp;#34;) } func (p Phone) Stop() { fmt.Println(&amp;#34;手機停止&amp;#34;) } type Camera struct { } func (c Camera) Start() { fmt.Println(&amp;#34;相機啟動~~&amp;#34;) } func (c Camera) Stop() { fmt.Println(&amp;#34;相機停止&amp;#34;) } //電腦 type Computer struct { } func (c Computer) Working(usb Usb) { //接受一個Usb的接口類型 //通過usb變量來調用Start等方法 fmt.</description>
    </item>
    
    <item>
      <title>數組</title>
      <link>https://yoziming.github.io/post/210810-agg-go-array1/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-array1/</guid>
      <description>數組 func main() { var n1 [3]int = [3]int{1, 2, 3} var n2 = [3]int{4, 5, 6} //長度聲明後就不能變化 var n3 = [...]int{7, 8, 9} //數組長度是類型的一部分 [3]int != [4]int var n4 = [...]string{0: &amp;#34;李四&amp;#34;, 1: &amp;#34;張三&amp;#34;, 5: &amp;#34;王武&amp;#34;} n5 := []int{5, 5, 5, 5, 5} //[]int 這樣定義其實是切片 fmt.Println(n1) fmt.Println(n2) fmt.Println(n3) fmt.Println(n4) fmt.Println(n5) n9 := fmt.Sprintf(&amp;#34;%.2f&amp;#34;, 9.888888) fmt.Println(n9) var score [5]float64 for i := 0; i &amp;lt; len(score); i++ { fmt.Println(&amp;#34;輸入成績&amp;#34;) fmt.Scanln(&amp;amp;score[i]) } for i := 0; i &amp;lt; len(score); i++ { fmt.</description>
    </item>
    
    <item>
      <title>文字檔案讀取寫入</title>
      <link>https://yoziming.github.io/post/210810-agg-go-io-reader/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-io-reader/</guid>
      <description>讀取 func main() { //打開一個文件 file, err := os.Open(&amp;#34;c:/test.txt&amp;#34;) //有人叫file對象/指針/文件句柄 if err != nil { fmt.Println(&amp;#34;open file err=&amp;#34;, err) } //看看文件是啥 fmt.Printf(&amp;#34;file=%v\n&amp;#34;, file) //退出函數就關閉文件 defer file.Close() //創建一個帶緩衝的reader，預設大小是4096 reader := bufio.NewReader(file) for { str, err := reader.ReadString(&amp;#39;\n&amp;#39;) //讀到換行就結束 fmt.Print(str) if err == io.EOF { //表示文件末尾 break } } fmt.Println(&amp;#34;\n讀取結束&amp;#34;) //用ioutil.ReadFile一次讀完 //這個包已經封裝了open跟close了，只適用在檔案大小不大的情境 file2 := &amp;#34;c:/test.txt&amp;#34; str2, err2 := ioutil.ReadFile(file2) if err2 != nil { fmt.Println(err) } fmt.Printf(&amp;#34;%s&amp;#34;, str2) //原本輸出是[]byte,用%s轉 //創建一個新檔案，寫入5句話 filePath := &amp;#34;c:/abc.</description>
    </item>
    
    <item>
      <title>文檔字符統計</title>
      <link>https://yoziming.github.io/post/210810-agg-go-txt/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-txt/</guid>
      <description>文檔字符統計 //保存結果用 type CharCount struct { ChCount int //英文字數 NumCount int // SpaceCount int OtherCount int } func main() { //思路 打開一個文件 創一個reader每讀取一行就去統計，將結果保存到一個結構體 fileName := &amp;#34;c:/abc.txt&amp;#34; file, err := os.Open(fileName) if err != nil { fmt.Println(err) return } defer file.Close() //來個實例 var count CharCount reader := bufio.NewReader(file) //開始讀取 for { str, err := reader.ReadString(&amp;#39;\n&amp;#39;) //這存在BUG 當行不換行做結尾就統計不到 if err == io.EOF { break } for _, v := range str { switch { case v &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; v &amp;lt;= &amp;#39;z&amp;#39;: fallthrough case v &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; v &amp;lt;= &amp;#39;Z&amp;#39;: count.</description>
    </item>
    
    <item>
      <title>日期時間</title>
      <link>https://yoziming.github.io/post/210810-agg-go-date-time/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-date-time/</guid>
      <description>日期時間 func main() { //1.獲取當前本地時間 now := time.Now() fmt.Printf(&amp;#34;now=%v,type=%T&amp;#34;, now, now) //返回的類型是struct //2.通過now獲取各種詳細 fmt.Printf(&amp;#34;年=%v,type=%T\n&amp;#34;, now.Year(), now.Year()) fmt.Printf(&amp;#34;月=%v,type=%T\n&amp;#34;, now.Month(), now.Month()) fmt.Printf(&amp;#34;月=%v,type=%T\n&amp;#34;, int(now.Month()), int(now.Month())) fmt.Printf(&amp;#34;日=%v,type=%T\n&amp;#34;, now.Day(), now.Day()) fmt.Printf(&amp;#34;時=%v,type=%T\n&amp;#34;, now.Hour(), now.Hour()) fmt.Printf(&amp;#34;分=%v,type=%T\n&amp;#34;, now.Minute(), now.Minute()) fmt.Printf(&amp;#34;秒=%v,type=%T\n&amp;#34;, now.Second(), now.Second()) fmt.Printf(&amp;#34;星期=%v,type=%T\n&amp;#34;, now.Weekday(), now.Weekday()) fmt.Printf(&amp;#34;星期=%v\n&amp;#34;, int(now.Weekday())) //3.格式化日期時間 dateStr := fmt.Sprintf(&amp;#34;年月日時分=%d-%d-%d %d:%d\n&amp;#34;, now.Year(), now.Month(), now.Day(), now.Minute(), now.Second()) fmt.Println(dateStr) //4.蛋疼的指定格式 fmt.Println(now.Format(&amp;#34;2006-01-02 15:04:05&amp;#34;)) fmt.Println(now.Format(&amp;#34;2006-01-02&amp;#34;)) fmt.Println(now.Format(&amp;#34;06&amp;#34;)) fmt.Println(now.Format(&amp;#34;01&amp;#34;)) fmt.Println(now.Format(&amp;#34;03&amp;#34;)) fmt.Println(now.Format(&amp;#34;01-02-06 03 04 05&amp;#34;)) //123456=月日時分秒年 //5.時間常量&amp;amp;休眠 //每隔固定時間打印數字，打到100退出 for i := 0; i &amp;lt;= 100; i++ { fmt.</description>
    </item>
    
    <item>
      <title>結構體</title>
      <link>https://yoziming.github.io/post/210810-agg-go-struct/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-struct/</guid>
      <description>結構體 type Cat struct { Name string Age int Color string // S1 []int //可以是切片 但是預設值為nil(沒分配空間，一樣要先make後才能用) } //結構體是一個值類型，預設是值拷貝，比如cat1跟cat2是獨立存在兩個空間 func main() { //創建Cat的變量 var cat1 Cat cat1.Name = &amp;#34;小花&amp;#34; cat1.Age = 18 cat1.Color = &amp;#34;花&amp;#34; fmt.Println(&amp;#34;cat1=&amp;#34;, cat1) // cat1.S1 = make([]int, 10) // cat1.S1[0] = 100 // fmt.Println(&amp;#34;cat1=&amp;#34;, cat1) //推薦方式 cat2 := Cat{&amp;#34;小黑&amp;#34;, 5, &amp;#34;black&amp;#34;} fmt.Println(cat2) //方法3 //var c *C=new(C) var cat3 *Cat = new(Cat) //因為cat3是一個指針 (*cat3).Name = &amp;#34;小白&amp;#34; //語法糖 cat3.Age也可以 ，不建議 cat3.</description>
    </item>
    
    <item>
      <title>繼承</title>
      <link>https://yoziming.github.io/post/210810-agg-go-inherit/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-inherit/</guid>
      <description>繼承 type Student struct { Name string Age int Score int //共有的字段 } type Pupil struct { Student //套入 Covid19 bool } type College struct { Student //套入指針效率更好 SexExp bool } func (stu *Student) ShowInfo() { fmt.Printf(&amp;#34;姓名=%v 年齡=%v 成績=%v\n&amp;#34;, stu.Name, stu.Age, stu.Score) } func (stu *Student) SetScore(s int) { stu.Score = s } func (p *Pupil) Test() { fmt.Println(&amp;#34;小學生考試&amp;#34;) } func main() { pupilA := &amp;amp;Pupil{} pupilA.Student.Name = &amp;#34;tome&amp;#34; pupilA.Student.Age = 8 pupilA.</description>
    </item>
    
    <item>
      <title>錯誤處理</title>
      <link>https://yoziming.github.io/post/210810-agg-go-err/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-err/</guid>
      <description>錯誤處理 func test() { 	//捕捉異常 	defer func() { 	//內置函數recover就是找是否異常 	if err := recover(); err != nil { //err不為空=有錯 	fmt.Println(&amp;#34;錯誤&amp;#34;, err) 	} 	}() 	n1 := 10 	n2 := 0 	res := n1 / n2 	fmt.Println(res) }  //讀取文件名稱，錯誤就報錯 func readConf(name string) (err error) { 	if name == &amp;#34;config.ini&amp;#34; { 	return nil 	} else { 	//返回自訂錯誤 	return errors.</description>
    </item>
    
    <item>
      <title>順序查找</title>
      <link>https://yoziming.github.io/post/210810-agg-go-sequential-search/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-sequential-search/</guid>
      <description>順序查找 func main() { names := [4]string{&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;D&amp;#34;} var input = &amp;#34;&amp;#34; fmt.Println(&amp;#34;輸入...&amp;#34;) fmt.Scanln(&amp;amp;input) //順序查找 // for i := 0; i &amp;lt; len(names); i++ { // if input == names[i] { // fmt.Printf(&amp;#34;找到%v,下標=%v \n&amp;#34;, input, i) // break // } else if i == len(names)-1 { // fmt.Println(&amp;#34;比對失敗...&amp;#34;) // } //順序查找2 index := -1 for i := 0; i &amp;lt; len(names); i++ { if input == names[i] { index = i break } } if index !</description>
    </item>
    
    <item>
      <title>Java UML類圖</title>
      <link>https://yoziming.github.io/post/220102-java-uml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220102-java-uml/</guid>
      <description>Java UML類圖  引用 https://blog.51cto.com/u_15060461/3937024
  思緒不清晰的時候，畫圖可以有效幫助解決問題 繪圖軟體推薦:draw.io，開源免費公認好用  也有線下版 https://github.com/jgraph/drawio-desktop/releases/tag/v16.1.2    類圖 ![uml (1)](uml (1).png)
 -:private，當前類 ~:default，同包 #:protected，可跨包的子類 +:public 斜體:抽象 _:static，靜態  關係圖 ![uml (2)](uml (2).png)
  空心三角形實線:extends繼承
  空心三角形虛線:implement實現接口
 或是棒棒糖    虛線箭頭:依賴，就是用到，比如用到它的屬性或作為方法參數、返回
 動物需要氧氣進行呼吸方法    實線箭頭:關聯，就是指向，類似SQL的外鍵
 人與身分證關聯    空心菱形+實線(箭頭):聚合，強調部分與整體，但部分可脫離整體
 菱形是整體，例如電視◇-遙控器 兩者生命週期不同，比如大雁群死了一個大雁還存在    實心菱形+實線(箭頭):組合，也是部分與整體，但強調不可脫離
 兩者生命週期一致，如鳥⬥-翅膀，人⬥-腦袋    類之間關係的強弱：依賴 &amp;lt; 關聯 &amp;lt; 聚合 &amp;lt; 組合 &amp;lt; 泛化（繼承）</description>
    </item>
    
  </channel>
</rss>
