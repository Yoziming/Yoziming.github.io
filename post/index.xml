<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 柚子茶室</title>
    <link>https://yoziming.github.io/post/</link>
    <description>Recent content in Posts on 柚子茶室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>yoziming</copyright>
    <lastBuildDate>Wed, 29 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://yoziming.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JDBC</title>
      <link>https://yoziming.github.io/post/211229-agg-jdbc-01/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211229-agg-jdbc-01/</guid>
      <description>JDBC  本筆記基於2019年9月的 尚硅谷JDBC核心技术(新版jdbc)
https://www.bilibili.com/video/BV1eJ411c7rf
  JDBC，全稱Java Database Connectivity 為java用來統一管理連接資料庫的接口  連接資料庫的步驟   從java連接到資料庫有3個要素:驅動、網址、帳號密碼
  先看範例，接著一項一項說明:
  @Test public void testConnection() throws Exception { //1.載入設定檔 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&amp;#34;jdbc.properties&amp;#34;); Properties pros = new Properties(); pros.load(is); //2.讀取配置資訊 String user = pros.getProperty(&amp;#34;user&amp;#34;); String password = pros.getProperty(&amp;#34;password&amp;#34;); String url = pros.getProperty(&amp;#34;url&amp;#34;); String driverClass = pros.getProperty(&amp;#34;driverClass&amp;#34;); //3.載入驅動 Class.forName(driverClass); //4.獲取連接 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); }  配置文件jdbc.properties  user=rootpassword=abc123url=jdbc:mysql://localhost:3306/testdriverClass=com.</description>
    </item>
    
    <item>
      <title>MySQL8新特性</title>
      <link>https://yoziming.github.io/post/211229-agg-mysql-14/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211229-agg-mysql-14/</guid>
      <description>MySQL8新特性概述  一樣跳過
 MySQL從5.7版本直接跳躍發佈了8.0版本，可見這是一個令人興奮的里程碑版本。MySQL 8版本在功能上做了顯著的改進與增強，開發者對MySQL的原始程式碼進行了重構，最突出的一點是多MySQL Optimizer優化器進行了改進。不僅在速度上得到了改善，還為使用者帶來了更好的性能和更棒的體驗。
1.1 MySQL8.0 新增特性 1. 更簡便的NoSQL支持 NoSQL泛指非關係型數據庫和資料存儲。隨著互聯網平臺的規模飛速發展，傳統的關係型數據庫已經越來越不能滿足需求。從5.6版本開始，MySQL就開始支援簡單的NoSQL存儲功能。MySQL 8對這一功能做了優化，以更靈活的方式實現NoSQL功能，不再依賴模式（schema）。
2. 更好的索引 在查詢中，正確地使用索引可以提高查詢的效率。MySQL 8中新增了隱藏索引和降冪索引。隱藏索引可以用來測試去掉索引對查詢性能的影響。在查詢中混合存在多列索引時，使用降冪索引可以提高查詢的性能。
3.更完善的JSON支援 MySQL從5.7開始支援原生JSON資料的存儲，MySQL 8對這一功能做了優化，增加了彙總函式JSON_ARRAYAGG()和JSON_OBJECTAGG()，將參數聚合為JSON陣列或物件，新增了行內操作符 -&amp;raquo;，是列路徑運算子 -&amp;gt;的增強，對JSON排序做了提升，並優化了JSON的更新操作。
4.安全和帳戶管理 MySQL 8中新增了caching_sha2_password 授權外掛程式、角色、密碼歷史記錄和FIPS模式支援，這些特性提高了資料庫的安全性和性能，使資料庫管理員能夠更靈活地進行帳戶管理工作。
5.InnoDB的變化 InnoDB是MySQL預設的存儲引擎，是事務型資料庫的首選引擎，支援事務安全表（ACID），支持行鎖定和外鍵。在MySQL 8 版本中，InnoDB在自增、索引、加密、鎖死、共用鎖等方面做了大量的改進和優化，並且支援原子資料定義語言（DDL），提高了資料安全性，對事務提供更好的支援。
6.資料字典 在之前的MySQL版本中，字典資料都存儲在中繼資料檔和非事務表中。從MySQL 8開始新增了交易資料字典，在這個字典裡存儲著資料庫物件資訊，這些資料字典存儲在內部事務表中。
7. 原子資料定義語句 MySQL 8開始支援原子資料定義語句（Automic DDL），即原子DDL。目前，只有InnoDB存儲引擎支援原子DDL。原子資料定義語句（DDL）將與DDL操作相關的資料字典更新、存儲引擎操作、二進位日誌寫入結合到一個單獨的原子事務中，這使得即使伺服器崩潰，事務也會提交或回滾。 使用支援原子操作的存儲引擎所創建的表，在執行DROP TABLE、CREATE TABLE、ALTER TABLE、 RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作時，都支援原子操作，即事務要麼完全操作成功，要麼失敗後回滾，不再進行部分提交。 對於從MySQL 5.7複製到MySQL 8 版本中的語句，可以添加IF EXISTS或IF NOT EXISTS語句來避免發生錯誤。
8.資源管理 MySQL 8開始支援創建和管理資源組，允許將伺服器內運行的執行緒分配給特定的分組，以便執行緒根據組內可用資源執行。組屬性能夠控制組內資源，啟用或限制組內資源消耗。資料庫管理員能夠根據不同的工作負載適當地更改這些屬性。 目前，CPU時間是可控資源，由“虛擬CPU”這個概念來表示，此術語包含CPU的核心數，超執行緒，硬體執行緒等等。伺服器在啟動時確定可用的虛擬CPU數量。擁有對應許可權的資料庫管理員可以將這些CPU與資源組關聯，並為資源組分配執行緒。 資源組元件為MySQL中的資源組管理提供了SQL介面。資源組的屬性用於定義資源組。MySQL中存在兩個預設組，系統組和使用者組，默認的組不能被刪除，其屬性也不能被更改。對於用戶自訂的組，資源組創建時可初始化所有的屬性，除去名字和類型，其他屬性都可在創建之後進行更改。 在一些平臺下，或進行了某些MySQL的配置時，資源管理的功能將受到限制，甚至不可用。例如，如果安裝了執行緒池外掛程式，或者使用的是macOS系統，資源管理將處於不可用狀態。在FreeBSD和Solaris系統中，資源執行緒優先順序將失效。在Linux系統中，只有配置了CAP_SYS_NICE屬性，資源管理優先順序才能發揮作用。
9.字元集支援 MySQL 8中默認的字元集由latin1更改為utf8mb4，並首次增加了日語所特定使用的集合，utf8mb4_ja_0900_as_cs。
10.優化器增強 MySQL優化器開始支援隱藏索引和降冪索引。隱藏索引不會被優化器使用，驗證索引的必要性時不需要刪除索引，先將索引隱藏，如果優化器性能無影響就可以真正地刪除索引。降冪索引允許優化器對多個列進行排序，並且允許排序順序不一致。
11.公用表運算式 公用表運算式（Common Table Expressions）簡稱為CTE，MySQL現在支持遞迴和非遞迴兩種形式的CTE。CTE通過在SELECT語句或其他特定語句前使用WITH語句對臨時結果集進行命名。</description>
    </item>
    
    <item>
      <title>觸發器Trigger</title>
      <link>https://yoziming.github.io/post/211228-agg-mysql-13/</link>
      <pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211228-agg-mysql-13/</guid>
      <description>觸發器Trigger  一樣跳過
 在實際開發中，我們經常會遇到這樣的情況：有 2 個或者多個相互關聯的表，如商品資訊和庫存資訊分別存放在 2 個不同的資料表中，我們在添加一條新商品記錄的時候，為了保證資料的完整性，必須同時在庫存表中添加一條庫存記錄。
這樣一來，我們就必須把這兩個關聯的操作步驟寫到程式裡面，而且要用事務包裹起來，確保這兩個操作成為一個原子操作，要麼全部執行，要麼全部不執行。要是遇到特殊情況，可能還需要對資料進行手動維護，這樣就很容易忘記其中的一步，導致資料缺失。
這個時候，咱們可以使用觸發器。**你可以創建一個觸發器，讓商品資訊資料的插入操作自動觸發庫存資料的插入操作。**這樣一來，就不用擔心因為忘記添加庫存資料而導致的資料缺失了。
1. 觸發器概述 MySQL從5.0.2版本開始支持觸發器。MySQL的觸發器和存儲過程一樣，都是嵌入到MySQL伺服器的一段程式。
觸發器是由事件來觸發某個操作，這些事件包括INSERT、UPDATE、DELETE事件。所謂事件就是指用戶的動作或者觸發某項行為。如果定義了觸發程式，當資料庫執行這些語句時候，就相當於事件發生了，就會自動激發觸發器執行相應的操作。
當對資料表中的資料執行插入、更新和刪除操作，需要自動執行一些資料庫邏輯時，可以使用觸發器來實現。
2. 觸發器的創建 2.1 創建觸發器語法 創建觸發器的語法結構是：
CREATETRIGGER觸發器名稱{BEFORE|AFTER}{INSERT|UPDATE|DELETE}ON表名FOREACHROW觸發器執行的語句塊;說明：
  表名：表示觸發器監控的物件。
  BEFORE|AFTER：表示觸發的時間。BEFORE 表示在事件之前觸發；AFTER 表示在事件之後觸發。
  INSERT|UPDATE|DELETE：表示觸發的事件。
 INSERT 表示插入記錄時觸發； UPDATE 表示更新記錄時觸發； DELETE 表示刪除記錄時觸發。    觸發器執行的語句塊：可以是單條SQL語句，也可以是由BEGIN…END結構組成的複合陳述式塊。
  2.2 代碼舉例 舉例1：
1、創建資料表：
CREATETABLEtest_trigger(idINTPRIMARYKEYAUTO_INCREMENT,t_noteVARCHAR(30));CREATETABLEtest_trigger_log(idINTPRIMARYKEYAUTO_INCREMENT,t_logVARCHAR(30));2、創建觸發器：創建名稱為before_insert的觸發器，向test_trigger資料表插入資料之前，向test_trigger_log資料表中插入before_insert的日誌資訊。
DELIMITER//CREATETRIGGERbefore_insertBEFOREINSERTONtest_triggerFOREACHROWBEGININSERTINTOtest_trigger_log(t_log)VALUES(&amp;#39;before_insert&amp;#39;);END//DELIMITER;3、向test_trigger資料表中插入資料
INSERTINTOtest_trigger(t_note)VALUES(&amp;#39;測試 BEFORE INSERT 觸發器&amp;#39;);4、查看test_trigger_log資料表中的資料
mysql&amp;gt;SELECT*FROMtest_trigger_log;+----+---------------+|id|t_log|+----+---------------+|1|before_insert|+----+---------------+1rowinset(0.00sec)舉例2：
1、創建名稱為after_insert的觸發器，向test_trigger資料表插入資料之後，向test_trigger_log資料表中插入after_insert的日誌資訊。
DELIMITER//CREATETRIGGERafter_insertAFTERINSERTONtest_triggerFOREACHROWBEGININSERTINTOtest_trigger_log(t_log)VALUES(&amp;#39;after_insert&amp;#39;);END//DELIMITER;2、向test_trigger資料表中插入資料。
INSERTINTOtest_trigger(t_note)VALUES(&amp;#39;測試 AFTER INSERT 觸發器&amp;#39;);3、查看test_trigger_log資料表中的資料
mysql&amp;gt;SELECT*FROMtest_trigger_log;+----+---------------+|id|t_log|+----+---------------+|1|before_insert||2|before_insert||3|after_insert|+----+---------------+3rowsinset(0.00sec)**舉例3：**定義觸發器“salary_check_trigger”，基於員工表“employees”的INSERT事件，在INSERT之前檢查將要添加的新員工薪資是否大於他領導的薪資，如果大於領導薪資，則報sqlstate_value為&amp;rsquo;HY000&amp;rsquo;的錯誤，從而使得添加失敗。
DELIMITER//CREATETRIGGERsalary_check_triggerBEFOREINSERTONemployeesFOREACHROWBEGINDECLAREmgrsalaryDOUBLE;SELECTsalaryINTOmgrsalaryFROMemployeesWHEREemployee_id=NEW.manager_id;IFNEW.salary&amp;gt;mgrsalaryTHENSIGNALSQLSTATE&amp;#39;HY000&amp;#39;SETMESSAGE_TEXT=&amp;#39;薪資高於領導薪資錯誤&amp;#39;;ENDIF;END//DELIMITER;上面觸發器聲明過程中的NEW關鍵字代表INSERT添加語句的新記錄。
3. 查看、刪除觸發器 3.1 查看觸發器 查看觸發器是查看資料庫中已經存在的觸發器的定義、狀態和語法資訊等。</description>
    </item>
    
    <item>
      <title>變量、流程控制與游標</title>
      <link>https://yoziming.github.io/post/211227-agg-mysql-12/</link>
      <pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211227-agg-mysql-12/</guid>
      <description>變量、流程控制與游標  一樣先跳過了
 1. 變數 在MySQL資料庫的存儲過程和函數中，可以使用變數來存儲查詢或計算的中間結果資料，或者輸出最終的結果資料。
在 MySQL 資料庫中，變數分為系統變數以及使用者自訂變數。
1.1 系統變數 1.1.1 系統變數分類 變數由系統定義，不是使用者定義，屬於伺服器層面。啟動MySQL服務，生成MySQL服務實例期間，MySQL將為MySQL伺服器記憶體中的系統變數賦值，這些系統變數定義了當前MySQL服務實例的屬性、特徵。這些系統變數的值要麼是編譯MySQL時參數的預設值，要麼是設定檔（例如my.ini等）中的參數值。大家可以通過網址 https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html 查看MySQL文檔的系統變數。
系統變數分為全域系統變數（需要添加global 關鍵字）以及會話系統變數（需要添加 session 關鍵字），有時也把全域系統變數簡稱為全域變數，有時也把會話系統變數稱為local變數。**如果不寫，默認會話級別。**靜態變數（在 MySQL 服務實例運行期間它們的值不能使用 set 動態修改）屬於特殊的全域系統變數。
每一個MySQL客戶機成功連接MySQL伺服器後，都會產生與之對應的會話。會話期間，MySQL服務實例會在MySQL伺服器記憶體中生成與該會話對應的會話系統變數，這些會話系統變數的初始值是全域系統變數值的複製。如下圖：
 全域系統變數針對於所有會話（連接）有效，但不能跨重啟 會話系統變數僅針對於當前會話（連接）有效。會話期間，當前會話對某個會話系統變數值的修改，不會影響其他會話同一個會話系統變數的值。 會話1對某個全域系統變數值的修改會導致會話2中同一個全域系統變數值的修改。  在MySQL中有些系統變數只能是全域的，例如 max_connections 用於限制伺服器的最大連接數；有些系統變數作用域既可以是全域又可以是會話，例如 character_set_client 用於設置用戶端的字元集；有些系統變數的作用域只能是當前會話，例如 pseudo_thread_id 用於標記當前會話的 MySQL 連接 ID。
1.1.2 查看系統變數  查看所有或部分系統變數  #查看所有全域變數 SHOWGLOBALVARIABLES;#查看所有會話變數 SHOWSESSIONVARIABLES;或SHOWVARIABLES;#查看滿足條件的部分系統變數。 SHOWGLOBALVARIABLESLIKE&amp;#39;%識別字%&amp;#39;;#查看滿足條件的部分會話變數 SHOWSESSIONVARIABLESLIKE&amp;#39;%識別字%&amp;#39;;舉例：
SHOWGLOBALVARIABLESLIKE&amp;#39;admin_%&amp;#39;; 查看指定系統變數  作為 MySQL 編碼規範，MySQL 中的系統變數以兩個“@”開頭，其中“@@global”僅用於標記全域系統變數，“@@session”僅用於標記會話系統變數。“@@”首先標記會話系統變數，如果會話系統變數不存在，則標記全域系統變數。
#查看指定的系統變數的值 SELECT@@global.變數名;#查看指定的會話變數的值 SELECT@@session.變數名;#或者 SELECT@@變數名; 修改系統變數的值  有些時候，資料庫管理員需要修改系統變數的預設值，以便修改當前會話或者MySQL服務實例的屬性、特徵。具體方法：
方式1：修改MySQL設定檔，繼而修改MySQL系統變數的值（該方法需要重啟MySQL服務）
方式2：在MySQL服務運行期間，使用“set”命令重新設置系統變數的值
#為某個系統變數賦值 #方式1： SET@@global.變數名=變數值;#方式2： SETGLOBAL變數名=變數值;#為某個會話變數賦值 #方式1： SET@@session.</description>
    </item>
    
    <item>
      <title>預存程序Procedure與自訂函數Function</title>
      <link>https://yoziming.github.io/post/211226-agg-mysql-11/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211226-agg-mysql-11/</guid>
      <description>存儲過程與函數  就是巨集Macro啦，這部分我暫時用不到，先直接貼上筆記過眼完事了，以後有用到再回來補
 MySQL從5.0版本開始支援存儲過程和函數。存儲過程和函數能夠將複雜的SQL邏輯封裝在一起，應用程式無須關注存儲過程和函數內部複雜的SQL邏輯，而只需要簡單地調用存儲過程和函數即可。
1. 存儲過程概述 1.1 理解 含義：存儲過程的英文是 Stored Procedure。它的思想很簡單，就是一組經過預先編譯的 SQL 語句的封裝。
執行過程：存儲過程預先存儲在 MySQL 伺服器上，需要執行的時候，用戶端只需要向伺服器端發出調用存儲過程的命令，伺服器端就可以把預先存儲好的這一系列 SQL 語句全部執行。
好處：
1、簡化操作，提高了sql語句的重用性，減少了開發程式師的壓力 2、減少操作過程中的失誤，提高效率 3、減少網路傳輸量（用戶端不需要把所有的 SQL 語句通過網路發給伺服器） 4、減少了 SQL 語句暴露在網上的風險，也提高了資料查詢的安全性
和視圖、函數的對比：
它和視圖有著同樣的優點，清晰、安全，還可以減少網路傳輸量。不過它和視圖不同，視圖是虛擬表，通常不對底層資料表直接操作，而存儲過程是程式化的 SQL，可以直接操作底層資料表，相比于面向集合的操作方式，能夠實現一些更複雜的資料處理。
一旦存儲過程被創建出來，使用它就像使用函數一樣簡單，我們直接通過調用存儲過程名即可。相較於函數，存儲過程是沒有返回值的。
1.2 分類 存儲過程的參數類型可以是IN、OUT和INOUT。根據這點分類如下：
1、沒有參數（無參數無返回） 2、僅僅帶 IN 類型（有參數無返回） 3、僅僅帶 OUT 類型（無參數有返回） 4、既帶 IN 又帶 OUT（有參數有返回） 5、帶 INOUT（有參數有返回）
注意：IN、OUT、INOUT 都可以在一個存儲過程中帶多個。
2. 創建存儲過程 2.1 語法分析 語法：
CREATEPROCEDURE存儲過程名(IN|OUT|INOUT參數名參數類型,...)[characteristics...]BEGIN存儲過程體END類似於Java中的方法：
修飾符返回類型方法名(參數類型參數名,...){方法體;}說明：
1、參數前面的符號的意思
  IN：當前參數為輸入參數，也就是表示入參；
存儲過程只是讀取這個參數的值。如果沒有定義參數種類，默認就是 IN，表示輸入參數。
  OUT：當前參數為輸出參數，也就是表示出參；
執行完成之後，調用這個存儲過程的用戶端或者應用程式就可以讀取這個參數返回的值了。
  INOUT：當前參數既可以為輸入參數，也可以為輸出參數。</description>
    </item>
    
    <item>
      <title>視圖View</title>
      <link>https://yoziming.github.io/post/211225-agg-mysql-10/</link>
      <pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211225-agg-mysql-10/</guid>
      <description>視圖View  視圖 = 存儲起來的select語句
  就是創建一張專門用來看的虛擬表 涉及的表稱為基表，基表也可以是視圖(可以嵌套作圖) 對視圖進行DML操作，會影響基表中的資料，反之亦然  但通常不會在視圖對資料進行操作，並且可以指定關閉這種權限   刪除視圖不影響基表  創建視圖 CREATE[ORREPLACE][ALGORITHM={UNDEFINED|MERGE|TEMPTABLE}]VIEW視圖名稱[(欄位清單)]AS查詢語句[WITH[CASCADED|LOCAL]CHECKOPTION]-- 如果查詢基表時用了別名，那創出來的視圖欄位名稱就會是別名 createviewemployees_viewasselectlast_name&amp;#39;姓名&amp;#39;,employee_id&amp;#39;員工編號&amp;#39;fromatguigudb.employees;-- 年薪 createviewyear_salary(name,year_salary)asselectemployees.last_name,salary*12*(1+ifnull(commission_pct,0))fromatguigudb.employees;-- 多表聯合 CREATEVIEWdept_sum_vu(name,minsal,maxsal,avgsal)ASSELECTd.department_name,MIN(e.salary),MAX(e.salary),AVG(e.salary)FROMemployeese,departmentsdWHEREe.department_id=d.department_idGROUPBYd.department_name;-- 格式化輸出 CREATEVIEWemp_departASSELECTCONCAT(last_name,&amp;#39;任職於&amp;#39;,department_name,&amp;#39;ㄅ&amp;#39;)ASemp_deptFROMemployeeseJOINdepartmentsdWHEREe.department_id=d.department_id查看視圖屬性 DESC/DESCRIBE視圖名稱;-- 查看視圖的屬性資訊 SHOWTABLESTATUSLIKE&amp;#39;視圖名稱&amp;#39;;-- 查看視圖的詳細定義資訊 SHOWCREATEVIEW視圖名稱;修改視圖內的資料  一般來說不會這麼做，了解即可
  如果是一對一關係的視圖，且有權限的話，可以使用INSERT、UPDATE和DELETE語句去修改其中的資料 有以下情況則不可修改:  在定義視圖的時候指定了“ALGORITHM = TEMPTABLE”，視圖將不支援INSERT和DELETE操作 視圖中不包含基表中所有被定義為非空又未指定預設值的列，視圖將不支援INSERT操作 在定義視圖的SELECT語句中使用了JOIN聯集查詢，視圖將不支援INSERT和DELETE操作 在定義視圖的SELECT語句後的欄位清單中使用了數學運算式或子查詢，視圖將不支援INSERT，也不支援UPDATE使用了數學運算式、子查詢的欄位值 在定義視圖的SELECT語句後的欄位清單中使用DISTINCT、彙總函式、GROUP BY、HAVING、UNION等，視圖將不支持INSERT、UPDATE、DELETE 在定義視圖的SELECT語句中包含了子查詢，而子查詢中引用了FROM後面的表，視圖將不支援INSERT、UPDATE、DELETE 視圖定義基於一個不可更新視圖 常量視圖    刪改視圖 -- 修改方法1 CREATEORREPLACEVIEW視圖名稱AS-- ...查詢語句 -- 修改方法2 ALTERVIEW視圖名稱AS-- ...查詢語句 -- 刪除 DROPVIEWIFEXISTS視圖名稱小結   視圖的優點:
  簡化操作:能夠分解複雜的查詢操作</description>
    </item>
    
    <item>
      <title>MySQL資料類型詳述</title>
      <link>https://yoziming.github.io/post/211223-agg-mysql-08/</link>
      <pubDate>Thu, 23 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211223-agg-mysql-08/</guid>
      <description>資料類型詳述  這節為了解型的知識點，有些筆記我直接複製貼上了 康師父這節講得太細，趕時間直接看最底的結論(對應教學影片p65) 用語注意:byte = 8 bit = 字節 = 位元組  MySQL中的資料類型    類型 類型舉例     整數類型 TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT   浮點類型 FLOAT、DOUBLE   定點數類型 DECIMAL   位類型 BIT   日期時間類型 YEAR、TIME、DATE、DATETIME、TIMESTAMP   文本字串類型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT   枚舉類型 ENUM   集合類型 SET   二進位字串類型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB   JSON類型 JSON物件、JSON陣列   空間資料類型 單值:GEOMETRY、POINT、LINESTRING、POLYGON；集合:MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION     常見資料類型的屬性，如下:     MySQL關鍵字 含義     NULL 數據列可包含NULL值   NOT NULL 資料列不允許包含NULL值   DEFAULT 預設值   PRIMARY KEY 主鍵   AUTO_INCREMENT 自動遞增，適用於整數類型   UNSIGNED 無符號   CHARACTER SET name 指定一個字符集    整數類型   整數類型一共有 5 種，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</description>
    </item>
    
    <item>
      <title>資料的增/刪/改</title>
      <link>https://yoziming.github.io/post/211222-agg-mysql-07/</link>
      <pubDate>Wed, 22 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211222-agg-mysql-07/</guid>
      <description>資料的操作 新增資料  使用INSERT INTO語句  插入一條完整的資料  完整即是此筆資料包含所有欄位的意思
  格式:  insertinto表名values(value1,value2,....); values是正規語法，也可以省略s 內容(value1,value2,....)的順序必須嚴格依照表的欄位順序 字符與日期的資料類型必須包在&#39;&#39;單引號中  插入指定欄位的資料  格式:  insertinto表名(欄位名1,欄位名2,...)values(value1,value2,....); 內容(value1,value2,....)的順序必須嚴格依照表的欄位順序 上面有列出的，下面就要填入  插入多條資料  執行效率更高，推薦使用
 INSERTINTOtable_name(column1[,column2,…,columnn])VALUES(value1[,value2,…,valuen]),(value1[,value2,…,valuen]),……(value1[,value2,…,valuen]); 使用INSERT同時插入多條記錄時，MySQL會返回一些在執行單行插入時沒有的額外資訊，這些資訊的含義如下:  Records:表明插入的記錄條數 Duplicates:表明插入時被忽略的記錄，原因可能是這些記錄包含了重複的主鍵值 Warnings:表明有問題的資料值，例如發生資料類型轉換    將查詢結果做為資料插入  格式:  INSERTINTO目標表名(tar_column1[,tar_column2,…,tar_columnn])SELECT(src_column1[,src_column2,…,src_columnn])FROM源表名[WHEREcondition] 注意沒有values了 查詢的欄位與插入的欄位需對應，例如:  並且要特別注意資料的長度，把長的資料放到短的格子可能出錯    INSERTINTOsales_reps(id,name,salary,commission_pct)SELECTemployee_id,last_name,salary,commission_pctFROMemployeesWHEREjob_idLIKE&amp;#39;%REP%&amp;#39;;/* sales_reps中的id對應查來的employee_id ... */ 更新資料  使用UPDATE語句更新資料，格式:  UPDATEtable_nameSETcolumn1=value1,column2=value2,…,column=valuen[WHEREcondition] 可以一次更新多條資料 如果需要回滾資料，需要保證在DML前，進行設置SET AUTOCOMMIT = FALSE;，防止自動提交 使用WHERE子句指定需要更新的資料  UPDATEemployeesSETdepartment_id=70WHEREemployee_id=113; 如果省略WHERE子句，則表中的所有資料都將被更新，慎用!!!  UPDATEcopy_empSETdepartment_id=110; 更新中的資料完整性錯誤  有些欄位可能受到約束影響，比如department_id是源自departments表，其中沒有id為110的項目，所以這樣更新就會報錯    UPDATEemployeesSETdepartment_id=55WHEREdepartment_id=110; 刪除資料  實際開發中都是用邏輯刪除，就是建一個欄位表示&amp;quot;刪除&amp;quot;，要刪的那筆資料&amp;quot;刪除&amp;quot;=true。基本上不會用到這些指令的</description>
    </item>
    
    <item>
      <title>資料庫的具體結構、創建與管理</title>
      <link>https://yoziming.github.io/post/211221-agg-mysql-06/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211221-agg-mysql-06/</guid>
      <description>資料庫的結構  所謂資料庫的具體結構層級如下:  DBMS資料庫管理系統 &amp;gt; database資料庫 &amp;gt; table表 &amp;gt; column欄位   創建database、table、column都需要自己命名  命名規則  庫名、表名不得超過30字符；變量限制為29字符 只能包含大小寫英數字與_下劃線 不可包含空格 同一DBM中庫不可重名，同一庫中表不可重名，同一表中字段不可重名 不可與關鍵字、保留字等衝突 命名與資料類型須保持一致性  常用的幾類類型:       資料類型 描述     INT 從-2^31到2^31-1的整型數據。存儲大小為 4個位元組   CHAR(size) 定長字元資料。若未指定，預設為1個字元，最大長度255   VARCHAR(size) 可變長字元資料，根據字串實際長度保存，必須指定長度   FLOAT(M,D) 單精確度，佔用4個位元組，M=整數位元+小數位，D=小數位。 D&amp;lt;=M&amp;lt;=255,0&amp;lt;=D&amp;lt;=30，默認M+D&amp;lt;=6   DOUBLE(M,D) 雙精度，佔用8個位元組，D&amp;lt;=M&amp;lt;=255,0&amp;lt;=D&amp;lt;=30，默認M+D&amp;lt;=15   DECIMAL(M,D) 高精度小數，佔用M+2個位元組，D&amp;lt;=M&amp;lt;=65，0&amp;lt;=D&amp;lt;=30，最大取值範圍與DOUBLE相同。   DATE 日期型資料，格式&amp;rsquo;YYYY-MM-DD&#39;   BLOB 二進位形式的長文本資料，最大可達4G   TEXT 長文本資料，最大可達4G     database庫的指令  必須具備相應權限</description>
    </item>
    
    <item>
      <title>子查詢Subquery</title>
      <link>https://yoziming.github.io/post/211220-agg-mysql-05/</link>
      <pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211220-agg-mysql-05/</guid>
      <description>子查詢Subquery  查中有查，以某查完的結果作為比較項目來查
  用一對()括號包起來 子查詢在主查詢之前先執行了一次 子查詢放在比較條件的右側 多行操作就對應多行子查詢  分類   依照內查詢返回的條目數:
 單行:返回一條結果 多行:返回多行結果    依照內查詢是否被執行多次:
  相關:查詢工資是否大於其部門平均(每個人部門不同，都要查各自的)
  不相關:查詢工資是否大於2000(每個人固定跟2000比較)
    單行子查詢  內查詢返回一條結果，外查詢跟這條結果比較 比較符:=等於、大小於等於、不等於 舉例:  -- 查詢薪水比&amp;#34;員工ID143號的薪水&amp;#34;還多的 selectsalary,job_id,employee_idfromemployeeswheresalary&amp;gt;(selectsalaryfromemployeeswhereemployee_id=143);-- 返回&amp;#34;job_id與141號員工相同&amp;#34;且&amp;#34;salary比143號員工多的&amp;#34; selectsalary,job_id,employee_idfromemployeeswheresalary&amp;gt;(selectsalaryfromemployeeswhereemployee_id=143)andjob_id=(selectjob_idfromemployeeswhereemployee_id=141);-- 查詢工資最少的 selectlast_name,job_id,salaryfromemployeeswheresalary=(selectmin(salary)fromemployees);-- 查詢管理人與部門ID跟編號141相同的 selectemployee_id,manager_id,department_idfromemployeeswheremanager_id=(selectmanager_idfromemployeeswhereemployee_id=141)anddepartment_id=(selectdepartment_idfromemployeeswhereemployee_id=141)andemployee_id!=141;-- 注意排除自己本身 -- 返回每個部門的最低工資，條件限制&amp;#34;比部門編號50的最低薪資&amp;#34;還高 selectdepartment_id,min(salary)fromemployeesgroupbydepartment_idhavingmin(salary)&amp;gt;(selectmin(salary)fromemployeeswheredepartment_id=50); HAVING、CASE也都可以使用 如果子查詢結果為null，那不返回任何東西 (與null比較必為null)  多行子查詢  也稱為集合比較子查詢 內查詢返回多行結果 使用多行比較操作符，因為返回很多條所以沒得等於，不然要等於哪個?     操作符 含義     IN 等於列表中的任意一個   ANY 需要和單行比較操作符一起使用，和子查詢返回的某一個值比較   ALL 需要和單行比較操作符一起使用，和子查詢返回的所有值比較   SOME 實際上是ANY的別名，作用相同，一般常使用ANY     舉例:  -- 返回其它job_id中比job_id為IT_PROG任一工資低的員工的員工號、job_id 以及salary** -- 其實相當於&amp;lt; IT_PROG中工資的max selectemployee_id,job_id,salaryfromemployeeswheresalary&amp;lt;any(selectsalaryfromemployeeswherejob_id=&amp;#39;IT_PROG&amp;#39;)andjob_id!</description>
    </item>
    
    <item>
      <title>常用函數:數值/字串/時間/流程控制...等</title>
      <link>https://yoziming.github.io/post/211219-agg-mysql-04/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211219-agg-mysql-04/</guid>
      <description>函數  日後有需要用到的函數大多可以在這裡查到
  根據輸入的資訊，返回某種結果 函數在不同的DBMS(資料庫軟體)之間的差距很大，使用時要注意移植性， 以下都是基於MySQL  常見分類  依照資料類型:數值、字符串、時間日期 依照功能:流程控制、加密解密、獲取信息 依照輸入資料的行數:單行、多行(聚合)  單行函數  對一行資料進行變換、每行返回一個結果  例如:想知道每個員工的工作年資，具體作法為現在時間減去員工入職時間，就可以調用時間相關的函數   單行函數可以嵌套使用   範例太多我就複製貼上了，先過眼了解，有用到時不熟悉再來查
 1. 數值    函數 用法     ABS(x) 返回x的絕對值   SIGN(X) 返回X的符號。正數返回1，負數返回-1，0返回0   PI() 返回圓周率的值   CEIL(x)，CEILING(x) 返回大於或等於某個值的最小整數   FLOOR(x) 返回小於或等於某個值的最大整數   LEAST(e1,e2,e3…) 返回列表中的最小值   GREATEST(e1,e2,e3…) 返回列表中的最大值   MOD(x,y) 返回X除以Y後的餘數   RAND() 返回0~1的隨機值，每次都不同   RAND(x) 返回0~1的隨機值，其中x的值用作種子值，相同的X值會產生相同的亂數   ROUND(x) 返回一個對x的值進行四捨五入後，最接近於X的整數   ROUND(x,y) 返回一個對x的值進行四捨五入後最接近X的值，並保留到小數點後面Y位   TRUNCATE(x,y) 返回數字x截斷為y位元小數的結果   SQRT(x) 返回x的平方根。當X的值為負數時，返回NULL    2.</description>
    </item>
    
    <item>
      <title>多表查詢、JOIN ON連接</title>
      <link>https://yoziming.github.io/post/211218-agg-mysql-03/</link>
      <pubDate>Sat, 18 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211218-agg-mysql-03/</guid>
      <description>多表查詢  從多張表格的查詢結果，連結彙整成一個表
 前提  需要有連接條件  沒有正確的連接條件，則會變成每個元素都相乘得出超爆量的結果，數學上稱這種集合為笛卡爾積，例如貓、狗X黑、白、黃的排列組合   正確連接舉例:員工表中有部門ID，部門表有部門ID，用其串聯顯示部門名稱  SELECTe.employee_id,d.department_id,d.department_nameFROMemployeese,departmentsdWHEREe.department_id=d.department_idORDERBYemployee_id; 如果查詢的表中，多個表都有同一字段，必須指明所在的表，此例中d.department_id就是必須指明的，否則報錯  為了提高效率與可讀性，使用字段最好都指名來源表   最好使用別名，並且一但起了別名就必須使用別名，否則報錯 當想實現N個表的多表查詢，必須至少有N-1個連接條件，例如:  SELECTe.employee_id,d.department_id,d.department_name,l.cityFROMemployeese,departmentsd,locationslWHEREe.department_id=d.department_id&amp;amp;&amp;amp;d.location_id=l.location_idORDERBYemployee_id;分類 等值 vs 非等值 -- 非等值舉例，比如在某個範圍之內 SELECTe.employee_id,e.last_name,j.grade_levelFROMemployeese,job_gradesjWHEREe.salary&amp;gt;=j.lowest_sal&amp;amp;&amp;amp;e.salary&amp;lt;=j.highest_salORDERBYemployee_id;自連接 vs 非自連接 -- 自連接舉例，將同一張表拆成2個別名 SELECTemp.employee_id,emp.last_name,mgr.employee_id,mgr.last_nameFROMemployeesemp,employeesmgrWHEREemp.`manager_id`=mgr.`employee_id`;內連接 vs 外連接  內連接:就是小時候excel用的VLOOKUP，返回的是兩個表都有匹配到的項目 外連接:返回包含不匹配的部分，又分左、右、全，還是上圖吧  當看到描述為查詢&amp;quot;所有&amp;ldquo;的XXX就要想到應該是外連接      這個用(+)實現左外連是SQL92語法，但MySQL不認，必須使用JOIN ... ON，下面詳述
  又MySQL不支援FULL OUTER JOIN，還需要關鍵字UNION輔助
  實現  這張圖基本上已經說明一切
 JOIN &amp;hellip; ON  用來取代WHERE a=b的用法 舉例:  select*fromemployeesinnerjoindepartmentsdond.department_id=employees.department_id; 通常把列數較多的放在A然後使用left join  UNION  可以合併多個SELECT的結果，前提是他們的列數與對應的數據類型相同 格式:  SELECTcolumn,.</description>
    </item>
    
    <item>
      <title>SQL語言基本關鍵字、排序與分頁</title>
      <link>https://yoziming.github.io/post/211217-agg-mysql-02/</link>
      <pubDate>Fri, 17 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211217-agg-mysql-02/</guid>
      <description>SQL  Structured Query Language，是一種通用的資料庫查詢語言
 分類  DDL:數據定義語言，定義數據庫或表本身，例如  CREATE、ALTER、DROP、RENAME、TRUNCATE   DML:數據操作語言，即增刪改查，針對的是具體的某條資料，例如  INSERT、DELETE、UPDATE、SELECT   DCL:數據控制語言，事務操作或權限控制等等，例如  COMMIT、ROLLBACK、SAVEPOINT、GRANT、REVOKE    標準  最經典的版本是SQL92與SQL99，一般也稱為SQL-2與SQL-3標準  SQL92形式簡單但語句長，難讀 SQL99版可讀性好，但語法較複雜    規則與規範   可以一行或多行，子句分行縮進增加可讀性
  每條命令用;、\G或\g結束
  標點符號
 必定成對，例如&#39;&#39;、() 必定是半形符號 字串和時間日期用&#39;&#39;單引號表示 列的別名盡量使用&amp;quot;&amp;quot;雙引號，且不建議省略as    大小寫
 Windows不分，Linux區分且規則如下:  數據庫名、表名、表別名、變數名區分 關鍵字、函數名、列名是忽略大小寫   建議規範  數據庫名、表名、表別名、字段名都用小寫 SQL關鍵字、函數名、綁定變數都大寫    註釋 單行:-- 註釋體，注意--後面有一個空格 多行:*/註釋體*/MySQL特有:#  關鍵字 SELECT  功能:查、列出 格式:  SELECT列名FROM表名;SELECT*FROM表名;-- 列出全部  FROM:來源表 FROM DUAL;返回一個偽表(暫時的)  AS  功能:暫時將返回的列名顯示成別名 格式:  SELECT列名AS&amp;#34;想顯示的別名&amp;#34;from表名;SELECT列名&amp;#34;想顯示的別名&amp;#34;from表名;-- 省略AS SELECT列名想顯示的別名from表名;-- 省略&amp;#34;&amp;#34;，但注意別名不能有空格  注意:並不是真的給某資料庫的某表某列賦了別名，只是暫時顯示來看而已  DISTINCT  功能:去重複 格式:  SELECTDISTINCT列名FROM表名;-- 聯合去重複，須滿足所有列的元素都不重複 SELECTDISTINCT列名1,列名2FROM表名;null  null不等於0 當null參與運算，結果必然也是空 解決方案:IFNULL(列名,備胎)  ‘‘單引號  注重符  功能:如果表名或字段名跟關鍵字衝突了，用其避開 格式:SELECT * FROM order;   查詢常數  功能:可以用作分隔之類的，沒多大意義 格式:    SELECTemp_no,&amp;#39;分隔&amp;#39;,first_name,&amp;#39;間隔&amp;#39;FROMemployees;DESCRIBE  功能:返回表的詳細結構與說明 格式:DESCRIBE 表名;、DESC 表名;  WHERE  功能:過濾 格式:  SELECT*FROM表WHERE條件;-- 範例 SELECT*FROMemployeesWHEREfirst_name=&amp;#39;georgi&amp;#39;; 注意WHERE必定聲明在FROM之後 MySQL中，篩字串不分大小寫  運算符號  先乘除後加減，沒特別的就不提了，與常規經驗一致</description>
    </item>
    
    <item>
      <title>MySQL簡介、環境配置、編碼與GUI</title>
      <link>https://yoziming.github.io/post/211216-agg-mysql-01/</link>
      <pubDate>Thu, 16 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211216-agg-mysql-01/</guid>
      <description>本筆記基於這份2021年11月的公開教學影片 【宋红康】MySQL数据库（安装/基础/高级/优化） https://www.bilibili.com/video/BV1iq4y1u7vj?p=1
 MySQL簡介  MySQL是開源且免費的資料庫 常用版本5.7、8.0 NoSQL為關聯式資料庫(Relational Database Management System)  想像成最傳統意義的表格，像Excel那樣 非關聯式資料庫(NoSQL)則例如以key-value形式儲存的redis    表與表的關聯關係  以下討論的都是基於關聯式資料庫
 一對一   通常可以直接建成一張表，但也是有應用場景
  例如以使用頻率拆分兩表(為了降低IO讀取提高效率):
  學生常用訊息表:學號、姓名、手機、班級
  學生其他訊息表:學號、住址、身分證號、緊急聯絡人
 兩張表的學號是唯一且相同的      建表原則:
 外鍵唯一:主表的主鍵和從表的外鍵(唯一)，形成主外鍵關係 外鍵為主鍵:主表的主鍵和從表的主鍵，形成主外鍵關係    一對多  舉例:  員工表:員工編號、員工姓名、所屬部門 部門表:部門編號、部門名   建表原則:從表(多方，這裡就是員工表)創建一個字段，字段作為外鍵指向主表(一方，這裡就是部門表)的主鍵  多對多  必須創建第三張表，通常將該表稱為關聯表，此關聯表以兩個一對多關係，將兩個表的主鍵都插到第三個表中 舉例:  學生訊息表:學號、姓名 課程訊息表:課程編號、課程內容 選課訊息表(關聯表):可以看到學號與對應的課程編號，一個課程編號必定對應多個學號；一個學號也可以選有多門課程   建表原則:關聯表中至少有2個字段，分別作為外鍵個指向一方的的主鍵  自我引用   表中的某個字段指向同張表的另一個字段</description>
    </item>
    
    <item>
      <title>JDK8新特性:Lambda表達式、StreamAPI、Optional類</title>
      <link>https://yoziming.github.io/post/211215-agg-ja-30/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211215-agg-ja-30/</guid>
      <description>Lambda表達式  可以簡略表達接口的匿名函數部份
  用於函數式接口，即只有一個抽象方法的接口  因為當你使用這個接口就必定要實現這個唯一的方法，所以很多東西可以省略    結構 // 舉例 Comparator&amp;lt;Integer&amp;gt; com = (o1, o2) -&amp;gt; o1.compareTo(o2);  -&amp;gt;:Lambda符號、箭頭符號 左邊:Lambda形參列表，就是接口中抽象方法的形參列表  參數類型可以省略(類型推斷) 如果只有一個參數，可以省略()括號   右邊:Lambda體，就是重寫的方法體，應該用{}大括號包裹  如果只有一行語句，可以省略{}大括號  如果省略{}大括號也必須省略return      應用  其實不用特別去記，IDEA寫出來他就會提示自動修改了
 一. // 無參無返回 Runnable r1 = new Runnable() { @Override public void run() { System.out.println(&amp;#34;hello&amp;#34;); } }; // Lambda省略後 Runnable r1 = () -&amp;gt; System.out.println(&amp;#34;hello&amp;#34;); 二. // 方法有一個形參，無返回 Consumer&amp;lt;String&amp;gt; stringConsumer = new Consumer&amp;lt;String&amp;gt;() { @Override public void accept(String s) { System.</description>
    </item>
    
    <item>
      <title>反射Reflection、動態代理</title>
      <link>https://yoziming.github.io/post/211214-agg-ja-29/</link>
      <pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211214-agg-ja-29/</guid>
      <description>反射Reflection  反射Reflection是Java被視為動態語言的關鍵，可以在運行時獲取類的內部訊息  動態語言:程式運行時，代碼可以根據某些條件改變自身結構   具體來說，當我們加載完某類之後，在記憶體中堆的方法區就產生了一個該類的Class物件，此物件包含了完整的該類的結構訊息 因此我們能透過反射的API，從一個物件取得他所屬類的屬性與方法並進行各種操作  主要API  java.lang.Class:代表一個類 java.lang.reflect.Method:代表類的方法 java.lang.reflect.Field:代表類的成員變數 java.lang.reflect.Constructor:代表類的構造器  Class類  Class類即是&amp;quot;類的類&amp;quot;，為反射的源頭 Object類中定義了getClass()方法，此方法被所有類繼承 Class類的實例物件只能由系統建立，當一個.class檔案被JVM載入執行時系統在堆的方法區產生唯一對應的物件 通過Class物件可以完整獲取類的結構並進行各種操作，所以要使用反射必須先獲取Class物件 萬物皆物件、萬物皆有Class類  數組的話只要元素類型與維度相同，視為同一個Class，例如int[5]與int[20]    獲取Class實例物件  已知具體類名:Class clazz = String.class 已知全類名:Class clazz = Class.forName(“java.lang.String”)  可能拋出錯誤ClassNotFoundException 也可以透過ClassLoader  ClassLoader cl = this.getClass().getClassLoader() Class clazz4 = cl.loadClass(“全類名”)     已有某類的實例物件:Class clazz = obj01.getClass()  ClassLoader  補充知識點，有印象就好
 類的加載實際步驟  Load:將.class檔案讀入記憶體、創建Class物件 Link:將類的二進位數據合併到JRE中、引入常量 Initialize:初始化，執行類構造器&amp;lt;clinit&amp;gt;()方法，進行static屬性或指定初始值的賦值   如果一個類的父類還沒初始化，會先進行父類的初始化 JVM會保證&amp;lt;clinit&amp;gt;()方法在多線程環境中的加鎖與同步  加載器的分類  Bootstrap:引導類，由C語言編寫，負責Java平台核心庫，無法直接獲取 Extension:擴展類，負責載入jre/lib/ext或指定目錄下的jar包 System(APPs):系統類，負責載入java.</description>
    </item>
    
    <item>
      <title>通訊協定:URL、IP與網路編程</title>
      <link>https://yoziming.github.io/post/211213-agg-ja-28/</link>
      <pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211213-agg-ja-28/</guid>
      <description>通訊協定  物理層:網路線、電話線 網路層:IP、ICMP、ARP 傳輸層:TCP、UDP 應用層:HTTP、FTP、DNS、Telnet 一般來說所謂&amp;quot;下層&amp;quot;是越靠近物理層面的那層  網路層(IP)   InetAddress類
 實例化  getByName(String host):host可以是IP，也可以是域名再透過DNS找到IP  IP  本機:127.0.0.1或localhost 內部IP:192.168.0.0~192.168.255.255 外部IP:其他的都是   域名:www.google.com、zh.wikipedia.org&amp;hellip;等等 DNS:Domain Name System，負責找出對應的IP   getLocalHost():返回本地IP   調用  getHostName():顧名思義 getHostAddress():顧名思義      port:連接埠、端口號，每個程序各自占用的通道，介於0~65536
 公認端口:0~1023，例如:http=80、ftp=21、telnet=23 註冊端口:1024~49151，約定成俗的，例如MySQL=3306    IP+port=Socket
 Socket才是真正實現程序間網路通信的基礎 主動發起通信的為客戶端Client，等待請求的為服務端Server    傳輸層  TCP  可靠，連接時需進行三次握手:  第一次:A發給B說&amp;quot;B 在嗎?&amp;quot; 第二次:B收到並返回&amp;quot;在，我是B，請說&amp;quot; 第三次:A收到B返回的&amp;quot;請說&amp;quot;，就認為傳輸是可靠的    適合用在大量的傳輸 傳輸完需釋放連接、效率低。四次揮手:  第一次:A發給B說&amp;quot;B 我們分手吧?</description>
    </item>
    
    <item>
      <title>IO流:物件流、序列化、隨機讀寫流與NIO</title>
      <link>https://yoziming.github.io/post/211212-agg-ja-27/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211212-agg-ja-27/</guid>
      <description>標準輸出/入流  System.in:標準輸入字節流，預設是從鍵盤輸入，類型是InputStream System.out:標準輸出流，預設輸出到控制台，類型是PrintStream，繼承自FilterOutputStream，繼承自OutputStream  重定向方法  public static void setIn(InputStream in) public static void setOut(PrintStream out)  範例-讀取輸入  不使用scanner
 public static void main(String[] args) { // 把標準輸入字節流先轉換成字符流  BufferedReader bufferedReader = null; try { InputStreamReader isr = new InputStreamReader(System.in); // 把字符流用bufferedReader包起來，為了調用readline方法  bufferedReader = new BufferedReader(isr); for (; true; ) { System.out.println(&amp;#34;輸入要轉換成大寫的字串...&amp;#34;); String str = bufferedReader.readLine(); if (&amp;#34;exit&amp;#34;.equalsIgnoreCase(str)) { // &amp;#34;exit&amp;#34;放前面防空指針  System.out.println(&amp;#34;離開&amp;#34;); break; } System.out.println(str.toUpperCase()); } } catch (IOException e) { e.</description>
    </item>
    
    <item>
      <title>IO流:基礎、緩衝流、轉換流與Unicode編碼</title>
      <link>https://yoziming.github.io/post/211211-agg-ja-26/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211211-agg-ja-26/</guid>
      <description>File類  位於 java.io之下 File類的一個物件，代表一個實際的文件檔案或一個資料夾 File類只涉及檔案或資料夾的創建、刪除、改名&amp;hellip;等方法，只能碰到外殼；讀取或寫入需要IO流才能做到 File類的物件通常做為參數傳到流的構造器中，作為讀取或寫入的終點  實例化  構造器的幾種參數
  File(String filepath):一般路徑 File(String parentPath, String childPath):分成父目錄與子目錄，再拼接起來 File(FileA parentFile, String childPath):相當於以 FileA為父目錄下的子目錄  路徑   不指明就是相對路徑，在IDEA中若使用 JUnit單元測試位置是 Module下(與 src資料夾同層)；若 main()方法則是在 Project下
  指明則是絕對路徑，例如 &amp;quot;G:\\JAVA\\code\\guigu\\day26IO\\src\\hi.txt&amp;quot;
  關於正反、雙斜槓等疑惑可以參考這篇:
https://yoziming.github.io/post/211212-slash-file-name/
  File類中有一個常量 File.separator可以根據系統自動變換分隔符
  常用方法  預設以一個File類的實例物件.調用以下方法
  String getAbsolutionPath():獲取絕對路徑 String getPath():獲取相對路徑 String getName():獲取檔案名稱 String getParent():獲取上層文件夾目錄路徑(需本身是絕對路徑)，若無則返回null Long Length():獲取檔案大小，單位位元組 Long LastModified():獲取最後修改時間戳 file1.boolean renameTo(File file2):將file1搬到file2的路徑並改名成file2，必須有file1無file2(他是一個移動+改名，無法覆蓋) String[] List():獲取指定目錄下的所有資料夾名與檔案名，類似dir與ls，只適用於資料夾目錄 File[] ListFiles():獲取指定目錄下的所有資料夾與檔案的File數組，只適用於資料夾目錄 boolean isDirctory():判斷是否為文件夾 boolean isFile():判斷是否為檔案 boolean exists():判斷是否存在 boolean canRead():判斷是否能讀 boolean canWrite():判斷是否能寫 boolean isHidden():判斷是否隱藏  創建/刪除檔案  不是實例化，而是真正在硬碟中創建檔案</description>
    </item>
    
    <item>
      <title>泛型Generic</title>
      <link>https://yoziming.github.io/post/211210-agg-ja-25/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211210-agg-ja-25/</guid>
      <description>泛型Generic  泛型是JDK5新增的項目
 特性  帶泛型的結構在實例化時，可以指明具體的泛型類型，類似於貼&amp;lt;標籤&amp;gt; 指明完後，使用到類的地方全都換成該泛型 用一個比喻，我自訂一個帶&amp;lt;&amp;gt;泛型的校車類，當實例化具體的校車A時，在&amp;lt;&amp;gt;中指明上裝的都是&amp;lt;北一女學生&amp;gt;，那裝進去的就只能是北一女學生， 當我對這台校車A進行各種操作時，就不用考慮裡面人是啥種類(以前都用Object盛裝，然後操作時還要先instanceOf確認種類再強轉)，現在跟校車A牽扯的通通都是&amp;lt;北一女學生&amp;gt;不用囉嗦 承上例，我也可以實例化另一台校車B&amp;lt;建中男學生&amp;gt;。一個優勢在於我規劃校車這個類時，先不用考慮具體要裝的是啥類而用泛型，用這個泛型先寫好通用的方法，留著空給實例化時再去決定實際調用的類  使用範例 // 造一個指明泛型為Integer, String的Map HashMap&amp;lt;Integer, String&amp;gt; stringHashMap = new HashMap&amp;lt;Integer, String&amp;gt;(); stringHashMap.put(1, &amp;#34;小名&amp;#34;); stringHashMap.put(2, &amp;#34;老王&amp;#34;); stringHashMap.put(3, &amp;#34;阿洲&amp;#34;); // 此時如果想放進非Integer,String的東西則報錯  // 轉成EntrySet，叫Map.Entry是因為Entry是一個內部接口 Set&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; entries = stringHashMap.entrySet(); // 通通都自動帶入泛型，而不用再去判斷種類或強轉 // 試著遍歷 Iterator&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; iterator = entries.iterator(); while (iterator.hasNext()) { Map.Entry&amp;lt;Integer, String&amp;gt; next = iterator.next(); Integer key = next.getKey(); String value = next.getValue(); System.out.println(key + &amp;#34;=&amp;gt;&amp;#34; + value); } 聲明  集合接口或集合類都天生帶有泛型的結構，自建的類或接口也能聲明泛型 泛型類可能有多個參數，可以都放在&amp;lt;&amp;gt;內用&amp;quot;,&amp;ldquo;隔開，例如:&amp;lt;E1, E2, E3&amp;gt; 聲明構造器時不用寫泛型 靜態方法不能使用類的泛型(因為泛型在實例化時才決定，當能不能跟static共存) 異常類不能聲明為泛型(因為它祖宗就沒有&amp;lt;&amp;gt;，繼承再怎樣都生不出來)  實例化  實例化時，指定的泛型必須是一個實際類，不能是基本數據類型(有需要就用包裝類) 泛型可以嵌套使用 帶泛型的接口或類在實例化時如果不指定泛型，就當作Object處理，但不等價於Object 要嘛一路都用泛型，要嘛都不要用  泛型方法   在方法中出現了泛型的結構，泛形參數與類的泛型無關</description>
    </item>
    
    <item>
      <title>路徑、正反斜槓與檔名的一些規則</title>
      <link>https://yoziming.github.io/post/211210-slash-file-name/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211210-slash-file-name/</guid>
      <description>正反斜槓  引用IrisAndMimi的解釋
  這個符號 「/」就是斜槓slash，呈現上右下左 而 「\」是反斜槓backslash，呈現上左下右 斜線的方向有時候容易搞混，其實只要回想一下手寫幾月幾日的時候，劃斜槓習慣往哪個方向就好了  路徑 Windows系統   只有Windows系統會用反斜槓\表達路徑，原因是上古時代DOS把正斜&amp;quot;/&amp;ldquo;當作參數命令用走了，於是就把反斜槓這個惡魔放了出來，用它表示路徑，記憶法:Windows的W第一筆畫就是\
  常見的Windows系統系統下的路徑:
  除開DOS，Windows大多數情況下，用正斜槓甚至正反斜槓混著用，也都能識別路徑
  玩日文遊戲的人可能注意過，日文的路徑是長這樣c:￥windows￥fonts￥，其實不僅日本還有韓國的₩，他們的鍵盤反斜槓\的位置就是￥與₩
    這個是編碼的歷史遺留問題，總之在日韓文系統\=￥=₩，系統會自動轉換，不用太在意
  MAC、Linux系統  不論是網址、MAC系統、Linux系統都是用&amp;rdquo;/&amp;ldquo;表達路徑   雙斜槓   //雙斜槓：協議和主機名之間的分隔符 （比如http://localhost:8080）
  \\雙反斜線 ：在windows里表示絕對地址的第一項，比如后面跟上IP地址的話，就是需要打開這個IP地址的網絡共享資源，舉例windows使用網路芳鄰會看到這樣:
  在大部分的程式語言中，把\反斜槓當作轉譯字符使用了，比如\n、\t，單用一個反斜槓很容易引起錯誤。最好還是用/正斜槓表達路徑
  檔名的大小寫規則   檔名不分大小寫:Windows系統、MAC系統
  檔名區分大小寫:Linux系統
  Git則可以自己手動設定，使用命令:
git config core.ignorecase true  資料夾的命名建議   大寫開頭的通常是系統預設的資料夾，Windows系統、MAC系統、Linux系統都有這個特性，舉例:</description>
    </item>
    
    <item>
      <title>集合:Map、HashMap、Collections工具類</title>
      <link>https://yoziming.github.io/post/211209-agg-ja-24/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211209-agg-ja-24/</guid>
      <description>Map Map接口:雙列數據，保存具有映射關係(key-value)成對的物件
分類  HashMap:主要實現類，線程不安全、效率高、可以存null  LinkedHashMap:遍歷時可以按照添加順序排列   TreeMap:可以按照key(必須都是同類)來排序，底層是紅黑樹 Hashtable:古老的實現類，注意t是小寫，線程安全、效率低、不能存null  Properties:常用來處理配置文件，key跟value都是String類型    結構  key:無序、不可重複的，使用Set儲存。key決定存放位置，key的所在類必須重寫equals()與hashCode() value:無序，可重複的，使用Collection儲存，value的所在類必須重寫equals() 一對key與value構成一個Entry物件，使用Set儲存，當然也是無序、不可重複的  HashMap源碼分析  以JDK7為例
  HashMap map = new HashMap();實例化時，底層創建了一個長度16的一維數組Entry[] table map.put(key1, value1);:放數據時，調用key1所在類的hashcode()方法算出哈希值，以此哈希值再經過某些位運算，得到在Entry[] table數組中的存放位置，此時:  若位置是空的，放入成功 若已經有人(可能有一個數據或鏈表)，就來比較key1跟佔位者(可能有多個，全都要比一遍)的哈希值  如果哈希值都不同，添加成功(放成鏈表) 如果key1的哈希值跟已存在的某數據(舉例為key2, value2)哈希值相同，此時再比較key1所在類的equals()方法，根據返回值:  如果equals()返回false，表示key不同只是恰好哈希值一樣，添加成功(放成鏈表) 如果equals()返回true，表示兩者key真的一樣，那就進入至尊對決，此時把put()方法理解為覆蓋，將舊的value2換成新的value1   所謂放成鏈表跟前面Set提到的一樣，類似於&amp;quot;卜&amp;quot;字的概念，從該位置延伸出去存放新的元素     擴容:超過臨界值(容量*負載因子)且要存的位置非空，就會進行擴容，預設的擴容方式為造一個新的兩倍長數組，然後將原有的複製過來  預設容量:16 預設負載因子:0.75 擴容的邏輯是這樣的，為了減少哈希碰撞(就是不希望分支的鏈表太多太長)，所以不會等他裝到滿才擴容。 假如負載因子0.9可能老是撞車導致分支很多，負載因子0.2可能一直在擴容，折衷就定負載因子為0.75效率最高    JDK8的改動  new HashMap():實例化時，底層沒有創建數組，首次調用put()方法才創建，類似懶漢式 底層數組用Node[]取代Entry[] 當數組某一個位置上的元素以鏈表形式存在的數據&amp;gt;8，且當前數組長度&amp;gt;64時，將鏈表改為紅黑樹儲存，提高查找效率  白話:分支長度&amp;gt;8且主幹長度&amp;gt;64轉紅黑樹    LinkedHashMap 繼承了HashMap的Node，但又多了before跟after兩個屬性，所以形成雙向鏈表，可以在添加時記錄前後順序</description>
    </item>
    
    <item>
      <title>集合:Collection接口、疊代器、List與Set</title>
      <link>https://yoziming.github.io/post/211208-agg-ja-23/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211208-agg-ja-23/</guid>
      <description>集合概述  集合、數組都是用來儲存多個數據(在記憶體中)的結構，簡稱Java容器 數組在聲明時長度跟數據類型就定死了，還強制是有序的，增刪改查都不變 Java集合分成兩種體系，有各種接口與實現類:  Collection接口:單列數據，用來存一個一個的物件  List接口:元素有序、可重複，又稱為&amp;quot;動態數組&amp;quot;  ArrayList LinkedList Vector   Set接口:元素無序、不可重複  HashSet LinkedHashSet TreeSet     Map接口:雙列數據，保存具有映射關係(key-value)成對的物件  HashMap  LinkedHashMap   TreeMap Hashtable  Properties        Collection Collection接口本身沒有直接的實現類，而是要通過其子類List與Set各自的實現類來完成物件的實例化
方法  用一個實現Collection接口的實例物件調用，例如:Collection coll = new ArrayList();
   add(Object e):將Object e加入集合中
  size():返回元素個數
  addAll(Collection c):將集合c的內容全加進來
  clear():清空元素，注意不是刪除集合本身，只是清掉其中的元素
  isEmpty():判定是否為空</description>
    </item>
    
    <item>
      <title>枚舉類enum、註解annotation</title>
      <link>https://yoziming.github.io/post/211207-agg-ja-22/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211207-agg-ja-22/</guid>
      <description>枚舉類(enum)  當類的物件數量是有限定的、確定的，例如:星期、性別、季節、支付方式、XX狀態 需要定義一組常量時，強烈建議使用枚舉類 如果類中只有一個物件，可以用單例模式 enum，發音&amp;quot;衣-囊&amp;quot;，名詞枚舉 enumerate，發音&amp;quot;以-new-merate&amp;quot;，動詞枚舉  自訂枚舉類  JDK 5以前
   聲明物件的屬性，用private final修飾
  將構造器私有化，給物件屬性賦上預想好的值
  在本類中預先創立好物件，用public static final修飾
  提供toSting方法
  提供其他訴求，例如:get屬性等等
  範例:
class PayMethod { private final String name; private final String desc; private PayMethod(String name, String desc) { this.name = name; this.desc = desc; } public static final PayMethod CASH = new PayMethod(&amp;#34;現金&amp;#34;, &amp;#34;真金白銀&amp;#34;); public static final PayMethod VISA = new PayMethod(&amp;#34;VISA卡&amp;#34;, &amp;#34;VISA金融卡&amp;#34;); public static final PayMethod ONLINE = new PayMethod(&amp;#34;電子支付&amp;#34;, &amp;#34;街口支付&amp;#34;); @Override public String toString() { return &amp;#34;PayMethod{&amp;#34; + &amp;#34;name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, desc=&amp;#39;&amp;#34; + desc + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } // 調用，因為是靜態，直接類名.</description>
    </item>
    
    <item>
      <title>常用類:日期時間、比較器、其他</title>
      <link>https://yoziming.github.io/post/211206-agg-ja-21/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211206-agg-ja-21/</guid>
      <description>日期時間(JDK 8前)  提前說下，這些過時的類型跟方法實際95%用不上，了解一下就夠了
  System類中的currentTimeMillis():返回當下與1970年1月1日之間的時間差，單位毫秒  這一長串的數字稱為時間戳    java.util.Date類   創建
  使用空參構造器:創建一個當前時間的物件，格式為Wed Dec 01 13:35:20 CST 2021
  形參傳入時間戳，創建一個該時間戳的物件
    方法
 toString():顯示時間 getTime():返回時間戳    java.sql.Date類  本身是java.util.Date的子類，用來對應數據庫中的日期變量  為了區分，最好使用全類名例如:java.sql.Date d2 = new java.sql.Date(d1.getTime()); 創建:形參必須傳入時間戳 方法:  toString():顯示時間，格式只有日期，如:2021-12-01 getTime():返回時間戳     java.util.Date與java.sql.Date轉換:形參中填入getTime()即可互轉  SimpleDateFormat類   顧名思義，把Date類格式化成String用的
  創建一個形參為你想要的格式(如常見的yyyy-MM-dd hh:mm:ss)的SimpleDateFormat物件
  用此物件調用format(date物件)方法返回想要的String，舉例:
Date d1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd hh:mm:ss&amp;#34;); String s1 = sdf.</description>
    </item>
    
    <item>
      <title>常用類:String相關類與方法</title>
      <link>https://yoziming.github.io/post/211205-agg-ja-20/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211205-agg-ja-20/</guid>
      <description>String類 String類特性  表示字符串，內容以&amp;quot;&amp;quot;包裹表示，稱為字面量的定義方式 是一個final類，不可被繼承 實現了Serializable接口，可以序列化 實現了Comparable接口，表示可以比較大小 內部定義了一個final char[] value數組來實際儲存數據，代表不可變的字符序列  當我們用字面量(區別於new)定義了一個String str1=&amp;quot;abc&amp;quot;，相當於在方法區的字符串常量池中新增了一個&amp;quot;abc&amp;quot;序列，其為不可變的 字符串常量池中不會儲存內容相同的字符串，比如我再新增一個str2=&amp;quot;abc&amp;quot;，則他們指向同一地址。  延伸str6=&amp;quot;a&amp;quot;+&amp;quot;bc&amp;quot;，在聲明時字面量相加，等於常量跟常量拼接，都是在常量池，所以指向同樣位置   而當我把str1=&amp;quot;hello&amp;quot;，或是用+拼接了其他內容，或是用replace取代了其中某一位的字，都是在常量池重新開闢空間，所謂不可變是這個意思   如果是用String str3=new String(&amp;quot;abc&amp;quot;);方法生成，則是創在堆中，str3本身是指向堆的地址，去比==都是false。這個動作實際開闢了2個記憶體空間，它在堆中的value才指向常量池  如果是new一個構造器生成時賦予的name傳入形參則跟new String是不同的，傳入形參也是類似於字面量的方法(因為顯然多在堆中開闢位置是毫無必要的) 若是用+拼接有任何涉及到變量的，例如str4=str1+&amp;quot;def&amp;quot;，都是相當於在堆空間new的操作，==去比較時全都false 但如果變量被final修飾(正常不會有人這麼做)，相當於這個變量存在常量池，又會是常量跟常量拼接，所以指向同樣位置 若是用intern()方法，例如str5=str1.intern();，返回值是在常量池中，==比較是true    面試題-判斷結果 public class StringTest { String str = new String(&amp;#34;good&amp;#34;); char[] ch = {&amp;#39;t&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;}; public void change(String str, char[] ch) { str = &amp;#34;bad&amp;#34;; ch[0] = &amp;#39;b&amp;#39;; } public static void main(String[] args) { StringTest ex = new StringTest(); ex.</description>
    </item>
    
    <item>
      <title>多線程:安全&amp;通信、Callable接口與線程池</title>
      <link>https://yoziming.github.io/post/211204-agg-ja-19/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211204-agg-ja-19/</guid>
      <description>線程安全 線程的生命週期 Thread.State類中定義了:
 新建:Thread類的物件被創建 就緒:start()後等待分配CPU資源的階段，可能是獲取了同步鎖、被notify() 運行:拿到實際資源、開始執行run()方法 阻塞:被暫時掛起，可能是sleep()或是被join()、或等待同步鎖、wait() 死亡:跑完或提前stop()、出錯了  同步代碼塊   解決多線程安全問題
  格式:
synchronized (同步器) { // 需要同步的代碼 }   同步器可以是任何物件，只需要滿足&amp;quot;它是多個線程共用的&amp;quot;，比如同類中的一個變量
 若是靠實現Runnable接口方法的多線程，可以用this，因為只有一個該類，當前對象是同一個 如果是繼承類實現的多線程，則可以用static變量，或是考慮&amp;quot;類名.class&amp;quot;(這玩意也是唯一的)    但這樣做實質等於單線程了，效率不高
  同步方法   解決多線程安全問題
  舉例:
public class SynTest implements Runnable { int ticket = 100; @Override public void run() { show(); } private synchronized void show() { for (; ticket &amp;gt; 0; ) { try { Thread.</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA Live Templates</title>
      <link>https://yoziming.github.io/post/211203-intellij_idea-live_templates/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211203-intellij_idea-live_templates/</guid>
      <description>IntelliJ IDEA Live Templates  盤點IDEA中Tab的實用招式，再配上alt+insert就能橫著走了
 基本聲明 psvm或main ▶ main 方法 st ▶ String prsf ▶ private static final psf ▶ public static final psfi ▶ public static final int psfs ▶ public static final String 創立物件 類名.new ▶ new 類名() new 類名().var或.val ▶ 類 物件名 = new 類(); new 類名().field ▶ 在方法外聲明一個成員變量，並在這裡初始化一個 print sout ▶ System.out.println(); souf ▶ System.out.printf(&amp;#34;&amp;#34;); &amp;#34;say something&amp;#34;.sout ▶ System.out.println(&amp;#34;say something&amp;#34;); obj.sout ▶ System.out.println(obj); obj.soutv ▶ System.</description>
    </item>
    
    <item>
      <title>多線程:基礎、Thread類、用法</title>
      <link>https://yoziming.github.io/post/211203-agg-ja-18/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211203-agg-ja-18/</guid>
      <description>多線程 名詞解釋    英文 台灣 中國 意義     Program 程式 程序 靜態的程式碼集合   Process 程序(進程) 進程 動態、被執行中且載入記憶體的program，也是 OS 分配資源的最小單位。打開工作管理員看到的就是這個   Thread 執行緒 線程 一個進程裡至少會有一個線程，表示內部的一條執行路徑。把進程比喻為一個工廠，線程則是工廠裡面的工人，負責任務的實際執行。同一個Process內的Thread使用相同的Memory Space，但這些Thread各自擁有其Stack。換句話說，Thread能透過reference存取到相同的Object，但是local variable卻是各自獨立的。白話:共享方法區跟堆，獨立棧跟計數器   Coroutine 協程 協程 輕量級的執行緒，由使用者掌控，例如GO的goroutine   Concurrent 並行 並發 一個 CPU 會去做多件事，但是同一個時間點之內只會做一件事，像是早上做 Job1、下午做 Job2、晚上做 Job3不斷的切換，目標是希望能做更多的事   Parallel 平行 並行 多個 CPU 在同一個時間點內會去做多件事，例如會有三個人同時分別在做 Job1、Job2、Job3 的事情。目標是希望能把事情更快速的做完。    需求來源  希望同時執行複數的任務，例如一邊執行main方法，GC一邊收垃圾 需要等待的狀況，例如等用戶輸入、等IO、等網路連接  Java多線程-方法一   造一個類，繼承Thread</description>
    </item>
    
    <item>
      <title>項目練習3-開發團隊調度系統</title>
      <link>https://yoziming.github.io/post/211202-agg-ja-17/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211202-agg-ja-17/</guid>
      <description>項目練習3-開發團隊調度系統  雖然不是特別難，實做一遍還是會遇到不少坑，以下個人復盤的筆記
  A類中用到B類的物件，引包後可以直接&amp;quot;private B類 物件名=new B類();&amp;ldquo;一個預設的來用 忽略大小寫可用equalsIgnoreCase 繼承的子類重複用到結構類似的方法，提取出相同因子在父類做一個public的然後去子類各自重寫，也能用來解決孫子super不到爺爺的困境 遍歷時注意.length的長度是在數組建立時就定死了，絕對不等於當前數組內的元素個數，如果遍歷.length有可能去遍歷到後面null的指針而報錯 單純只是想遍歷最好用foreach 手動複製數組使用System.arraycopy 方法形參是父類，想篩選傳進來的是否為某具體子類，用if(!(物件 instanceof 子類))可以優雅的判斷 switch-case如果沒有return記得break  </description>
    </item>
    
    <item>
      <title>利用bat一鍵更新HugoBlog</title>
      <link>https://yoziming.github.io/post/211201-blog-one-key-update/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211201-blog-one-key-update/</guid>
      <description>一鍵更新   透過.bat一鍵打包+git發布上傳到你的github專案倉庫
  既然是個人的倉庫，首先要解決一個權限問題，否則隨便路人都可以亂上傳到你的倉庫豈不是亂套
  作法簡單來說，在電腦本機生成一個key(一串暗號)，然後到github網頁上設定，約好拿這個key來的人就允許上傳
  生成本機key $ ssh-keygen # 產生金鑰Generating public/private rsa key pair.Enter file in which to save the key : # 金鑰存放路徑，預設會放到我的文件/.ssh# 放哪不是特別重要，有強迫症可以自己改，否則直接按EnterEnter passphrase (empty for no passphrase): # 密碼，可設定可不設定，設定的話每次上傳會多需要輸入一次密碼Enter same passphrase again: # 再輸入一次密碼The key fingerprint is: # 之後會顯示你的 fingerprint，到這裡就完成 key 的產生了將key報備到專案  到生成的路徑，找id_rsa.pub，右鍵筆記本編輯打開，會看到很長一行開頭是&amp;quot;ssh-rsa &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&amp;quot;，全選複製   回你的github專案   內容貼上剛剛複製的那行 自己給這個key起個名，懶得命名可以取剛剛那串最尾的&amp;quot;使用者@電腦&amp;quot;當名稱  建立批次執行檔 起一個.</description>
    </item>
    
    <item>
      <title>異常處理:try-catch、finally與throws</title>
      <link>https://yoziming.github.io/post/211201-agg-ja-16/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211201-agg-ja-16/</guid>
      <description>異常的分類 在Java中，程序執行中的異常分為Exception與Error，他們都繼承自Throwable
(語法錯誤跟邏輯錯誤那不叫異常)
Error   錯誤，JVM系統內部錯誤虛擬機無法解決的問題、資源耗盡等嚴重情況，比如:
  無限迴圈產生堆疊溢位(Stack Overflow)
  寫錯分配導致記憶體不足(Out-Of-Memory)，
    解決方法就是把它寫對
  Exception   例外，發生了出乎預料的事，又依&amp;quot;受不受檢&amp;quot;分成
  Checked Exception:又稱編譯時異常，通常在原始碼中必須顯式地catch並且處理，比如:
  IOException、讀取文件不存在
  ClassNotFoundException
  這部分在compile time就會檢查
    Unchecked Exception:又稱RuntimeException，運行時異常，比如:
 NullPointerException，空指針訪問 ArrayIndexOutOfBoundsException，數組角標越界 ClassCastException，類型轉換異常 NumberFormatException，數字類型不合 InputMismatchException，輸入數據不符合，例如scan int結果來了字串 ArithmeticException，算法異常，例如把某數除以0 通常是透過撰寫相應程式以避免的邏輯錯誤, 可以根據當下的情境來判斷是不是要catch    異常處理 代碼執行時，一旦出現異常，就會在異常處生成一個對應異常類的物件，並將其拋出，拋出後的代碼就不再執行
try-catch   格式:
try { int num = Integer.parseInt(str); } catch (NumberFormatException e) { e.</description>
    </item>
    
    <item>
      <title>抽象abstract、接口interface、內部類</title>
      <link>https://yoziming.github.io/post/211130-agg-ja-15/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211130-agg-ja-15/</guid>
      <description>抽象abstract  隨著繼承不斷疊代，子類越來越具體，而父類越來越通用。
類的設計必須保證子類與父類共有特徵，有時候我們將父類設計得非常抽象，以至於它沒有具體的實例，這樣的類稱為抽象類。
 定義  abstract屬於Java中的關鍵字，可以用來修飾類與方法，以下分別說明  abstract修飾類  此類不能實例化 必定有構造器被繼承 開發中都會提供抽象類的子類，讓子類形成實例來調用 不能修飾final類，final類規定不能被繼承，玩毛線  abstract修飾方法  稱為抽象方法，只有聲明，沒有方法體 (就沒要讓你具體用) 此方法不能被調用 包含抽象方法的類，必定是一個抽象類。反之抽象類不一定要有抽象方法 實際開發中的調用必須是被子類繼承後重寫，所有的抽象方法都被重寫後此子類才能實例化(否則，存在繼承來的抽象方法你就是個抽象類) 不能修飾私有private方法，因為抽象就是為了被繼承，抽象與其矛盾 不能修飾靜態static方法，靜態方法跟類共存亡，可以直接被類調用，通常是去弄靜態屬性的，抽象與其矛盾 不能修飾final方法，final方法規定是不能被重寫，抽象與其矛盾  應用-模板方法設計 在軟體開發中，實現某種功能時，整體中很固定、通用的方法，在父類中就寫好了；而其他不確定、易變的就先抽象起來，交給子類去實現
匿名子類的匿名對象  在一次性使用的場合，不想實際造一個匿名類的實體子類，可以在new 匿名類()後面接{}，{內直接重寫方法，範例:
 abstract public class Person { abstract public void work(); } public class Student extends Person { @Override public void work() { System.out.println(&amp;#34;學生讀書&amp;#34;); } public static void main(String[] args) { method(new Student()); method(new Person() { @Override public void work() { System.</description>
    </item>
    
    <item>
      <title>關鍵字:static/main/final、代碼塊與單例模式</title>
      <link>https://yoziming.github.io/post/211129-agg-ja-14/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211129-agg-ja-14/</guid>
      <description>關鍵字static  意義:靜態的，類中共用的，生命週期跟隨類的 使用對象:屬性、方法、內部類、代碼塊，以下分別說明  使用static修飾屬性   稱為&amp;quot;靜態變量&amp;quot;或&amp;quot;類變量&amp;quot;
  先複習關於變量的知識
   實例變量是每個造出來的物件各自有的，比如:大明跟小明各自的age不同 類變量是整個類共用的，比如:大明跟小明的nation都是TW  類變量隨著類的加載而加載，可以通過&amp;quot;類.靜態變量&amp;quot;進行調用 物件沒創建之前類變量就已經存在 由於類只會加載一次，靜態變量在記憶體中也只存在一份，位於方法區的靜態域   在哪應用靜態屬性:  類中共用的，生命週期跟隨類的  舉例:構造器中自動生成編號的基數(比如從1001開始、1002..)   常量也常聲明為static，再加上final修飾  舉例:Math.PI      使用static修飾方法  稱為靜態方法，規則大致與上面相同 隨著類的加載而加載，可以通過&amp;quot;類.靜態方法&amp;quot;進行調用 不能在靜態方法中調用非靜態的屬性或方法(畢竟沒有物件) 在靜態方法中，不能使用this或super關鍵字(物件都沒出生當然不能用) 在哪應用靜態方法:  操作靜態屬性的方法，通常設為靜態 工具類的方法，比如Math、Array、Collections    單例(singleton)設計模式   定義:整個系統中，強制某個類只存在一個實例，減少資源消耗
  應用場合:
 網站的計數器，只造一個，不然難以同步 日誌:通常是一個日誌文件一直被開著，最好只有一個實例去操作它 數據庫的連接池 Windows的Task Manager跟Recycle Bin也是很典型的單例    &amp;ldquo;餓漢式&amp;quot;實現:
  私有化的構造器</description>
    </item>
    
    <item>
      <title>多態:關鍵字instanceof、Object類與包裝類</title>
      <link>https://yoziming.github.io/post/211128-agg-ja-13/</link>
      <pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211128-agg-ja-13/</guid>
      <description>多態性  類似go接口的概念，就是為了讓子類能調用父類的方法
白話:為了實現代碼的通用性
   一個事物的多種形態
  父類的引用指向子類的物件(子類的物件賦給父類的引用)，舉例:
Father obj = new Child();   使用:虛擬方法調用，編譯期只能調用父類中聲明的方法，但運行時執行的是子類重寫父類的方法。多態只有在運行那一個才知道要調用哪個方法，即多態是個運行時行為，又稱為動態綁定
 白話:編譯看左，運行看右    前提:類的繼承關係、方法的重寫，缺一不可
  目的:避免重複寫很多重載的方法
  體現:
  舉例`Person`類 之下有子類 `Chinese`、`Japanese`、`American` `Person`類有`welcome`方法，被各自子類以該國語言重寫過 我的某功能調用`welcome`時能接受`Person`類，依照實際子類物件呈現不同語言的`welcome`結果 該功能即不需要`Chinese`、`Japanese`、`American`都寫一次   public class Atest { public static void main(String[] args) { Atest test = new Atest(); test.func(new Dog()); // 多態體現在這  } public void func(Animal animal) { //Animal animal=new Dog();  animal.</description>
    </item>
    
    <item>
      <title>繼承:方法重寫、關鍵字super與物件實例化過程</title>
      <link>https://yoziming.github.io/post/211127-agg-ja-12/</link>
      <pubDate>Sat, 27 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211127-agg-ja-12/</guid>
      <description>繼承 目的  減少代碼冗餘、提高復用性 便於功能擴展 為多態鋪路  格式 class A extends B{} // A延展了B A:子類、派生類、subclass B:父類、超類、基類、superclass 繪圖時，通常用實心箭頭從子指向父，例如:Student→Person，表示學生類繼承了人類
特性  A繼承B之後，子類A就獲取了B聲明的所有屬性與方法，包含了私有(private)的，但是由於封裝性的影響，子類無法直接調用父類私有(private)的屬性與方法 不允許多重繼承(一人只能有一個老爸) 可以多層繼承(允許有孫子，孫子也會繼承爺爺的特性) 一個父類可以有多個子類(允許家族開枝散葉) 所有類都繼承自java.lang.Object，換言之所有類都具有Object類的特性  權限修飾符protected的應用  之前提過protected的範圍是不同包的子類也能用，就是應在這了  實際發開中用的比較少一點    方法的重寫   子類繼承父類後，對父類同名同參數的方法，進行覆蓋
  子類重寫的方法權限修飾符必須不小於父類被重寫的方法
 白話:不能把公車私有化，權限範圍不能縮小 注意:不能重寫父類中聲明為private的方法(本身就見不到)，可以在子類中硬寫一個同名的方法，但那就不是構成重寫    若父類被重寫的方法返回值是void，子類重寫的方法也必須返回void
  若父類被重寫的方法返回值是A類型，子類重寫的方法返回值可以是A類或A類的子類
 舉例:父類返回值是動物類，子類可以重寫返回動物類或貓類狗類    若父類被重寫的方法返回值是基本數據類型，子類重寫的方法返回值必須是相同基本數據類
 舉例:父類返回double子類也必須是double，不能是int期待他自動類型提升    拋出異常(throws)的規則與返回值相同
  以上白話小結:權限不能小於爸爸、返回值不能大於爸爸
  補充:子類與父類同名同參數的方法要嘛都聲明為非static的(考慮重寫)，要嘛都聲明為static的(不是重寫，靜態類的方法不能被覆蓋)
  關鍵字super 用來表示父類中的屬性、方法、構造器</description>
    </item>
    
    <item>
      <title>項目練習2-客戶訊息管理系統</title>
      <link>https://yoziming.github.io/post/211126-agg-ja-11/</link>
      <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211126-agg-ja-11/</guid>
      <description>項目練習-客戶訊息管理系統  有點基礎這部分都蠻簡單的
 有個知識點是這邊在&amp;quot;刪除用戶&amp;quot;的功能用到了循環鏈表的概念
public boolean deleteCustomer(int index) { if (customers[index] != null) { for (int i = index; i &amp;lt; total - 1; i++) { // 不能搬到total，否則[i+1]會越位  customers[i] = customers[i + 1]; } customers[total - 1] = null; total--; System.out.println(&amp;#34;刪除用戶成功!&amp;#34;); return true; } System.out.println(&amp;#34;索引無效，操作失敗&amp;#34;); return false; } total表示當前數組中用戶總數，這個i &amp;lt; total - 1蠻關鍵的，我原先沒想到這邊要-1，還想著讓他把後面的null往前搬就好，沒考慮到末尾可能會越位的情況。
搬完再跟customers[total - 1] = null搭配使用，這樣才是健壯的</description>
    </item>
    
    <item>
      <title>封裝性、構造器、關鍵字this、Package包</title>
      <link>https://yoziming.github.io/post/211125-agg-ja-10/</link>
      <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211125-agg-ja-10/</guid>
      <description>封裝的設計思想   高內聚:類的內部數據操作細節自己完成，不允許外部干涉
  低耦合:對外露出少量的方法(API)供使用
   舉例:微波爐，我不需要用戶控制燈光、波照、轉盤等等，只要他放入東西按下&amp;quot;解凍&amp;quot;即可。即所謂的&amp;quot;一鍵XX&amp;quot;功能。
 封裝性的體現  將類的屬性私有化(private)，通過公共的(public)的set與get方法讓外部調用，舉例:  public class Main { public static void main(String[] args) { Animal a1 = new Animal(); a1.setAge(10); System.out.println(a1.getAge()); } } class Animal { private int age; public void setAge(int i) { age = i; } public int getAge() { return age; } }  不對外公開的私有方法(比如對外是各種排序方法，內部自己寫了一個交換兩數據位置的&amp;quot;小工具&amp;quot;) 單例模式(將構造器私有化) &amp;hellip;等等 需要權限修飾符來配合  權限修飾符  JAVA中有4種權限修飾符，各自的範圍是: (從小到大，下包含上)
  private:限當前類內部使用 default(缺省，就是不寫):同一個包名就可以調用 protected:不同包它的子類可以調用 public:相當於開放的  修飾的對象  以上4種可以用於修飾類的內部結構:屬性、方法、構造器、內部類 class本身的修飾只能是缺省或public，一個.</description>
    </item>
    
    <item>
      <title>物件導向:方法的重載與參數的值傳遞</title>
      <link>https://yoziming.github.io/post/211124-agg-ja-09/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211124-agg-ja-09/</guid>
      <description>細說方法 方法的重載(overload)  定義:同一各類中，允許存在一個以上的同名方法，只要他們的參數個數或參數類型不同即可 跟方法的權限修飾符、返回值類型、形參變量名、方法體無關，判斷重點在於參數本身 可能會自動類型提升，舉例:傳入的是int形，方法中沒有int但有double，就會調用double 典型的例子就是內建的println()  可變個數形參  格式:方法名(形參類型 ... 形參名) 調用時傳入的形參數量可以是0到多個，包含數組 與本類中方法名相同，形參不同的方法間構成重載(可共存) 與本類中方法名相同，形參類型也相同的數組之間不構成重載(不可共存)  PS.這是歷史遺留問題，因為可變個數形參是JDK5加入的，以前都是用數組   方法內把它當作數組使用，遍歷itar (i=0;i&amp;lt;形參名.length;i++){} 必須聲明在末尾，且最多只能有一個  方法參數的值傳遞 先複習一下變量的賦值規則  變量是基本數據類型(byte、short、int、long、char、float、double、boolean)，賦值的是變量所保存的數據值 變量是引用類型(引用類型就只有null跟地址值兩種情況)，賦值給的是所保存數據的地址值  名詞解釋  形參:方法定義時，聲明的小括號中的參數 實參:方法調用時，實際傳給形參的數據  傳參規則  跟變量的賦值規則其實相同
  如果參數是基本數據類型，實參賦給形參的是數據值(類似給一份副本) 如果參數是引用類型，實參賦給形參的是地址值(包含變量的數據類型)  陷阱題  println在char[]這有個特例，要避免踩坑就是調用時多看看方法格式
 int[] arr1 = new int[]{1, 2, 3}; System.out.println(arr1); // [I@1b6d3586 char[] arr2 = new char[]{&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;}; System.out.println(arr2); // abc 練習-在方法中引用其他類的方法並調用 public class Main { public static void main(String[] args) { PassObject t1 = new PassObject(); Circle c = new Circle(); t1.</description>
    </item>
    
    <item>
      <title>物件導向:基本概念與學習路線</title>
      <link>https://yoziming.github.io/post/211123-agg-ja-08/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211123-agg-ja-08/</guid>
      <description>物件導向  Object-oriented programming中國翻為&amp;quot;面向對象&amp;quot;，台灣則翻為物件導向
我個人也覺得&amp;quot;物件導向&amp;quot;翻的比較信雅達，可以參考這篇知乎問答的解釋
https://www.zhihu.com/question/22515658/answer/120754062
 概念 首先用咖啡機煮咖啡為例:
過程導向(Process-oriented)  過程導向強調的是功能行為，以函數為最小單位，考慮如何做
   執行加咖啡豆方法
  執行加水方法
  執行煮咖啡方法
  執行喝咖啡方法
  物件導向(Object-oriented)  物件導向則是先將功能封裝進物件，強調具備功能的物件，以類/物件為最小單位，考慮誰來做
 在執行煮咖啡操作前要抽象出：人和咖啡機（分類），然後開始執行：
  人.加咖啡豆
  人.加水
  咖啡機.煮
  人.喝咖啡
  物件導向的三大特徵  封裝(Encapsulation) 繼承(Inheritance) 多態(Polymorphism)  類和實例 類(class):抽象的模板、概念上的定義
物件(object):是實際存在的個體，也稱為實例(Instance)
 比如說有輪子、吃汽油跑的是汽車類。小弟的車new march則為實例
 類的設計  設計類其實就是設計類的成員
 屬性(field):成員變量，又稱域、字段、欄位
行為(method):成員方法，又稱函數
舉例:汽車類的屬性有輪子大小、有品牌名稱；汽車的行為有吃汽油跑
練習-在JAVA創建類並實例化 class Car { // 屬性  String brand; String owner; boolean isNew = true; // 可以給預設值  // 行為(方法)  public void crash() { if (isNew) { System.</description>
    </item>
    
    <item>
      <title>數組:填值/複製/查找/排序、Arrays工具類</title>
      <link>https://yoziming.github.io/post/211122-agg-ja-07/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211122-agg-ja-07/</guid>
      <description>數組常用算法 數據結構  程序=數據結構+演算法
  數據間的邏輯關係:集合、一對一、一對多、多對多 數據的儲存結構:  線性表:順序表(如:數組)、鏈表、棧、隊列 樹形結構:二叉樹 圖形結構    演算法-Algorithm   排序
  檢索
  加密
  &amp;hellip;
  練習題-帕斯卡三角  形狀不是很漂亮
 int[][] arr = new int[10][]; for (int i = 0; i &amp;lt; arr.length; i++) { arr[i] = new int[i + 1]; // 兩外邊都是1  arr[i][0] = 1; arr[i][i] = 1; if (i &amp;gt; 1) { for (int j = 1; j &amp;lt; arr[i].</description>
    </item>
    
    <item>
      <title>數組Array</title>
      <link>https://yoziming.github.io/post/211121-agg-ja-06/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211121-agg-ja-06/</guid>
      <description>數組Array  多個相同類型的數據按一定的順序排列的集合
 結構  數組名 元素 下標aka角標/索引 長度(元素的個數)  特性  數組本身是引用數據類型，其中的元素可以是任何類型 數組的排列是有序的 在記憶體中開闢一整塊連續的空間，數組名引用的是這塊連續空間的首地址 長度確定後就不可更改  聲明與初始化  數組必須初始化才能使用
  方法1-靜態初始化，創建時填入已知的元素內容，由系統判定長度  int[] array1; // 聲明 array1 = new int[]{1, 2, 3}; // 靜態初始化:同時對元素賦值了 // 也可以合併成 int[] array1 = new int[]{1, 2, 3}; // 可以再縮寫成 (類型推斷) int[] array1 = {1, 2, 3};  方法2-動態初始化，創建時填入已知的長度，元素內容為0或空(系統默認，後述)  int[] array3 = new int[3]; // 動態初始化，注意後面的[5]是指長度 訪問數組內的元素  沒特別的，一樣從0~長度-1。長度=array.length
 舉例:array[0]、array[1]&amp;hellip;array[array.length-1]</description>
    </item>
    
    <item>
      <title>台灣人常唸錯的IT英文單字</title>
      <link>https://yoziming.github.io/post/211120-it-english-taiwanese-problems/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211120-it-english-taiwanese-problems/</guid>
      <description>台灣人常唸錯的IT英文單字  非母語有一些口音在所難免，我不求最正宗的發音，但至少不太要離譜甚至產生歧意，畢竟能夠順利溝通交流才是最重要的
 cache，錯誤&amp;quot;catch&amp;quot;，正確它和&amp;quot;cash&amp;quot;同音
archive，錯誤&amp;quot;阿起府&amp;quot;，正確&amp;quot;阿-凱f&amp;quot;，f幾乎不發音
SQL，錯誤&amp;quot;circle&amp;quot;，正確&amp;quot;see-qual&amp;quot;
hidden，錯誤&amp;quot;嗨-等&amp;quot;，正確&amp;quot;he-等&amp;quot;
suite，錯誤&amp;quot;訴-特&amp;quot;，正確&amp;quot;sweet&amp;quot;，發音相同都是swēt
virtual，錯誤&amp;quot;V-糗&amp;quot;，正確&amp;quot;ver-秋歐&amp;quot;，虛擬的
visual，正確&amp;quot;V-九歐&amp;quot;，視覺的，微軟的Visual Studio Code是這個
mobile，錯誤&amp;quot;哞比歐&amp;quot;，正確&amp;quot;ㄇㄡ-ㄅㄛˇ&amp;quot;，英式&amp;quot;哞百歐&amp;quot;
maintain，man-ten，動詞維護
maintenance，名詞維護，正確&amp;quot;咩-特-ㄋㄜˇ-死&amp;quot;4個音，重音在特
module，正確&amp;quot;媽-九&amp;quot;
enum，正確&amp;quot;衣-囊&amp;quot;，名詞枚舉
enumerate，正確&amp;quot;以-new-merate&amp;quot;，動詞枚舉
annotation，正確&amp;quot;A-ㄋ-tation&amp;quot;，名詞註解
Azure，正確&amp;quot;阿九兒&amp;quot;，連一起速念
parameter，錯誤&amp;quot;怕拉-咪特&amp;quot;，正確&amp;quot;ㄆ˙-ㄌㄩㄝ-ㄇ˙-ter&amp;quot;4個音，第一是輕聲ㄆ，重音在第二個音節
separator，正確&amp;quot;ㄙㄟ-ㄆ˙-蕊特&amp;quot;，第二是輕聲ㄆ，重音在第三音節
error，錯誤&amp;quot;ㄟ摟&amp;quot;，正確&amp;quot;ㄟ-惹&amp;quot;
format，錯誤&amp;quot;否-妹t&amp;quot;，正確&amp;quot;F歐-美t&amp;quot;
Period，正確&amp;quot;P-re-诶&amp;quot;
copy，錯誤&amp;quot;摳比&amp;quot;，正確&amp;quot;咖痞&amp;quot;
lambda，正確&amp;quot;ㄌ一ㄢ-打&amp;quot;
image，錯誤&amp;quot;一美舉&amp;quot;，正確&amp;quot;一米舉&amp;quot;
Algorithm，正確&amp;quot;凹狗-rithm&amp;quot;
width，錯誤&amp;quot;wide&amp;quot;，正確&amp;quot;with&amp;quot;，當作d不存在
lock，錯誤&amp;quot;肉可&amp;quot;，正確&amp;quot;辣可&amp;quot;
query，錯誤&amp;quot;誇-李&amp;quot;，正確&amp;quot;ㄎㄨㄧ-ㄜˇ-ry&amp;quot;3音連速念
confirm，錯誤&amp;quot;康鳳&amp;quot;，正確&amp;quot;ken-firm&amp;quot;，firm=&amp;ldquo;份兒&amp;quot;連念。這是認證、確認的意思
conform，錯誤&amp;quot;康鳳&amp;rdquo;，正確&amp;quot;ken-form&amp;quot;。這是符合的意思，兩字常常誤用誤念
register，錯誤&amp;quot;re-季-ster&amp;quot;，正確&amp;quot;ㄌㄩㄝ-幾-ster&amp;quot;
Arduino，正確&amp;quot;阿督衣no&amp;quot;
result，錯誤&amp;quot;re-造&amp;quot;，正確&amp;quot;re-奏特&amp;quot;，奏特連念
chrome，錯誤&amp;quot;恐龍米&amp;quot;，正確&amp;quot;窟窿&amp;quot;連念到近乎一個音
null，有些人念&amp;quot;怒偶&amp;quot;，正宗應為&amp;quot;鬧&amp;quot;、或&amp;quot;NO&amp;quot;，但這跟區域有關係，就算誤念成nil大概也能懂，不用太強求
record，做名詞紀錄時，正確&amp;quot;ㄌㄩㄝ-渴d&amp;quot;，d幾乎不發音
record，做動詞紀錄時，正確&amp;quot;re-扣d&amp;quot;，規律幾乎都是名詞重音在前，動詞重音在後
resume，做名詞履歷時，正確&amp;quot;ㄌㄩㄝ-su-美&amp;quot;，重音在前
resume，做動詞恢復時，正確&amp;quot;re-zoom&amp;quot;，重音在後
modem，錯誤&amp;quot;某店&amp;quot;，正確&amp;quot;ㄇㄡ-等&amp;quot;
cancel，正確&amp;quot;ken-叟&amp;quot;，取消
cancer，正確&amp;quot;ken-ser&amp;quot;，癌症，兩字常常誤用誤念
guarantee，正確&amp;quot;ㄍㄟ-掄-替&amp;quot;
standard，錯誤&amp;quot;stan-打&amp;quot;，正確&amp;quot;stan-得兒&amp;quot;
execute，正確&amp;quot;ㄟ-ser-cute&amp;quot;
compile，正確&amp;quot;康-派-偶&amp;quot;，動詞編譯
compiler，正確&amp;quot;康-派l-惹&amp;quot;，l幾乎不發音，名詞編譯器
exit，正確&amp;quot;ㄟㄎ-sit&amp;quot;，常誤念成exist
vehicle，正確&amp;quot;V-诶口&amp;quot;</description>
    </item>
    
    <item>
      <title>流程控制:嵌套循環、break與continue</title>
      <link>https://yoziming.github.io/post/211120-agg-ja-05/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211120-agg-ja-05/</guid>
      <description>嵌套循環  就是for中有for，有時候需要多花點時間理解
  內層循環整個遍歷完，外層循環才執行一次 假設外層循環要執行m次，內層循環要執行n次。整個跑完內層循環一共執行了m*n次  練習題-印菱形 Scanner scan = new Scanner(System.in); System.out.println(&amp;#34;輸入想印的菱形邊長n=...&amp;#34;); int n = scan.nextInt(); // 上半部分(含中間最長邊) for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt; n - i; j++) { System.out.print(&amp;#34; &amp;#34;); } for (int k = 0; k &amp;lt; i; k++) { System.out.print(&amp;#34;* &amp;#34;); } System.out.println(); } // 下半部分(從最長-1開始) for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt; i; j++) { System.</description>
    </item>
    
    <item>
      <title>流程控制:if、switch、for、while</title>
      <link>https://yoziming.github.io/post/211119-agg-ja-04/</link>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211119-agg-ja-04/</guid>
      <description>分支控制 if-else  基礎都一樣不多贅述
   特殊情況有人不加{}，這種情境下就近原則且只控制一行(到第一個;為止)
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); System.out.println(&amp;#34;b&amp;#34;); System.out.println(&amp;#34;c&amp;#34;); 結果為 b c   只有單行時可以接else且也會就近選擇
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); else System.out.println(&amp;#34;d&amp;#34;); 結果為d   多行時直接報錯
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); System.out.println(&amp;#34;b&amp;#34;); System.out.println(&amp;#34;c&amp;#34;); else 報錯   小結:不加{}的全部拖出去打
  switch-case   結構:
switch (表達式) { case 常量1: // 執行語句  break; case 常量2... ... default: // 預設執行語句 }   如果不加break;就不會跳出，而是會穿透且之下的語句全都執行一遍
  基於上述特性，可以合併使用，舉例:</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA設定與常用快捷鍵</title>
      <link>https://yoziming.github.io/post/211117-intellij_idea-shortkey/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-intellij_idea-shortkey/</guid>
      <description>IDEA基礎設定   安裝的根目錄，舉例&amp;hellip;\IntelliJ IDEA 2021.2.3\bin\idea64.exe.vmoptions
編輯這個idea64.exe.vmoptions，改成-Xmx1024m -Xms2048m
  ctrl+alt+s開啟設定 -&amp;gt; plugins插件 -&amp;gt; 搜尋chinese -&amp;gt; 安裝重啟 -&amp;gt; 中文化
  plugins插件 -&amp;gt; 搜尋save actions-&amp;gt; 安裝重啟 -&amp;gt; 存檔時自動格式化
  外觀-使用自定義字體打勾-Sarasa mono&amp;hellip;，大小改14
   強烈建議使用更紗黑體Sarasa-Gothic https://github.com/be5invis/Sarasa-Gothic 特性:融合Iosevka(程式碼常用的等寬字型)跟Source Han Sans(思源黑)，有等距、繁簡中日韓不缺字，簡直完美
   編譯器-字體-一樣改，大小我是設18、行高1.1
  編譯器-代碼樣式-Java-空行-保持最大空白行，前三項我都設1，太多空白可自動刪除
  佈景主題推薦one dark，這也是最多人用的
  Rainbow Brackets 括弧變色
  IDEA常用快捷鍵 視窗  Close All Tabs : alt + w Terminal : ctrl + alt + 0  選取  选中下一个相同内容的快捷键(vs code中的Ctrl+D)：Alt + J 依照個人習慣我還是把它改成ctrl + D了，原本ctrl + D(複製當前行)改成alt+ shift + ↓  以「行」為單位  複製 : ctrl + D 移動 : ctrl + shift + ↑/↓ 註解 : ctrl + / 刪除 : ctrl+x(其實是剪下)  以「區塊」為單位  擴增選取 : ctrl + W 遞減選取 : ctrl + shift + W 更改大小寫 : ctrl + shift + U  自動功能 :  自動補全 : alt + enter 自動產生 : alt + Ins 自動排版 : ctrl + alt + L 自動移出未使用 import : ctrl + alt + O  顯示形參列表:ctrl+p 查找當前文件結構(有哪些方法、屬性):ctrl+F12 以下記錄自己習慣的設定 </description>
    </item>
    
    <item>
      <title>運算符:邏輯運算、賦值、位運算與三元運算</title>
      <link>https://yoziming.github.io/post/211118-agg-ja-03/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211118-agg-ja-03/</guid>
      <description>運算符 加減乘除  基本都一樣不再贅述
 % 取餘的規則  結果的符號與被取餘的數符號相同，舉例-12%5=-2、12%-5=2、-12%-5=-2 實際開發中取餘常用來判斷是否能除盡  自增自減的規則  ++a，(前++)先運算後取值，舉例a=2;b=++a;結果a=3;b=3 a++，先取值後運算，舉例a=2;b=a++;結果a=3;b=2 --a，先運算後取值，舉例a=2;b=--a;結果a=1;b=1 a--，先取值後運算，舉例a=2;b=a--;結果a=1;b=2 自增減不會改變數據類型(但可能會溢位) 不可連用，舉例a++++會報錯  另外+也能用在字符串聯接，舉例&amp;quot;he&amp;quot;+&amp;quot;llo&amp;quot;=&amp;quot;hello&amp;quot;
= 賦值的規則  可以連續賦值，舉例int i1,i2; i1=i2=10; int i3=10,j3=20; +=、-=、*=、/=、%= 不會改變數據類型 面試題n=10; n+=(n++)+(++n); n=? 解: 拆成 n = n + 10 + 12 =32 寫==則是比較運算符，返回boolean  邏輯運算符  乍看邏輯跟短路結果是一樣，實際使用上差異為短路後的東西就不執行了 舉例: b=false; n=10; b &amp;amp;&amp;amp; (n++&amp;gt;0)=false，但n=10  位運算符  操作的都是整數 &amp;laquo; 向左移一位相當於*2，&amp;raquo;向右移一位相當於/2，有可能溢位  三元運算符  結構: (條件表達式) ? 表達式1 : 表達式2 說明: 條件表達式=boolean，如果是true則執行表達式1，反之執行2 表達式1 與 表達式2 要求類型一致(至少能裝進同一個類型) 其實就是簡易版的if，可以嵌套使用  優先級  基本原則是從上到下，從左到右，括號優先 自增減、賦值運算、三元運算才從右往左看  </description>
    </item>
    
    <item>
      <title>關鍵字、變量、數據類型與轉換</title>
      <link>https://yoziming.github.io/post/211117-agg-ja-02/</link>
      <pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-agg-ja-02/</guid>
      <description>關鍵字 關鍵字  有特殊含意與用途，所有關鍵字都是小寫
 例如:if、new&amp;hellip;等等，後面都會一一接觸到
保留字  未來版本可能會用到而保留
 例如:goto、const
標識符(identifier)  可以自己命名的(類、變量、函數&amp;hellip;等)就叫標識符
   由字母、數字、_、$組成
  數字不可為開頭
  能包含關鍵字但不能純用關鍵字
  嚴格區分大小寫
  不能包含空格
標識符的命名規範  不強制但最好遵守
   包名:多單詞所有字母小寫aaabbbccc
  類名、接口名:大駝峰(首字母大寫)AaaBbbCcc
  變量名、方法名:開頭小寫後面首字母大寫(小駝峰)aaaBbbCcc
  常量名:全大寫，用下畫線相連AAA_BBB_CCC
  命名要有意義，見名知意
  變量(variable)  記憶體中的一個儲存區域，使用的基本單位
  必須先聲明，後使用 作用域在其定義所在的一對{}內，只在其作用域中有效 同一作用域中不可重複  數據類型 基礎數據類型  六種數字類型（四個整數型，兩個浮點型），一種字符類型，還有一種布爾型
 byte  byte數據類型是8位、有符號的，以二進制補碼表示的整數 最小值是-128（-2^7）最大值是127（2^7-1）默認值是0 byte類型用在大型數組中節約空間，主要代替整數，因為byte變量佔用的空間只有int類型的四分之一 例子：byte a = 100，byte b = -50  short  short數據類型是16位、有符號的以二進制補碼表示的整數 最小值是-32768（-2^15）最大值是32767（2^15 - 1）默認值是0 Short數據類型也可以像byte那樣節省空間 一個short變量是int型變量所佔空間的二分之一 例子：short s = 1000，short r = -20000  int  int數據類型是32位、有符號的以二進制補碼表示的整數 最小值是-2,147,483,648（-2^31）最大值是2,147,483,647（2^31 - 1）默認值是0 一般整型變量默認為int類型 例子：int a = 100000, int b = -200000  long  long數據類型是64位、有符號的以二進制補碼表示的整數 最小值是-9,223,372,036,854,775,808（-2^63） 最大值是9,223,372,036,854,775,807（2^63 -1） 這種類型主要使用在需要比較大整數的系統上 必須以L(大小都可)結尾，不加自動被當成int 默認值是0L 例子： long a = 100000L，Long b = -200000L  float  float的儲存結構是1個符號位，8個指數位，23個尾數，符合IEEE 754標準的浮點數 可以看做float只有24位來表示精度，所以int或long轉``float可能會有精度損失 必須以F(大小都可)結尾，不加報錯 默認值是0.</description>
    </item>
    
    <item>
      <title>Java簡介、環境配置、HelloWorld</title>
      <link>https://yoziming.github.io/post/211116-agg-ja-01/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-agg-ja-01/</guid>
      <description>本筆記基於這份2019年4月的公開教學影片 尚硅谷Java入门视频教程(在线答疑+Java面试真题) https://www.bilibili.com/video/BV1Kb411W75N?p=1
 認識Java、環境配置 常用DOS操作  就是windows的cmd，影視中駭客情節常常出現的小黑窗，可以用文字操作基本的軟體功能
   cd=進入指定目錄
  cd..=回上層
  cd=回到根目錄
  變更硬碟目錄=直接輸入d:
  dir=列出當前目錄下的清單
  del=刪除檔案(對文件夾使用=刪除文件內所有檔案)
  md=創建目錄
  rd=刪除目錄
  exit=退出
  Java體系在不同平台的版本演化  Java SE，標準版，桌面級應用等，基礎API Java EE，企業版，主要用於Web開發，包含Servlet、JSP等技術 Java ME，小型版，古老的PDA、手機等，已過時 Java Card，面向小程序(Applets)，運行在小設備(如智能卡)等平台  Java語言特性  由繼承的脈絡可說JAVA是類C語言
  強制物件導向:總是基於&amp;quot;某件東西去做事&amp;quot;，得先搞懂何謂&amp;quot;類&amp;quot;與&amp;quot;物件&amp;quot;  三大特性:封裝、繼承、多態   健壯性:強類型、異常處理、GC(垃圾回收)、丟棄指針等 跨平台:只要平台能跑JVM(虛擬機)就能跑JAVA  Java的運行環境  JDK包含JRE包含JVM
  JDK，Java Development Kit，開發工具包，給開發人員用的，包含了JRE以及編譯工具(javac.</description>
    </item>
    
    <item>
      <title>LeetCode:1.Two Sum、9.Palindrome Number、13.Roman to Integer</title>
      <link>https://yoziming.github.io/post/211116-leetcode1&#43;9&#43;13/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-leetcode1&#43;9&#43;13/</guid>
      <description>1. Two Sum
 求某數組中哪兩位數的和等於X
 // go // nums []int=傳入的數組；target=X func twoSum(nums []int, target int) []int { m := make(map[int]int, len(nums)) for i, num := range nums { if idx, ok := m[target-num]; ok { return []int{idx, i} } m[num] = i } return []int{0, 0} } 9. Palindrome Number
 判斷是否為迴文數字，例如121
 // java public boolean isPalindrome(int x) { // 判斷是否迴文，如121、2332、456654  // 負數或尾數是0或&amp;lt;10的顯然可以排除  if (x &amp;lt; 0 || (x !</description>
    </item>
    
    <item>
      <title>修改css或js後瀏覽器快取不更新問題</title>
      <link>https://yoziming.github.io/post/211017-explorer_cache_problems_with_cssjs/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211017-explorer_cache_problems_with_cssjs/</guid>
      <description>修改css或js後瀏覽器快取不更新問題  當初我真的是被這個整到懷疑人生
 解決方式一：
​ 使用者按Ctrl + F5強制重新整理頁面或者手動清空了瀏覽器的快取。此時瀏覽器會重新向伺服器獲取CSS和JS檔案,新的檔案便會生效。
解決方式二：
​ 但是使用者量過大的時候總不能讓每個使用者一一清理快取吧，於是便從程式碼的角度著手解決這個問題。在js後面新增版本號，讓瀏覽器把這個JS檔案當做新的檔案重新向伺服器獲取資源。
加版本號前：
 &amp;lt;script type=&amp;#34;text/javascript&amp;#34; th:src=&amp;#34;@{/js/test/index.js}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  加版本號後：
 &amp;lt;script type=&amp;#34;text/javascript&amp;#34; th:src=&amp;#34;@{/js/test/index.js?v=1.0}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  參考 https://www.itread01.com/content/1548610940.html</description>
    </item>
    
    <item>
      <title>Docker &amp; Hyper-V占用port問題</title>
      <link>https://yoziming.github.io/post/211015-dockerhyper-v-port-problem/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211015-dockerhyper-v-port-problem/</guid>
      <description>Docker &amp;amp; Hyper-V占用port問題 在window下用docker desktop有時候遇上port被莫名佔用 用指令netstat -ano | findstr xxx查詢xxx埠被誰佔用卻又顯示沒有
原來是因為在window下用docker需要依賴hyper-v技術， 而這個hyper-v每次都會隨機搶走一部分tcp埠，使用命令可以得知應避開的範圍:
# powershell / cmd netsh interface ipv4 show excludedportrange protocol=tcp 如果避不開就手動叫Hyper-V讓路   關閉hyper-v
# powershell / cmd dism.exe /Online /Disable-Feature:Microsoft-Hyper-V   配置ipv4動態埠 / 或者配置需要的埠不被佔用
# powershell / cmd 管理員許可權 # start 起始埠 num 表示可用埠數 按自己的需求來 netsh int ipv4 set dynamicport tcp start=30000 num=16383 // 叫他去用30000以後的阜 # 排除ipv4動態埠佔用 startport 起始埠 numberofports 埠數 netsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1 // 或是指定端口50051為要讓路的   重新啟動hyper-v</description>
    </item>
    
    <item>
      <title>ubuntu常用操作</title>
      <link>https://yoziming.github.io/post/211010-ubuntu-common-operations/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211010-ubuntu-common-operations/</guid>
      <description>ubuntu常用操作  ubuntu 屋奔兔，算是最常見的Linux系統
 // 解壓縮XX檔案到/usr/local sudo tar -C /usr/local -xzvf go1.17.1.linux-amd64.tar.gz
// 文字編輯器 sudo gedit /home/yoziming/.config/go/env
// 檔案總管 sudo nautilus
// 啟用go mod go env -w GO111MODULE=on</description>
    </item>
    
    <item>
      <title>Kubernetes基礎認識</title>
      <link>https://yoziming.github.io/post/211006-k8s/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211006-k8s/</guid>
      <description>Kubernetes基礎認識  自動化地以容器的形式管理你的應用程式 To host your application in the form of containers in a automated fashion
 名詞解釋   Cluster:集群，計算、儲存資源的集合。一個Cluster通常包含一個Controller Plane和數個Node，視需求而定(也可能有Multi-Controller Plane 的集群)
 Controller Plane:(以前叫Mater)控制主節點，調度指揮所  APIserver:管理整個 K8s 所需 API 的接口(Endpoint)，提供HTTP Rest介面的關鍵服務處理程序，是集群中各個節點的溝通橋樑 etcd:存資料 Scheduler:資源調配，例如調度Pod運行在哪個Node Controller-manager:總經理，負責管理並運行 controller ，controller定義各種Pod的部屬特性(如最常用的Deployment)來滿足不同的業務場景   Node:節點，讓物件(resource-objects)運行的實體或虛擬機器  kubelet:對應api-server的接口，可以看成每個Node上的&amp;quot;實際執行者&amp;quot;或&amp;quot;操作者&amp;quot;，負責接收來自api-server的訊息，並做出相對應的動作，例如，負責Pod對應的容器的建立、啟動或停止等。 kube-proxy:維護網路規則(iptables)，這些規則允許從群集內部或外部的與Pod進行通訊。 Container Runtime:容器的運行引擎，預設是Docker，也支援其他滿足CRI標準的。  Pod:可被調度的最小單位，每個Pod包含一或多個容器，Pod內共享生命週期、資源、通信(使用同一個網路namespace，即相同的IP與port)、儲存空間。通常使用是一個Pod中放一個容器；當需要高度共享資源時才會用一個Pod內多個容器的形式      延伸觀念  Deployment:部屬，例如把Pod做橫向擴展，適用自動管理，或達成無停機系統升級 Service:服務，Deployment可以部屬多個Pod，每個Pod都有自己的IP，隨時都在生滅浮動，外界如何訪問? 答案就是透過Service，可以說Controller負責運行Pod，而Service負責訪問Pod。 Ingress:Service 中是將每個 Service 元件對外的 port number 跟 Node 上的 port number 做 mapping，這樣在我們的 Service 變多時，port number 以及分流規則的管理變得相當困難。而 Ingress 可以透過 HTTP/HTTPS，在我們眾多的 Service 前搭建一個 reverse-proxy。這樣 Ingress 可以幫助我們統一一個對外的 port number，並且根據 hostname 或是 pathname 決定封包要轉發到哪個 Service 上 Namespace:命名空間，假如有多個用戶使用同一個Cluster，想把他們創建的Controller、Pod等資源分開，就靠Namespace。Namespace將物理的Cluster從邏輯上切成多個虛擬Cluster，每一個虛擬Cluster就是一個Namespace，不同Namespace中的資源完全隔離。K8s默認創建2個Namespace:  default:如果不指定，資源就預設放這 kube-system:K8s自己創建的系統資源會放在這個Namespace中      </description>
    </item>
    
    <item>
      <title>MySQL常用語句 &amp; Workbench</title>
      <link>https://yoziming.github.io/post/211005-mysql-cmdworkbench/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211005-mysql-cmdworkbench/</guid>
      <description>MySQL 常用語句 資料庫database
create database XXX;show databases;use XXX;drop database XXX;資料表table
create table mytable(school char(5),name char(10),id int);show tables;describe mytable; // 顯示這表有哪些欄位跟屬性drop table mytable;select * from mytable; // 顯示mytable中所有資料insert into mytable(school, name, id) values (&#39;NCTU&#39;,&#39;Jerry&#39;,&#39;123&#39;);insert into mytable values (&#39;NCTU&#39;,&#39;Jerry&#39;,&#39;123&#39;);update mytable set name = &#39;HaHa&#39; where id = &#39;123&#39;;delete from mytable where name = &#39;HaHa&#39;;delete from 表格; // 把表格內資料都刪除(但格式宣告還在)select * from mytable where id = &#39;123&#39; order by name DESC; // 資料表查詢+條件+排序 (DESC 代表由大到小排序)load data local infile &amp;quot;c:\\data.</description>
    </item>
    
    <item>
      <title>Docker啟用Redis</title>
      <link>https://yoziming.github.io/post/211002-docker-redis/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211002-docker-redis/</guid>
      <description>Docker啟用Redis 抓映象檔 docker pull redis:6.0 拉一個6.0版本的redis  執行 Image docker run --name redis6 -p 6379:6379 -d redis:6.0 redis-server --appendonly yes –name redis6 ：將 Container 取名為 redis6 -p 6379:6379 ：將 Container 的 6379 Port 映射到主機的 6379 Port (前面代表主機，後面代表容器) -d :後台執行 Container ，並返回ID redis-server –appendonly yes : 在 Container 執行 redis-server 啟動命令，並打開redis持久化配置  進入 Container docker exec -it redis6 bash -i ：即使沒有附加也保持STDIN 打開 -t ：分配一個偽終端  資料庫測試 redis-cliset hello worldget hello</description>
    </item>
    
    <item>
      <title>Docker啟用Mysql</title>
      <link>https://yoziming.github.io/post/211001-docker-mysql/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211001-docker-mysql/</guid>
      <description>Docker啟用Mysql 抓映象檔 docker pull mysql/mysql-server:8.0 拉一個8.0版本的mysql  執行 Image docker run -d -it --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=mydb mysql:8 --default-authentication-plugin=mysql_native_password -d：同--detach，以背景模式執行。 -v ~/mysql-docker-data:/var/lib/mysql：同--volume，掛載host目錄到container目錄，也就是host的~/mysql-docker-data會保存container /var/lib/mysql的資料；windos docker app這樣做的話，資料是暫時的重開機後會不見。 -it：同--interactive加--tty，作用為運行container時可登入其bash操作。 --name mysql8，命名container名稱為mysql8。 -p：同--publish。作用為將container的3306 port對映到&amp;quot;主機(host)&amp;ldquo;的3306 port -e：同--env，設定環境變數。MYSQL_ROOT_PASSWORD設定MySQL root帳號的登入密碼為1234，MYSQL_DATABASE設定資料庫名稱為mydb。 mysql:8：mysql為image名稱，8為image tag。所以運行的是mysql:8的image。 --default-authentication-plugin=mysql_native_password：把儲存密碼的方式改為MySQL 5的mysql_native_password，因為MySQL 8的儲存方式預設為caching_sha2_password，但一些免費的MySQL client圖形工具如Sequel Pro，Navicat等會無法連線，所以設定此參數。  檢視運行中的容器 docker ps進入 Container docker exec mysql8 mysql -u root -p docker exec指令的作用為在運行的container執行指令，所以意思就是在mysql8這個container執行mysql -u root -p的指令。  docker container exec -it mysql8 /bin/bash 遇到權限問題用這個  進入Mysql mysql -uroot -p新增 1 個開放外部連線的帳號 CREATE USER &#39;user01&#39;@&#39;%&#39; IDENTIFIED BY &#39;1234&#39;;GRANT ALL ON your_database.</description>
    </item>
    
    <item>
      <title>Docker常用語句</title>
      <link>https://yoziming.github.io/post/210930-docker-common-operations/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210930-docker-common-operations/</guid>
      <description>Docker常用語句 抓映象檔 docker pull xxx檢視運行中的容器 docker ps進入 Container docker exec -it &amp;lt;container_id&amp;gt; /bin/bash -i ：即使沒有附加也保持STDIN 打開 -t ：分配一個偽終端  查看字元編碼 locale臨時改成UTF8 export LANG=&amp;quot;en_US.UTF-8&amp;quot;  永久設置需在Dockerfile中設置環境字元集環境變數
ENV LANG=&amp;quot;en_US.UTF-8&amp;quot;  </description>
    </item>
    
    <item>
      <title>Docker啟用MinIO</title>
      <link>https://yoziming.github.io/post/210929-docker-minio/</link>
      <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210929-docker-minio/</guid>
      <description>Docker啟用MinIO儲存 執行 Image docker run -d --name minio -e &amp;quot;MINIO_ROOT_USER=root&amp;quot; -e &amp;quot;MINIO_ROOT_PASSWORD=root1234&amp;quot; -p 9000:9000 -p 9001:9001 minio/minio server /data --console-address &amp;quot;:9001&amp;quot;  --name minio，命名container名稱為minio。 -v /data/minio:/data/minio該命令將主機 /data/minio 目錄對映到容器中的 /data/minio 目錄中 MinIO 還提供了圖形管理介面，在瀏覽器輸入 ip:9001即可檢視 不管是圖形介面操作，還是客戶端操作，預設賬號密碼都為 minioadmin -e環境變數，這裡用了自定義賬號密碼，賬號不能小於 3 字元，密碼不能小於 8 字元  Go初始化 導入github.com/minio/minio-go/v7，注意這個後面的v7，在自動引包時可能會漏掉，導致使用到舊版的同名函數而報錯
func InitMinio() { ctx := context.Background() endpoint := &amp;#34;localhost:9000&amp;#34; accessKeyID := &amp;#34;root&amp;#34; secretAccessKey := &amp;#34;root1234&amp;#34; useSSL := false // Initialize minio client object. 	minioClient, err := minio.</description>
    </item>
    
    <item>
      <title>consul基礎使用練習</title>
      <link>https://yoziming.github.io/post/210928-consul-practice/</link>
      <pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210928-consul-practice/</guid>
      <description>consul基礎使用練習  想像去郵局辦事，consul類似於發號碼牌的那個機器
伺服端(櫃台人員)去找consul註冊服務，比如說櫃台1~3提供儲蓄，櫃台4~6提供郵寄服務
客戶進來透過服務發現，把要辦的事丟給consul，它查看哪個櫃台健康，幫你匹配對應的服務或叫號
(感覺這例子不太完善，就&amp;hellip;類似的理解啦，實際用了才會懂)
   下載
# 官網:https://www.consul.io/downloads# ubuntu shell: (下載&amp;gt;解壓縮&amp;gt;把二進位執行檔丟進去)wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zipunzip consul_1.10.3_linux_amd64.zipsudo mv consul /usr/local/bin/  測試
consul -h  啟動server
consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=192.168.234.128 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0這個IP=192.168.234.128=ubuntu的ip
*若/etc/consul.d/不存在要先自己創
  查看服務
http://192.168.234.128:8500/  註冊自訂的健康檢查服務，範例:
剛剛自訂的配置檔路徑/etc/consul.d/下新增一個web.json
{&amp;quot;service&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;web&amp;quot;,&amp;quot;tags&amp;quot;: [&amp;quot;extract&amp;quot;, &amp;quot;verify&amp;quot;, &amp;quot;compare&amp;quot;, &amp;quot;idcard&amp;quot;],&amp;quot;address&amp;quot;: &amp;quot;192.168.234.128&amp;quot;,&amp;quot;port&amp;quot;: 9000,&amp;quot;check&amp;quot;: {&amp;quot;id&amp;quot;: &amp;quot;api&amp;quot;,&amp;quot;name&amp;quot;: &amp;quot;HTTP API on port 9000&amp;quot;,&amp;quot;http&amp;quot;: &amp;quot;http://localhost:9000&amp;quot;,&amp;quot;interval&amp;quot;: &amp;quot;10s&amp;quot;,&amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;}}}  重啟server並查看服務</description>
    </item>
    
    <item>
      <title>Golang下透過grpc調用服務案例</title>
      <link>https://yoziming.github.io/post/210927-grpc/</link>
      <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210927-grpc/</guid>
      <description>Golang下透過grpc調用服務案例  grpc簡單說就是跨平台(跨語言)調用各種服務的通用轉接口
 對.proto文件使用轉譯指令:
protoc --go_out=plugins=grpc:. *.proto 案例:透過grpc遠程傳遞一個調用teacher資料類型的服務
 .proto:
syntax=&amp;quot;proto3&amp;quot;;option go_package=&amp;quot;/.;pb&amp;quot;;message Teacher{int32 age=1;string name=2;}service SayName{rpc SayHello(Teacher) returns(Teacher);}server:
type Children struct{}// 綁定類方法func (c *Children) SayHello(ctx context.Context, t *pb.Teacher) (*pb.Teacher, error) {t.Name += &amp;quot;is sleeping&amp;quot;return t, nil}func main() {// 初始一個grpc對象grpcServer := grpc.NewServer()// 註冊服務pb.RegisterSayNameServer(grpcServer, new(Children))// 監聽listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.</description>
    </item>
    
    <item>
      <title>Golang中使用ProtoBuf</title>
      <link>https://yoziming.github.io/post/210926-golang-protobuf/</link>
      <pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210926-golang-protobuf/</guid>
      <description>Golang中使用ProtoBuf  protobuf類似json，它體積更小效率更高，規範統一(沒有大小寫等困擾)。
缺點是改動協議就要重新生成、數據本身是二進位沒有可讀性
   下載，window系統選.exe，解壓縮放到$GOPATH/bin
https://github.com/protocolbuffers/protobuf/releases  安裝golang對應的庫跟插件
go get github.com/golang/protobuf/protogo get github.com/golang/protobuf/protoc-gen-go  測試
protoc -h 或 protoc --version沒報錯就是成功
  消息體舉例，xxx.proto
// 指定版本，不打3就會是2syntax=&amp;quot;proto3&amp;quot;;// 指定輸出位置&amp;amp;go包名，沒寫轉換不了// option go_package =&amp;quot;path;name&amp;quot;;option go_package =&amp;quot;/.&amp;quot;; // 放在同一目錄下包名為__(空)// 定義消息體，分配唯一編號 (不能用19000~19999)message Student{int32 age = 1; // 可以不從1開始，但不可重複string name = 2;People p=3;repeated int32 score=4; // 數組Week w=5;// 聯合體oneof data{string teacher=6;string class=7;}}// 消息體可以嵌套message People{int32 weight=1;}// 定義枚舉類型enum Week{Monday=0; // 必須從0開始Turesday=1;}  生成go文件</description>
    </item>
    
    <item>
      <title>MVC &amp; Microservices</title>
      <link>https://yoziming.github.io/post/210920-mvcmicroservices/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210920-mvcmicroservices/</guid>
      <description>MVC架構 Model:模型，管理資料庫(增刪改查)、業務邏輯、物件結構定義
View:視圖，使用者實際在看、操作的介面(UI)，前端
Controller:控制，接收請求、回覆結果，決定工作流程，算是Model跟View的中間人
微服務架構（Microservices）  單一職責:把業務邏輯拆分成無數個小區塊(Blocks)，負責單一任務，服務之間透過管道來通訊。 輕量級通訊:使用不依賴語言或平台的格式，例如XML、JSON、protobuf。通常基於HTTP協議、符合REST風格來達成標準化、無狀態化。 獨立開發、測試、部屬:顧名思義，都拆開了就可以分開做，不像傳統架構牽一髮而動全身。 容器化:微服務既然能獨立作業了，就可以放到容器(Container)中，互相隔離互不干擾，達成快速部署、節省資源。Docker是目前最普遍的容器技術，Kubernetes(K8s)是常用來管理容器、協調整合的平台。  </description>
    </item>
    
    <item>
      <title>GoogleSearchConsole</title>
      <link>https://yoziming.github.io/post/211020-blog-ga/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211020-blog-ga/</guid>
      <description>如何讓自己的blog被google搜尋到  首先你要跟google證明這個網站是你的，並且允許google的爬蟲機器人獲取你的網站資料，這樣別人才能在google上搜尋到你的網站 同時也能夠使用google自訂搜尋方便自己查找資料  關於網站驗證  你同意後它才能把觸手深入你的網站，你可以自訂搜尋這個網站的資料權限 google提供多種方法，我是選html標記，放在套用的主題的之下，舉例:   如果你換了主題記得也要重改  Hugo建立sitemap索引  提供sitemap索引讓google機器人更好抓你的網站 Hugo內鍵就有這個功能，修改config.toml，插入:  [sitemap]changefreq = &#39;weekly&#39;filename = &#39;sitemap.xml&#39;priority = 0.5自訂搜尋 大部分主題都有此功能，一樣修改config.toml即可:
googleSearchCode = &amp;quot;你的SearchCode&amp;quot;</description>
    </item>
    
    <item>
      <title>HugoBlog的圖片插入方式</title>
      <link>https://yoziming.github.io/post/210930-blog-insert-image/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210930-blog-insert-image/</guid>
      <description>插入圖片的方式  常見有2種做法
 方法1  在.\static\images\下放入的圖片會被打包上傳，然後從相對路徑引用那個圖片 適和用在全站通用的資源，比如背景圖、縮圖  方法2   在.\content\post\下，每當有用到圖片一篇文章的就新增一個資料夾
  資料夾可以命名可自訂，然後進去把.md檔改名為&amp;quot;index.md&amp;quot;，圖片放同層
  範例:  這個方法比較好整理，每篇用到的圖片放在自己的資料夾中
  </description>
    </item>
    
    <item>
      <title>用Hugo建立靜態Blog</title>
      <link>https://yoziming.github.io/post/210909-blog-hugo/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210909-blog-hugo/</guid>
      <description>用Github&amp;amp;Hugo建立靜態Blog  程式設計師寫blog再常見不過，好處多多不再贅述，但如何從0開始架出一個blog?
我看了很多教學有各種高級的自動部署、netlify後台等等，照做時卻老是在一些關鍵點卡住。我這個土路雖然蠢笨但確實能做出東西，同樣新手可以試試。
   安裝Chocolatey //程式安裝器，讓你從終端裝各種東西很方便
https://chocolatey.org/install到這個網址，官方提供很多方法安裝，非常簡單快速一行搞定安裝hugo，有些佈景主題要用到加強版(extended)
choco install hugo -confirmchoco install hugo-extended -confirm  hugo new site &amp;lt;資料夾名稱&amp;gt; //建立一個root，相當於你個人網站的原始資料母巢
  挑主題，到https://themes.gohugo.io/
  套用主題，範例
 cd &amp;lt;資料夾名稱&amp;gt;git initgit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary  依照主題的說明文件修改根目錄下的config.toml 注意，config.toml中的第一項baseURL網址不要有&amp;quot;https://www.ooxx&amp;quot;，否則會造成一些未知的BUG。正確網址應為&amp;quot;https://你的username.github.io/&amp;quot;
  到content/post/下開始寫一篇blog
  開啟本地預覽，指令hugo server -F //防止時差問題用-F
  隨意一個地方開啟網址http://localhost:1313/ 看看網站
  網站沒問題就打包，指令hugo，會在root資料夾下多出一個public資料夾，裡面就是一個完整的網站準備丟去網路上發布
  去gitHub建一個Repository(倉庫)，名稱強制為 你的username.github.io
  下載GitHub Desktop客戶端，可以把他理解成一個雲端，我要把本地public資料夾的內容透過它丟去gitHub上剛剛建的那個Repository(倉庫)裡，之後就能透過網站提供的gitPage功能實現個人網站的搭建</description>
    </item>
    
    <item>
      <title>一次性隊列</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/</guid>
      <description>一次性隊列 //用結構體管理隊列type Queue struct {maxSize intarray [3]intfront int //隊列首(不包含)rear int //隊尾(含)}//添加數據val到隊列func (q *Queue) AddQueue(val int) (err error) {//先判斷是否已滿if q.rear == q.maxSize-1 {return errors.New(&amp;quot;queue full&amp;quot;)}q.rear++q.array[q.rear] = valreturn}//取出數據func (q *Queue) GetQueue() (val int, err error) {//先判斷是否為空if q.rear == q.front {return -1, errors.New(&amp;quot;queue empty&amp;quot;)}q.front++val = q.array[q.front]return val, err}//顯示隊列func (q *Queue) ShowQueue() {fmt.</description>
    </item>
    
    <item>
      <title>二分樹的3種遍歷</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/</guid>
      <description>二分樹的3種遍歷 package mainimport &amp;quot;fmt&amp;quot;type Hero struct {No intName stringLeft *HeroRight *Hero}//前序遍歷 先輸出root 再輸出左子樹 再輸出右子樹，會中左右一層層往下func PreOrder(node *Hero) {if node != nil {fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)PreOrder(node.Left)PreOrder(node.Right)}}//中序遍歷 左子樹 root 右子樹func InfixOrder(node *Hero) {if node != nil {InfixOrder(node.Left)fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)InfixOrder(node.Right)}}//後序遍歷 左子樹 右子樹 root，會一路到最左最下開始打func PostOrder(node *Hero) {if node !</description>
    </item>
    
    <item>
      <title>哈希表數據結構</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/</guid>
      <description>哈希表數據結構 package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;os&amp;quot;)type Emp struct {Id intName stringNext *Emp}func (e *Emp) ShowMe() {fmt.Printf(&amp;quot;链表%d 找到该雇员 %d\n&amp;quot;, e.Id%7, e.Id)}//不帶表頭，即第一個節點就放雇員資料type EmpLink struct {Head *Emp}func (e *EmpLink) FindByIdEmpLink(id int) *Emp {cur := e.Headfor {if cur != nil &amp;amp;&amp;amp; cur.Id == id {return cur} else if cur == nil {break}cur = cur.</description>
    </item>
    
    <item>
      <title>單向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>單向鏈表 type HeroNode struct {no intname stringnext *HeroNode //表示指向下一個節點}//給鏈表插入節點func Insert(head *HeroNode, newHeroNode *HeroNode) {//先找到最後的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break}temp = temp.next //不斷往下找}//把newHeroNode加到屁股temp.next = newHeroNode}//根據No從小到大插入func InsertNo(head *HeroNode, newHeroNode *HeroNode) {//想找到適當的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break} else if temp.next.no &amp;gt; newHeroNode.no {//表示new要插到temp後break} else if temp.</description>
    </item>
    
    <item>
      <title>插入&amp;選擇&amp;快速排序</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E6%8F%92%E5%85%A5%E9%81%B8%E6%93%87%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E6%8F%92%E5%85%A5%E9%81%B8%E6%93%87%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>插入&amp;amp;選擇&amp;amp;快速排序 //選擇排序func SelectSort(array *[6]int) {for j := 0; j &amp;lt; len(array)-1; j++ {min := array[j]minIndex := j//尋找最小的下標for i := j + 1; i &amp;lt; len(array); i++ {if min &amp;gt; array[i] {min = array[i]minIndex = i}}if minIndex != j {array[j], array[minIndex] = array[minIndex], array[j]}fmt.Printf(&amp;quot;第%d次交換後 %v\n&amp;quot;, j+1, *array)}}//插入排序func InsertSort(arr *[6]int) {for j := 1; j &amp;lt; len(arr); j++ {//給第二個元素找位置insertVal := arr[j]insertIndex := j - 1 //下標//由大到小for insertIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[insertIndex] &amp;lt; insertVal {arr[insertIndex+1] = arr[insertIndex] //數據後移insertIndex--}//插入if insertIndex+1 !</description>
    </item>
    
    <item>
      <title>模擬棧&amp;四則運算</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E6%A8%A1%E6%93%AC%E6%A3%A7%E5%9B%9B%E5%89%87%E9%81%8B%E7%AE%97/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E6%A8%A1%E6%93%AC%E6%A3%A7%E5%9B%9B%E5%89%87%E9%81%8B%E7%AE%97/</guid>
      <description>模擬棧&amp;amp;四則運算 //模擬棧的使用type Stack struct {MaxTop int //最大可存個數Top int //頂arr [20]int}func (s *Stack) Push(val int) (err error) {//先判斷是否滿if s.Top == s.MaxTop-1 {fmt.Println(&amp;quot;stack full&amp;quot;)return errors.New(&amp;quot;stack full&amp;quot;)}//放入數據s.Top++s.arr[s.Top] = valreturn}func (s *Stack) Pop() (val int, err error) {//先判斷是否空if s.Top == -1 {fmt.Println(&amp;quot;stack empty&amp;quot;)return 0, errors.New(&amp;quot;stack empty&amp;quot;)}//彈出數據val = s.arr[s.Top]s.Top--return val, nil}//遍歷func (s *Stack) List() {//先判斷是否空if s.</description>
    </item>
    
    <item>
      <title>環形單向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E7%92%B0%E5%BD%A2%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E7%92%B0%E5%BD%A2%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>環形單向鏈表 type CatNode struct {no intname stringnext *CatNode}func Insert(head *CatNode, newCatNode *CatNode) {//判斷是否第一隻貓if head.next == nil {head.no = newCatNode.nohead.name = newCatNode.namehead.next = head //構成環形fmt.Println(*newCatNode, &amp;quot;已初始化並加入環形鏈表&amp;quot;)return}//定義一個變量找到環形最後一個temp := headfor {if temp.next == head {break}temp = temp.next}temp.next = newCatNodefmt.Println(*newCatNode, &amp;quot;已加入環形鏈表&amp;quot;)newCatNode.next = head}func Del(head *CatNode, id int) *CatNode {temp := headhelper := headif temp.</description>
    </item>
    
    <item>
      <title>稀疏數組</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E7%A8%80%E7%96%8F%E6%95%B8%E7%B5%84/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E7%A8%80%E7%96%8F%E6%95%B8%E7%B5%84/</guid>
      <description>稀疏數組 type ValNode struct {row int //橫的col int //直的val int}func main() {//創建數組範例var chessMap [11][11]intchessMap[1][2] = 1chessMap[2][3] = 2//輸出看樣子for _, v := range chessMap {for _, v2 := range v {fmt.Printf(&amp;quot;%d\t&amp;quot;, v2)}fmt.Println()}//轉成稀疏數組，思路:遍歷他，創造一個結構體，發現有值就放進對應的切片var sparseArr []ValNode//紀錄規模跟預設值valNode0 := ValNode{row: 11,col: 11,val: 0,}sparseArr = append(sparseArr, valNode0)for i, v := range chessMap {for j, k := range v {if k !</description>
    </item>
    
    <item>
      <title>約瑟夫問題</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E7%B4%84%E7%91%9F%E5%A4%AB%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E7%B4%84%E7%91%9F%E5%A4%AB%E5%95%8F%E9%A1%8C/</guid>
      <description>約瑟夫問題 type Boy struct {No intNext *Boy //指向下一個小孩的指針}func addBoy(num int) *Boy {//num表示小孩的個數，*Boy返回第一個小孩的指針first := &amp;amp;Boy{}temp := &amp;amp;Boy{}if num &amp;lt; 1 {fmt.Println(&amp;quot;num值錯誤&amp;quot;)return first}for i := 1; i &amp;lt;= num; i++ {boy := &amp;amp;Boy{No: i,}if i == 1 {first = boy //不變temp = boytemp.Next = first} else {temp.Next = boytemp = boytemp.</description>
    </item>
    
    <item>
      <title>迷宮遞迴</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/</guid>
      <description>迷宮遞迴 func SetWay(myMap *[8][7]int, a int, b int) bool {//a,b 表示對地圖的那個點測試//找到出口if myMap[6][5] == 2 {return true} else {//繼續找if myMap[a][b] == 0 { //可探測的點myMap[a][b] = 2 //踩上去了，再探上下左右，但是我知道要往下往右探if SetWay(myMap, a+1, b) { //下return true} else if SetWay(myMap, a, b+1) { //右return true} else if SetWay(myMap, a-1, b) { //上return true} else if SetWay(myMap, a, b-1) { //左return true} else { //死路myMap[a][b] = 3return false}} else { //不可探測的點return false}}}func main() {//定義地圖 1=牆壁 0=沒走過的點 2=通路 3=走過的死路var myMap [8][7]int//四周設置圍牆for i := 0; i &amp;lt; 7; i++ {myMap[0][i] = 1myMap[7][i] = 1}for i := 0; i &amp;lt; 8; i++ {myMap[i][0] = 1myMap[i][6] = 1}myMap[3][1] = 1myMap[3][2] = 1//看樣子for i := 0; i &amp;lt; 8; i++ {for j := 0; j &amp;lt; 7; j++ {fmt.</description>
    </item>
    
    <item>
      <title>雙向鏈表</title>
      <link>https://yoziming.github.io/post/210815-agg-go-al-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210815-agg-go-al-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
      <description>雙向鏈表 type HeroNode struct {no intname stringpre *HeroNode //表示指向前一個節點next *HeroNode //表示指向下一個節點}//給鏈表插入節點func Insert(head *HeroNode, newHeroNode *HeroNode) {//先找到最後的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break}temp = temp.next //不斷往下找}//把newHeroNode加到屁股temp.next = newHeroNodenewHeroNode.pre = temp}//根據No從小到大插入func InsertNo(head *HeroNode, newHeroNode *HeroNode) {//想找到適當的節點，創建一個輔助temp := headfor {if temp.next == nil { //表示找到最後break} else if temp.</description>
    </item>
    
    <item>
      <title>channel通道</title>
      <link>https://yoziming.github.io/post/210810-agg-go-channel/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-channel/</guid>
      <description>channel通道 lock sync與chan基本認識 //階乘1-n 把各個數放到map中 用goroutine完成var (myMap = make(map[int]int, 10)//聲明一個全局的互斥鎖lock sync.Mutex//來點管道 記得要make初始化才能用intChan chan int = make(chan int, 3)//聲明類型為空接口可以接收任意類型allChan chan interface{} = make(chan interface{}, 5)//注意後面沒聲明容量則不給用)type Cat struct {Name stringAge int}func test(n int) {res := 1for i := 1; i &amp;lt;= n; i++ {res = res * i}//把res放進mayMap//加鎖lock.Lock()myMap[n] = res//解鎖lock.</description>
    </item>
    
    <item>
      <title>const常量</title>
      <link>https://yoziming.github.io/post/210810-agg-go-const/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-const/</guid>
      <description>const常量  常量 聲明時必須賦值、不能修改、只能是bool、數值、string，賦值需是一個確定的值
 func main() {const tax int = 10const x = 9 / 3// const c = 9 / a //因為a可能是一個變量所以這樣不行// var a int = 3fmt.Println(tax, x)const (a = iota //表示a=0b //b=a+1c //c=b+1)fmt.Println(a, b, c)const (d = iotaef, g = iota, iota)fmt.Println(d, e, f, g)//其他程式語言常量會用全大寫，go中沒限制，且一樣用首字母大小來控制使用範圍}</description>
    </item>
    
    <item>
      <title>defer臨走前啟用</title>
      <link>https://yoziming.github.io/post/210810-agg-go-defer/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-defer/</guid>
      <description>defer臨走前啟用  退出函數前才執行
 func sum(n1, n2 int) int {defer fmt.Println(&amp;quot;ok1&amp;quot;, n1)defer fmt.Println(&amp;quot;ok2&amp;quot;, n2)//defer棧先入後出n1++n2++res := n1 + n2fmt.Println(&amp;quot;ok3 res=&amp;quot;, res)return res}func main() {res := sum(10, 20)fmt.Println(&amp;quot;res=&amp;quot;, res)}</description>
    </item>
    
    <item>
      <title>goroutine</title>
      <link>https://yoziming.github.io/post/210810-agg-go-goroutine/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-goroutine/</guid>
      <description>goroutine  進程=程序在操作系統中的一次進行過程
線程=執行實例的最小單位
  一個進程可以創建多個線程且併發執行 一個程序至少包含一個進程，一個進程至少包含一個線程 併發=多線程程序在單核上運行 併行=多線程程序在多核上運行  GO的主線程(可以理解為進程)，一個GO進程上可以起很多協程，協程可以理解為輕量級的線程，協程特點:
 有獨立的棧空間 共享程序堆空間 調度由用戶控制 為輕量級的線程  func test() {for i := 0; i &amp;lt; 10; i++ {fmt.Println(&amp;quot;test()Hello,world&amp;quot; + strconv.Itoa(i))time.Sleep(time.Second / 10)}}func main() {go test() //開啟一個協程//如果主線程退出了，即使協程還沒執行完，也會退出//協程可以自己先結束for i := 0; i &amp;lt; 10; i++ {fmt.Println(&amp;quot;main()Hello,go&amp;quot; + strconv.Itoa(i))time.Sleep(time.Second / 10)}go test() //開啟一個協程，主線程退出了，即使協程還沒執行完，也會退出//查邏輯CPU數量cpuNum := runtime.NumCPU()fmt.Println(cpuNum)//設置最大線程數量runtime.</description>
    </item>
    
    <item>
      <title>Go使用mysql與事務操作</title>
      <link>https://yoziming.github.io/post/210810-agg-go-mysql/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-mysql/</guid>
      <description>Go使用mysql與事務操作 基本操作 import (&amp;quot;database/sql&amp;quot;&amp;quot;fmt&amp;quot;_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;)var db *sql.DB // 是一個連接池對象// user 接收數據type user struct {id intname stringage int}func initDB() (err error) {dsn := &amp;quot;root:root@tcp(127.0.0.1:3306)/sql_test&amp;quot;db, err = sql.Open(&amp;quot;mysql&amp;quot;, dsn) // 這個db要用全局的，重要!if err != nil {return}err = db.Ping()if err != nil {return} else {fmt.Println(&amp;quot;連接成功&amp;quot;)}return}// 查詢一個func find1() {var u1 usersqlStr := `select id, name, age from user where id=?</description>
    </item>
    
    <item>
      <title>JSON序列化</title>
      <link>https://yoziming.github.io/post/210810-agg-go-json/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-json/</guid>
      <description>JSON序列化  JSON 格式 {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:&amp;ldquo;值2&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:[&amp;ldquo;值2數組&amp;rdquo;,值2數組]}
 type Monster struct {Name string `json:&amp;quot;name&amp;quot;` //反射機制Age int `json:&amp;quot;age&amp;quot;`Sal float64 `json:&amp;quot;sal&amp;quot;`}func test1() {monster1 := Monster{Name: &amp;quot;牛魔王&amp;quot;,Age: 50,Sal: 8000.0,}data, err := json.Marshal(&amp;amp;monster1)if err != nil {fmt.Println(err)}fmt.Println(string(data))}//把map序列化func testMap() {var mapA map[string]interface{} = make(map[string]interface{})mapA[&amp;quot;name&amp;quot;] = &amp;quot;紅孩兒&amp;quot;mapA[&amp;quot;age&amp;quot;] = 18data, err := json.Marshal(&amp;amp;mapA)if err !</description>
    </item>
    
    <item>
      <title>Map集合</title>
      <link>https://yoziming.github.io/post/210810-agg-go-map/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-map/</guid>
      <description>Map集合 func main() {// map[key類型] value類型var m1 map[int]int = make(map[int]int)//key類型通常是int or string//value 通常是數字 or string or map or struct//只聲明不會給內存，要make才初始化才能用(跟切片一樣)m1[1] = 100m1[2] = 200m1[3] = 300m1[1] = 1000//key不能重複，後賦予的頂掉前面fmt.Println(m1)var m2 = make(map[string]string)m2[&amp;quot;AV&amp;quot;] = &amp;quot;sss&amp;quot;fmt.Println(m2)//推薦寫法m3 := make(map[string]string)m3[&amp;quot;一號&amp;quot;] = &amp;quot;台北&amp;quot;m3[&amp;quot;二奧&amp;quot;] = &amp;quot;桃園&amp;quot;fmt.Println(m3)m4 := map[int]int{1: 10, 2: 20, 3: 30}fmt.Println(m4)//學生姓名+性別m5 := make(map[string](map[string]string))m5[&amp;quot;stu01&amp;quot;] = make(map[string]string) //不能少m5[&amp;quot;stu01&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;tom&amp;quot;m5[&amp;quot;stu01&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;男&amp;quot;m5[&amp;quot;stu02&amp;quot;] = make(map[string]string) //不能少m5[&amp;quot;stu02&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;mary&amp;quot;m5[&amp;quot;stu02&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;女&amp;quot;fmt.</description>
    </item>
    
    <item>
      <title>new與make的區別</title>
      <link>https://yoziming.github.io/post/210810-agg-go-newmake/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-newmake/</guid>
      <description>func main() {num1 := 100fmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num1, num1, &amp;amp;num1)num2 := new(int) //*intfmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num2, num2, &amp;amp;num2)//new用來分配類型//make用來分配內存}</description>
    </item>
    
    <item>
      <title>Redis基本操作</title>
      <link>https://yoziming.github.io/post/210810-agg-go-redis/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-redis/</guid>
      <description>Redis基本操作 0.啟動cmd&amp;gt;redis-cli
1.數據結構類似JSON都是Key-Value
2.五大數據類型String、Hash、List、Set、Zset
2-1.String:最基本的字串，value最大值=512M
指令:set(如果存在就相當於修改)、get、del (很多指令可以用tab協助完成)
setex(幾秒後自毀)
2-2.Hash:類似於Map
指令:hset key field value、hget、hdel
一次設多項(空格隔開)hmset、hmget
hlen:統計有幾個元素
hexists:看field是否存在
2-3.List:是個有序的鏈表，元素的值可以重複，可以把東西加在頭或尾
指令:lpush 從左往管子裡塞東西，一直推擠過去
lrange 0 end (最左是0 1 2 3&amp;hellip;，也可以用負數 -1表示最後一個 -2表示倒數第2
比如說lrange 0 -1 =從左開始全顯示
rpush 從右邊加東西 (就順序上來說比較習慣)
lpop / rpop 從左或右取出數據(彈走了)
del key 刪掉就沒了
lindex 按照索引下標獲得元素(從左到右0開始)
llen 長度
2-4.Set:String類型的無序集合(元素的值不能重複)
舉例 存放email不該重複 (重複加了無效)
指令saad
smembers 印出所有值
sismember 判斷值是否成員
srem 刪除指定值</description>
    </item>
    
    <item>
      <title>Reflect反射</title>
      <link>https://yoziming.github.io/post/210810-agg-go-reflect/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-reflect/</guid>
      <description>reflect反射 func reflectTest01(b interface{}) {//通過反射獲取傳入的各種訊息//先拿reflect.TyperType := reflect.TypeOf(b)fmt.Println(&amp;quot;rType=&amp;quot;, rType)rVal := reflect.ValueOf(b)fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)// n1:=10+rVal //rVal他看起來是int但其實是type reflect.Valuen1 := 10 + rVal.Int() //用.Int()轉換後就可以了// n3 := rVal.Float()//像這樣也不行的，一定要確認類型fmt.Println(&amp;quot;n1=&amp;quot;, n1)// fmt.Println(&amp;quot;n3=&amp;quot;, n3)//把rVal轉回interface{}iV := rVal.Interface()n2 := iV.(int)fmt.Println(&amp;quot;n2=&amp;quot;, n2)}func reflectTest02(b interface{}) {//通過反射獲取傳入的各種訊息//先拿reflect.TyperType := reflect.TypeOf(b)fmt.Println(&amp;quot;rType=&amp;quot;, rType)rVal := reflect.ValueOf(b)fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)//把rVal轉回interface{}iV := rVal.Interface()//斷言回來n2, ok := iV.</description>
    </item>
    
    <item>
      <title>RPC</title>
      <link>https://yoziming.github.io/post/210927-rpc/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210927-rpc/</guid>
      <description>server / 用接口，讓服務端註冊RPC的時候，就能確保他合法type World struct{}func (w *World) HelloWorld(name string, resp *string) error {*resp = name + &amp;quot;你好&amp;quot;return nil// 如果這個return的返回值不為空，// 那無論傳出的參數是否有值，服務端都不會給東西// (就你給你error)}// 用接口，讓服務端註冊RPC的時候，就能確保他合法type MyInerface interface {HelloWorld(string *string) error}// 調用方法時，給i傳參，參數是實現HelloWorld方法的對象func RegsiterService(i MyInerface) {rpc.RegisterName(&amp;quot;hello&amp;quot;, i)}func main() {// 1.註冊RPC服務 綁定對象方法err := rpc.RegisterName(&amp;quot;hello&amp;quot;, new(World))if err != nil {fmt.Println(&amp;quot;註冊RPC服務失敗&amp;quot;, err)}// 2.開始監聽listener, err := net.</description>
    </item>
    
    <item>
      <title>Split切分字串</title>
      <link>https://yoziming.github.io/post/210810-agg-go-split/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-split/</guid>
      <description>Split切分字串 // abc,b=&amp;gt;[a c]func Split(str, sep string) []string {// str=&amp;quot;bsfcvjkhbafs&amp;quot; sep=&amp;quot;b&amp;quot;var ret = make([]string, 0, strings.Count(str, sep)+1)index := strings.Index(str, sep)for index &amp;gt;= 0 {ret = append(ret, str[:index])str = str[index+len(sep):]index = strings.Index(str, sep)}ret = append(ret, str)return ret}</description>
    </item>
    
    <item>
      <title>Test單元測試</title>
      <link>https://yoziming.github.io/post/210810-agg-go-test/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-test/</guid>
      <description>Test單元測試  單元測試目的是驗證程式碼(例如一個方法)本身的邏輯是否正確 單元測試應排除外部依賴（Database、File System IO） 單元測試應該是隨時隨地都要能正確執行 單元測試的標題需要具備好的可讀性、明確、標題與測試的內容精確吻合 例：「public void GetTest_帶入會員ID＿應回該ID搜尋到的會員資料DTO」，盡量符合：受測方法＿傳入參數意義＿期望得到的結果 一個測試只應該關注一件事情，如果受測目標有多種狀況，應該分成好幾個測試去涵蓋所有邏輯   3A原則
  Arrange = 準備受測物件、參數、預期結果 Act = 執行受測方法 Assert = 驗證執行結果與預測結果是否一致  cal.go func addUpper(n int) int {res := 0for i := 0; i &amp;lt;= n; i++ {res = +i}return res}func getSub(n1, n2 int) int {return n1 - n2}cal_test.go func TestAddUpper(t *testing.T) {//調用res := addUpper(10)if res !</description>
    </item>
    
    <item>
      <title>WaitGroup鎖</title>
      <link>https://yoziming.github.io/post/210810-agg-go-waitgroup/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-waitgroup/</guid>
      <description>WaitGroup鎖 讀寫鎖 var x = 0var wg sync.WaitGroupvar rwlock sync.RWMutexfunc write() {rwlock.Lock()x = x + 1time.Sleep(time.Millisecond * 10)rwlock.Unlock()wg.Done()}func read() {// lock.Lock()rwlock.RLock() //鎖讀time.Sleep(time.Millisecond)rwlock.RUnlock()// lock.Unlock()wg.Done()}func main() {start := time.Now()for i := 0; i &amp;lt; 10; i++ {wg.Add(1)go write()}for i := 0; i &amp;lt; 1000; i++ {wg.Add(1)go read()}wg.</description>
    </item>
    
    <item>
      <title>二維數組</title>
      <link>https://yoziming.github.io/post/210810-agg-go-array/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-array/</guid>
      <description>// 000000// 001000// 020300// 000000func main() {var arr [4][6]intarr[1][2] = 1arr[2][1] = 2arr[2][3] = 3//遍歷for i := 0; i &amp;lt; len(arr); i++ {for j := 0; j &amp;lt; len(arr[i]); j++ {fmt.Print(arr[i][j], &amp;quot; &amp;quot;)}fmt.Println()}//遍歷rangefor i, v := range arr {for j, v2 := range v {fmt.Printf(&amp;quot;arr[%v][%v]=%v \t&amp;quot;, i, j, v2)}fmt.</description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://yoziming.github.io/post/210810-agg-go-bubble-sort/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-bubble-sort/</guid>
      <description>冒泡排序 var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 6}func main() {s1 := arr1[:]bubbleSort(s1)fmt.Println(arr1)}func bubbleSort(x []int) {for j := 1; j &amp;lt; len(x); j++ {for i := 0; i &amp;lt; len(x)-1; i++ {if x[i] &amp;gt; x[i+1] {x[i], x[i+1] = x[i+1], x[i]}}}}</description>
    </item>
    
    <item>
      <title>函數封裝的金字塔</title>
      <link>https://yoziming.github.io/post/210810-agg-go-pyramid/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-pyramid/</guid>
      <description>package mainimport (&amp;quot;fmt&amp;quot;)var input intfunc jin(input int) {for i := 1; i &amp;lt;= input; i++ {for k := 1; k &amp;lt;= input-i; k++ {fmt.Print(&amp;quot; &amp;quot;)}for j := 1; j &amp;lt;= 2*i-1; j++ {if j == 1 || j == 2*i-1 || i == input {fmt.Print(&amp;quot;*&amp;quot;)} else {fmt.Print(&amp;quot; &amp;quot;)}}fmt.Println()}}func main() {fmt.</description>
    </item>
    
    <item>
      <title>函數綁定方法</title>
      <link>https://yoziming.github.io/post/210810-agg-go-method/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-method/</guid>
      <description>函數綁定方法  方法:結構體的行為，自訂義的結構都可以有方法，方法是作用在指定類型上(綁定的)
方法就是跟一種類型綁定的函數，因為綁定數據類型了就可以偷雞，具體表現在省指針
定義方法時候寫的是func(a ABC) //後面怎樣調用都是值拷貝
定義方法時候寫的是func(a *ABC)//後面怎樣調用都是真實地址
要調用方法，只能透過那種類型的的數據變量 例如a1.ABC
 package mainimport (&amp;quot;fmt&amp;quot;)type Person struct {Name string}//給Person類型綁定一個方法func (p Person) test() {p.Name = &amp;quot;jack&amp;quot;fmt.Println(&amp;quot;test()=&amp;quot;, p.Name)}//給Person類型添加一個speak方法，輸出xxx是好人func (p Person) speak() {fmt.Println(p.Name, &amp;quot;是一個好人&amp;quot;)}//添加一個計算方法算+1...+100func (p Person) count() {res := 0for i := 1; i &amp;lt;= 100; i++ {res += i}fmt.Println(p.Name, &amp;quot;計算的結果是&amp;quot;, res)}//添加一個計算方法算+1.</description>
    </item>
    
    <item>
      <title>切片</title>
      <link>https://yoziming.github.io/post/210810-agg-go-slice/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-slice/</guid>
      <description>func main() {//切片的類型是引用(傳遞的時候也是引用地址)//切片長度可變(不像數組)var arr1 = [5]int{1, 2, 3, 4, 5}s1 := arr1[1:3] //表示切arr的[1 2] 左開右閉(含左不含右)//var slice=arr[0:end]簡寫[:end]//[start:len(arr)]=[start:]//[0:len(arr)]=[:]fmt.Println(&amp;quot;s1內容是&amp;quot;, s1)fmt.Println(&amp;quot;s1長度是&amp;quot;, len(s1))fmt.Println(&amp;quot;s1容量是&amp;quot;, cap(s1))fmt.Printf(&amp;quot;s1第一個地址是%p\n&amp;quot;, &amp;amp;s1[0])fmt.Printf(&amp;quot;arr1[1]地址是%p\n&amp;quot;, &amp;amp;arr1[1])s1[0] = 33fmt.Println(&amp;quot;arr1內容是&amp;quot;, arr1)//var 切片名[]type=make([]type,len,cap)var s2 []float64 = make([]float64, 5, 10)fmt.Println(s2)//var 變量=make(類型)var s22 = make([]float64, 5, 10)fmt.Println(s22)var s3 []int = []int{1, 2, 3, 4, 5}fmt.Println(s3)//用append動態追加s3 = append(s3, 6, 7, 8, 9)fmt.</description>
    </item>
    
    <item>
      <title>匿名函數與閉包</title>
      <link>https://yoziming.github.io/post/210810-agg-go-closure/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-closure/</guid>
      <description>匿名函數 func main() {res := func(n1, n2 int) int {return n1 + n2}(10, 20)fmt.Println(res)a := func(n1, n2 int) int {return n1 - n2}res = a(10, 5)fmt.Println(res)}閉包 //累加器func Add() func(int) int { //Add是一個函數，返回的數據類型是func(int) intvar n int = 10 //返回的是一個匿名函數，那這個函數用到函數外的n，因此形成一個整體稱為閉包return func(x int) int {n = n + xreturn n//閉包是類，函數是操作，n是字段，函數+使用n構成閉包//n只初始化一次}}func main() {a := Add()fmt.</description>
    </item>
    
    <item>
      <title>命令行參數Args&amp;Flag</title>
      <link>https://yoziming.github.io/post/210810-agg-go-argsflag/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-argsflag/</guid>
      <description>命令行參數Args&amp;amp;Flag func main() {fmt.Println(&amp;quot;命令行參數有&amp;quot;, len(os.Args))//遍歷os.Args切片 得到所有輸入的參數值for i, v := range os.Args {fmt.Printf(&amp;quot;args[%v]=%v\n&amp;quot;, i, v)}fmt.Println(&amp;quot;=====================&amp;quot;)//flag方法 先定義幾個變量用於接收參數值var user stringvar pwd stringvar host stringvar port intflag.StringVar(&amp;amp;user, &amp;quot;u&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;帳號 預設為空&amp;quot;)flag.StringVar(&amp;amp;pwd, &amp;quot;pwd&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;密碼 預設為空&amp;quot;)flag.StringVar(&amp;amp;host, &amp;quot;h&amp;quot;, &amp;quot;localhost&amp;quot;, &amp;quot;主機 預設為localhost&amp;quot;)flag.IntVar(&amp;amp;port, &amp;quot;port&amp;quot;, 3306, &amp;quot;端口 預設為3306&amp;quot;)//前面有亂打的字就不行 比如...exe 12354 -u tom會調用預設flag.Parse() //這個一定要調用//輸出結果fmt.Printf(&amp;quot;user=%v pwd=%v host=%v port=%v&amp;quot;,user, pwd, host, port)}</description>
    </item>
    
    <item>
      <title>字串轉換常用函數</title>
      <link>https://yoziming.github.io/post/210810-agg-go-string-conver/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-string-conver/</guid>
      <description>字串轉換常用函數 var str string = &amp;quot;abc123中文&amp;quot;func main() {fmt.Println(&amp;quot;長度=&amp;quot;, len(str))r := []rune(str)for i := 0; i &amp;lt; len(r); i++ {fmt.Printf(&amp;quot;遍歷=%q\n&amp;quot;, r[i])}//轉成整數 Atoin, err := strconv.Atoi(&amp;quot;5421&amp;quot;)if err != nil {fmt.Println(&amp;quot;錯誤,err&amp;quot;)} else {fmt.Println(&amp;quot;轉換成&amp;quot;, n)//整數轉字串str2 := strconv.Itoa(654231)fmt.Printf(&amp;quot;類型是%T\n&amp;quot;, str2)//轉bytevar bytes = []byte(&amp;quot;hello&amp;quot;)fmt.Printf(&amp;quot;bytes=%v \n&amp;quot;, bytes)//byte轉回字串str3 := string([]byte{97, 98, 99})fmt.Printf(&amp;quot;str3=%v \n&amp;quot;, str3)//10進制轉2,8,16返回字串str4 := strconv.</description>
    </item>
    
    <item>
      <title>實作練習-ini解析器</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</guid>
      <description>用來解析.ini文檔格式是否有問題
 package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;io/ioutil&amp;quot;&amp;quot;reflect&amp;quot;&amp;quot;strings&amp;quot;)type RedisConfig struct {Host string `ini:&amp;quot;host&amp;quot;`Port int `ini:&amp;quot;port&amp;quot;`Password string `ini:&amp;quot;password&amp;quot;`Database int `ini:&amp;quot;database&amp;quot;`}type MysqlConfig struct {Address string `ini:&amp;quot;address&amp;quot;`Port int `ini:&amp;quot;port&amp;quot;`Password string `ini:&amp;quot;password&amp;quot;`Username string `ini:&amp;quot;username&amp;quot;`}type Config struct {MysqlConfig `ini:&amp;quot;mysql&amp;quot;`RedisConfig `ini:&amp;quot;redis&amp;quot;`}func loadIni(fileName string, data interface{}) (err error) {// 0. 參數校驗// 0.1 傳來的data必須是結構體類型指針t := reflect.</description>
    </item>
    
    <item>
      <title>實作練習-txt文本批次取代器</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/</guid>
      <description>實作練習-txt文本批次取代器  自己寫用來一次取代多個名詞，去除多餘空格或符號等等
 package mainimport (&amp;quot;bufio&amp;quot;&amp;quot;fmt&amp;quot;&amp;quot;io&amp;quot;&amp;quot;os&amp;quot;&amp;quot;strings&amp;quot;)var data []string = make([]string, 128)func main() {readByBufio()for _, v := range data {if v == &amp;quot;&amp;quot; {break}fmt.Print(v)}}func readByBufio() {file, err := os.Open(&amp;quot;C:/test.txt&amp;quot;)if err != nil {fmt.Printf(&amp;quot;os.Open err %s\n&amp;quot;, err)return}defer file.Close()reader := bufio.NewReader(file)for i := 0; ; i++ {line, err := reader.</description>
    </item>
    
    <item>
      <title>實作練習-多人聊天室</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>實作練習-多人聊天室  本來很傻的檔案代碼一個一個貼，後來學了github的專案管理就放到那了
 https://github.com/yoziming/go-practice-chatroom</description>
    </item>
    
    <item>
      <title>實作練習-客戶名單管理系統</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/</guid>
      <description>實作練習-客戶名單管理系統 model type Customer struct {Id intName stringGender stringAge intPhone stringEmail string}//使用工廠模式返回一個實例func NewCustomer(id int, name string, gender string,age int, phone string, email string) Customer {return Customer{Id: id,Name: name,Gender: gender,Age: age,Phone: phone,Email: email,}}//返回用戶訊息func (c Customer) GetInfo() string {info := fmt.Sprintf(&amp;quot;%v	%v	%v	%v	%v	%v&amp;quot;,c.Id, c.Name, c.Gender, c.Age, c.</description>
    </item>
    
    <item>
      <title>實作練習-家庭收支小app</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/</guid>
      <description>實作練習-家庭收支小app type MyMoney struct {key string //鍵入值note string //收支說明balance float64 //餘額money float64 //收支flag bool //判斷是否有明細details string //詳細loop bool //循環}//綁定方法func (mm *MyMoney) MainMenu() {for {if !mm.loop {break}fmt.Println(&amp;quot;\n-----------------家庭收支记账软件-----------------&amp;quot;)fmt.Println(&amp;quot; 1 收支明细&amp;quot;)fmt.Println(&amp;quot; 2 登记收入&amp;quot;)fmt.Println(&amp;quot; 3 登记支出&amp;quot;)fmt.Println(&amp;quot; 4 退出软件&amp;quot;)fmt.Print(&amp;quot;請選擇(1-4)...&amp;quot;)fmt.Scanln(&amp;amp;mm.key)switch mm.key {case &amp;quot;1&amp;quot;:mm.showDetails()case &amp;quot;2&amp;quot;:mm.income()case &amp;quot;3&amp;quot;:mm.outcome()case &amp;quot;4&amp;quot;:mm.exit()default:fmt.</description>
    </item>
    
    <item>
      <title>實作練習-點對點聊天</title>
      <link>https://yoziming.github.io/post/210820-agg-go-proj-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/</guid>
      <description>實作練習-點對點聊天 server.go func main() {fmt.Println(&amp;quot;服務器開始監聽&amp;quot;)listen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;0.0.0.0:8888&amp;quot;) //0.0.0.0 寫4位ip v4 v6都能用if err != nil {fmt.Println(&amp;quot;監聽失敗&amp;quot;, err)return}defer listen.Close() //主程式退出後就關閉監聽// fmt.Printf(&amp;quot;listen succes=%v\n&amp;quot;, listen)for {//開啟監聽端口8888time.Sleep(time.Microsecond)fmt.Println(&amp;quot;等待連接中...&amp;quot;)conn, err := listen.Accept()if err != nil {fmt.Println(&amp;quot;Accept()err=&amp;quot;, err)} else {fmt.Printf(&amp;quot;conn suc con=%v 客戶端ip=%v\n&amp;quot;, conn, conn.RemoteAddr().String())}//準備啟動一個協程go process(conn)}}func process(conn net.Conn) {//循環接收客戶端送來的數據defer conn.Close()fmt.Printf(&amp;quot;服務器等待%s客戶端輸入...\n&amp;quot;, conn.</description>
    </item>
    
    <item>
      <title>對有序數列進行二分查找</title>
      <link>https://yoziming.github.io/post/210810-agg-go-binary-search/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-binary-search/</guid>
      <description>//對有序數列進行二分查找var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 0}func bubble(x []int) {for j := 1; j &amp;lt; len(x); j++ {for i := 0; i &amp;lt; len(x)-1; i++ {if x[i] &amp;gt; x[i+1] {x[i], x[i+1] = x[i+1], x[i]}}}}func bi(x int, s []int, left int, right int) {middle := (right + left) / 2if left &amp;gt; right {fmt.</description>
    </item>
    
    <item>
      <title>工廠模式</title>
      <link>https://yoziming.github.io/post/210810-agg-go-factory/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-factory/</guid>
      <description>//工廠模式// 假如有些要公用的東西又不想用大寫讓人隨意改了 例如結構體、結構體內的字段等等// 我就在那個包裏建一個方法，這個方法本身大寫，在方法中原地調用那些本來是大寫的玩意// 返回一個相同的值過來，相當於那在那個包里把該封裝的都封好，拿出來的就是產品import (&amp;quot;fmt&amp;quot;)type Student struct {Name stringAge intScore float64}func (s *Student) Say() string {infoStr := fmt.Sprintf(&amp;quot;信息 name=[%v] age=[%v] score=[%v]&amp;quot;,s.Name, s.Age, s.Score)return infoStr}func main() {var s1 = Student{Name: &amp;quot;tom&amp;quot;,Score: 98,Age: 18, //不依賴順序}res := s1.Say()fmt.Println(res)//其他創建結構變量同時指定值的方法:stu2 := Student{&amp;quot;Jack&amp;quot;, 20, 100} //項目順序都要有對應fmt.Println(stu2)//返回結構的指針var stu3 = &amp;amp;Student{&amp;quot;Mary&amp;quot;, 28, 5}fmt.</description>
    </item>
    
    <item>
      <title>拷貝檔案</title>
      <link>https://yoziming.github.io/post/210810-agg-go-io-copy/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-io-copy/</guid>
      <description>拷貝一個檔案 //定義一個函數接收2個路徑func CopyFile(dstFileName, srcFileName string) (written int64, err error) {srcFile, err := os.Open(srcFileName)if err != nil {fmt.Println(err)}defer srcFile.Close()//通過srcFile獲取到readerreader := bufio.NewReader(srcFile)//打開dstFileNamedstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666)if err != nil {fmt.Println(err)}//通過dstFile獲取到writerwriter := bufio.NewWriter(dstFile)defer dstFile.Close()return io.Copy(writer, reader)}func main() {src := &amp;quot;C:/01.mkv&amp;quot; //原始檔dst := &amp;quot;C:/food2.mkv&amp;quot;_, err := CopyFile(dst, src)if err == nil {fmt.</description>
    </item>
    
    <item>
      <title>接口interface</title>
      <link>https://yoziming.github.io/post/210810-agg-go-interface/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-interface/</guid>
      <description>接口interface  例如定義 只要滿足&amp;quot;會跑&amp;quot;且&amp;quot;會叫&amp;quot;的就是&amp;quot;動物&amp;quot;，
那不管你是啥玩意只要實現會跑跟會叫，我就當你是動物，就能用動物的接口去調用
 //接口內不能有變量，方法也不能實現type Usb interface {//聲明兩個沒實現的方法Start()Stop()}type Usb2 interface {//接口是不需要顯示聲明，只要能實現就都能調用Start()Stop()//假如我多聲明一個沒實現的方法在接口內就不能調用Test() //有方法沒實現，導致Usb2這個接口不能用}type Phone struct {}//讓Phone實現USB接口的方法func (p Phone) Start() {fmt.Println(&amp;quot;手機啟動&amp;quot;)}func (p Phone) Stop() {fmt.Println(&amp;quot;手機停止&amp;quot;)}type Camera struct {}func (c Camera) Start() {fmt.Println(&amp;quot;相機啟動~~&amp;quot;)}func (c Camera) Stop() {fmt.Println(&amp;quot;相機停止&amp;quot;)}//電腦type Computer struct {}func (c Computer) Working(usb Usb) { //接受一個Usb的接口類型//通過usb變量來調用Start等方法fmt.</description>
    </item>
    
    <item>
      <title>數組</title>
      <link>https://yoziming.github.io/post/210810-agg-go-array1/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-array1/</guid>
      <description>數組 func main() {var n1 [3]int = [3]int{1, 2, 3}var n2 = [3]int{4, 5, 6}//長度聲明後就不能變化var n3 = [...]int{7, 8, 9}//數組長度是類型的一部分 [3]int != [4]intvar n4 = [...]string{0: &amp;quot;李四&amp;quot;, 1: &amp;quot;張三&amp;quot;, 5: &amp;quot;王武&amp;quot;}n5 := []int{5, 5, 5, 5, 5}//[]int 這樣定義其實是切片fmt.Println(n1)fmt.Println(n2)fmt.Println(n3)fmt.Println(n4)fmt.Println(n5)n9 := fmt.Sprintf(&amp;quot;%.2f&amp;quot;, 9.888888)fmt.Println(n9)var score [5]float64for i := 0; i &amp;lt; len(score); i++ {fmt.Println(&amp;quot;輸入成績&amp;quot;)fmt.Scanln(&amp;amp;score[i])}for i := 0; i &amp;lt; len(score); i++ {fmt.</description>
    </item>
    
    <item>
      <title>文字檔案讀取寫入</title>
      <link>https://yoziming.github.io/post/210810-agg-go-io-reader/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-io-reader/</guid>
      <description>讀取 func main() {//打開一個文件file, err := os.Open(&amp;quot;c:/test.txt&amp;quot;)//有人叫file對象/指針/文件句柄if err != nil {fmt.Println(&amp;quot;open file err=&amp;quot;, err)}//看看文件是啥fmt.Printf(&amp;quot;file=%v\n&amp;quot;, file)//退出函數就關閉文件defer file.Close()//創建一個帶緩衝的reader，預設大小是4096reader := bufio.NewReader(file)for {str, err := reader.ReadString(&#39;\n&#39;) //讀到換行就結束fmt.Print(str)if err == io.EOF { //表示文件末尾break}}fmt.Println(&amp;quot;\n讀取結束&amp;quot;)//用ioutil.ReadFile一次讀完//這個包已經封裝了open跟close了，只適用在檔案大小不大的情境file2 := &amp;quot;c:/test.txt&amp;quot;str2, err2 := ioutil.ReadFile(file2)if err2 != nil {fmt.Println(err)}fmt.Printf(&amp;quot;%s&amp;quot;, str2) //原本輸出是[]byte,用%s轉//創建一個新檔案，寫入5句話filePath := &amp;quot;c:/abc.</description>
    </item>
    
    <item>
      <title>文檔字符統計</title>
      <link>https://yoziming.github.io/post/210810-agg-go-txt/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-txt/</guid>
      <description>文檔字符統計 //保存結果用type CharCount struct {ChCount int //英文字數NumCount int //SpaceCount intOtherCount int}func main() {//思路 打開一個文件 創一個reader每讀取一行就去統計，將結果保存到一個結構體fileName := &amp;quot;c:/abc.txt&amp;quot;file, err := os.Open(fileName)if err != nil {fmt.Println(err)return}defer file.Close()//來個實例var count CharCountreader := bufio.NewReader(file)//開始讀取for {str, err := reader.ReadString(&#39;\n&#39;)//這存在BUG 當行不換行做結尾就統計不到if err == io.EOF {break}for _, v := range str {switch {case v &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;z&#39;:fallthroughcase v &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;Z&#39;:count.</description>
    </item>
    
    <item>
      <title>日期時間</title>
      <link>https://yoziming.github.io/post/210810-agg-go-datetime/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-datetime/</guid>
      <description>日期時間 func main() {//1.獲取當前本地時間now := time.Now()fmt.Printf(&amp;quot;now=%v,type=%T&amp;quot;, now, now) //返回的類型是struct//2.通過now獲取各種詳細fmt.Printf(&amp;quot;年=%v,type=%T\n&amp;quot;, now.Year(), now.Year())fmt.Printf(&amp;quot;月=%v,type=%T\n&amp;quot;, now.Month(), now.Month())fmt.Printf(&amp;quot;月=%v,type=%T\n&amp;quot;, int(now.Month()), int(now.Month()))fmt.Printf(&amp;quot;日=%v,type=%T\n&amp;quot;, now.Day(), now.Day())fmt.Printf(&amp;quot;時=%v,type=%T\n&amp;quot;, now.Hour(), now.Hour())fmt.Printf(&amp;quot;分=%v,type=%T\n&amp;quot;, now.Minute(), now.Minute())fmt.Printf(&amp;quot;秒=%v,type=%T\n&amp;quot;, now.Second(), now.Second())fmt.Printf(&amp;quot;星期=%v,type=%T\n&amp;quot;, now.Weekday(), now.Weekday())fmt.Printf(&amp;quot;星期=%v\n&amp;quot;, int(now.Weekday()))//3.格式化日期時間dateStr := fmt.Sprintf(&amp;quot;年月日時分=%d-%d-%d %d:%d\n&amp;quot;, now.Year(), now.Month(),now.Day(), now.Minute(), now.Second())fmt.Println(dateStr)//4.蛋疼的指定格式fmt.Println(now.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;))fmt.Println(now.Format(&amp;quot;2006-01-02&amp;quot;))fmt.Println(now.Format(&amp;quot;06&amp;quot;))fmt.Println(now.Format(&amp;quot;01&amp;quot;))fmt.Println(now.Format(&amp;quot;03&amp;quot;))fmt.Println(now.Format(&amp;quot;01-02-06 03 04 05&amp;quot;))//123456=月日時分秒年//5.時間常量&amp;amp;休眠//每隔固定時間打印數字，打到100退出for i := 0; i &amp;lt;= 100; i++ {fmt.</description>
    </item>
    
    <item>
      <title>結構體</title>
      <link>https://yoziming.github.io/post/210810-agg-go-struct/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-struct/</guid>
      <description>結構體 type Cat struct {Name stringAge intColor string// S1 []int //可以是切片 但是預設值為nil(沒分配空間，一樣要先make後才能用)}//結構體是一個值類型，預設是值拷貝，比如cat1跟cat2是獨立存在兩個空間func main() {//創建Cat的變量var cat1 Catcat1.Name = &amp;quot;小花&amp;quot;cat1.Age = 18cat1.Color = &amp;quot;花&amp;quot;fmt.Println(&amp;quot;cat1=&amp;quot;, cat1)// cat1.S1 = make([]int, 10)// cat1.S1[0] = 100// fmt.Println(&amp;quot;cat1=&amp;quot;, cat1)//推薦方式cat2 := Cat{&amp;quot;小黑&amp;quot;, 5, &amp;quot;black&amp;quot;}fmt.Println(cat2)//方法3//var c *C=new(C)var cat3 *Cat = new(Cat)//因為cat3是一個指針(*cat3).Name = &amp;quot;小白&amp;quot;//語法糖 cat3.Age也可以 ，不建議cat3.</description>
    </item>
    
    <item>
      <title>繼承</title>
      <link>https://yoziming.github.io/post/210810-agg-go-inherit/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-inherit/</guid>
      <description>繼承 type Student struct {Name stringAge intScore int//共有的字段}type Pupil struct {Student //套入Covid19 bool}type College struct {Student //套入指針效率更好SexExp bool}func (stu *Student) ShowInfo() {fmt.Printf(&amp;quot;姓名=%v 年齡=%v 成績=%v\n&amp;quot;, stu.Name, stu.Age, stu.Score)}func (stu *Student) SetScore(s int) {stu.Score = s}func (p *Pupil) Test() {fmt.Println(&amp;quot;小學生考試&amp;quot;)}func main() {pupilA := &amp;amp;Pupil{}pupilA.Student.Name = &amp;quot;tome&amp;quot;pupilA.Student.Age = 8pupilA.</description>
    </item>
    
    <item>
      <title>錯誤處理</title>
      <link>https://yoziming.github.io/post/210810-agg-go-err/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-err/</guid>
      <description>錯誤處理 func test() { //捕捉異常 	defer func() { //內置函數recover就是找是否異常 	if err := recover(); err != nil { //err不為空=有錯 	fmt.Println(&amp;#34;錯誤&amp;#34;, err) } }() n1 := 10 n2 := 0 res := n1 / n2 fmt.Println(res) } //讀取文件名稱，錯誤就報錯 func readConf(name string) (err error) { if name == &amp;#34;config.ini&amp;#34; { return nil } else { //返回自訂錯誤 	return errors.New(&amp;#34;文件錯誤&amp;#34;) } } func test02() { err := readConf(&amp;#34;config.in564&amp;#34;) if err != nil { panic(err) } fmt.</description>
    </item>
    
    <item>
      <title>順序查找</title>
      <link>https://yoziming.github.io/post/210810-agg-go-sequential-search/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/210810-agg-go-sequential-search/</guid>
      <description>順序查找 func main() {names := [4]string{&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;}var input = &amp;quot;&amp;quot;fmt.Println(&amp;quot;輸入...&amp;quot;)fmt.Scanln(&amp;amp;input)//順序查找// for i := 0; i &amp;lt; len(names); i++ {// if input == names[i] {// fmt.Printf(&amp;quot;找到%v,下標=%v \n&amp;quot;, input, i)// break// } else if i == len(names)-1 {// fmt.Println(&amp;quot;比對失敗...&amp;quot;)// }//順序查找2index := -1for i := 0; i &amp;lt; len(names); i++ {if input == names[i] {index = ibreak}}if index !</description>
    </item>
    
  </channel>
</rss>
