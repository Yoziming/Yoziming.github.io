<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 柚子茶室</title>
    <link>https://yoziming.github.io/tags/java/</link>
    <description>Recent content in Java on 柚子茶室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Yoziming</copyright>
    <lastBuildDate>Thu, 15 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yoziming.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>用Java code生成Excel檔案</title>
      <link>https://yoziming.github.io/post/221215-java-code-build-excel/</link>
      <pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/221215-java-code-build-excel/</guid>
      <description>知識點 用Java code 生成Excel檔案 簡單快入的更改字形、排版 Excel欄位有下拉選單(資料驗證) 應用情景 有一個報修功能讓使用者可以上傳Excel的清單，系統可以讀取然後產生批量的報修單。於是有一個範例檔案 然而範例檔案還要達成傻瓜式操作，防止使用者填入錯誤的代碼，需要做成下拉清單，像這樣: 引用包 Hutool、poi Code 下拉選單的核心就在writer.addSelect方法，只要把Enum轉為String[]就可以了 @GetMapping(&amp;#34;/getExample&amp;#34;) public void getExample(HttpServletResponse response) throws IOException { // 造下拉選單的array Map&amp;lt;String, String&amp;gt; stateMap = new HashMap&amp;lt;&amp;gt;(); List&amp;lt;String&amp;gt; stateList = new ArrayList&amp;lt;&amp;gt;(); stateMap.put(LightCtrlDetailState.PM_ACCEPT.getCode(), LightCtrlDetailState.PM_ACCEPT.getDesc()); stateMap.put(LightCtrlDetailState.PM_DISCARD.getCode(), LightCtrlDetailState.PM_DISCARD.getDesc()); stateMap.forEach((k, v) -&amp;gt; stateList.add(&amp;#34;#&amp;#34; + k + &amp;#34;(&amp;#34; + v + &amp;#34;)&amp;#34;)); String[] stateArray = stateList.toArray(new String[0]); List&amp;lt;String&amp;gt; faultList = new ArrayList&amp;lt;&amp;gt;(); Map&amp;lt;String, String&amp;gt; faultMap = LightCtrlFault.toMap(); faultMap.forEach((k, v) -&amp;gt; faultList.add(&amp;#34;#&amp;#34; + k + &amp;#34;(&amp;#34; + v + &amp;#34;)&amp;#34;)); String[] faultArray = faultList.</description>
    </item>
    
    <item>
      <title>用Javafaker產生假資料</title>
      <link>https://yoziming.github.io/post/220228-postgres-javafaker/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220228-postgres-javafaker/</guid>
      <description>填充模板資料 工作上遇到的情境，業務要推銷軟體產品，需要做一個Demo展示，有個功能是可以顯示精美的圖形報表，那總不可能自己一筆一筆輸入資料
使用的技術有PostgreSQL、JPA、Javafaker、Gradle 其實單純是我目前工作上即將用到的技術 PostgreSQL 資料庫，開源免費，社群愛用
直接docker拉一個
docker pull postgres:10-alpine docker run -p 5432:5432 --name postgres --restart=always -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -d postgres:10-alpine 隨便建一個表 CREATE TABLE public.staff ( id int8 NOT NULL, full_name text NOT NULL, age int4 NOT NULL, address bpchar(150) NULL, salary numeric NULL, CONSTRAINT company_pkey PRIMARY KEY (id) ); Eclipse + Gradle + Lombok 首先確定Eclipse有裝好Lombok，沒有的話去官網下載 https://projectlombok.org/download 裝好會是這樣的 然後進到gradle專案的build.gradle dependencies { compileOnly &amp;#39;org.projectlombok:lombok:1.18.22&amp;#39; annotationProcessor &amp;#39;org.projectlombok:lombok:1.18.22&amp;#39; } Javafaker https://github.com/DiUS/java-faker 非常神奇的工具，能夠自動產生多種資料(姓名、電話、地址&amp;hellip;甚至寶可夢)，且支援多國在地化，包含台灣中文 參考程式碼 build.</description>
    </item>
    
    <item>
      <title>Java面試，機考題整理</title>
      <link>https://yoziming.github.io/post/220217-java-interview-02/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220217-java-interview-02/</guid>
      <description>其實就是leetcode easy題，把常見的盡量做一做吧
反轉字串 /** * 輸入 &amp;#39;abcde&amp;#39; 輸出 &amp;#39;edcba&amp;#39; */ private static String reverseStr(String str) { String result = &amp;#34;&amp;#34;; for (int i = str.length(); i &amp;gt;= 1; i--) { result = result + str.charAt(i - 1); } return result; } 是否迴文 private boolean isPal(String str) { String newStr = new StringBuilder(str).reverse().toString(); return str.equals(newStr); } FizzBuzz /** * FizzBuzz * 給一個整數 n 請列印出 1~n 的每一個整數， 但是 * 當整數可以被 3 整除的時候印出 Fizz 來代替原本要印出的數， * 當整數可以被 5 整除的時候印出 Buzz 來代替原本要印出的數， * 當整數可以被 3 跟 5 整除的時候印出 FizzBuzz 來代替原本原本要印出的數。 */ private static void printFizzBuzz(int n) { for (int i = 1; i &amp;lt;= n; i++) { if (i % 3 == 0 &amp;amp;&amp;amp; i % 5 == 0) { System.</description>
    </item>
    
    <item>
      <title>Java初階面試題整理-01</title>
      <link>https://yoziming.github.io/post/220216-java-interview-01/</link>
      <pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220216-java-interview-01/</guid>
      <description>Java特性 純物件導向(Object-oriented programming，OOP)，任何行為是來自某個資料(物件)，目的是方便維護跟擴展性 跨平台(只要能跑JVM)、有GC Java中的基本資料類型 基本類型 位元 位元組 預設值 int 32 4 0 short 16 2 0 long 64 8 0L byte 8 1 0 char 16 2 &amp;lsquo;u0000&amp;rsquo; float 32 4 0f double 64 8 0d boolean 1 false 這八種基本類型都有對應的包裝類分別為:Byte、Short、Integer、Long、Float、Double、Character、Boolean 包裝類型不賦值就是 Null ，而基本類型有預設值且不是 Null，所以通常在專案中設計entity都用包裝類，這樣從資料庫抓過來如果是空的不會自動變成0之類的引起麻煩 基本資料類型是存放在JVM棧中的區域變數表中(那些常用的早就準備好了)，而包裝類型屬於物件類型，我們知道物件實例都存在於堆中。相比於物件類型， 基本資料類型佔用的空間非常小 包裝類型的常量池技術？ Java 基本類型的包裝類的大部分都實現了常量池技術 Byte,Short,Integer,Long 這 4 種包裝類默認創建了數值 [-128，127] 的相應類型的緩存資料，Character 創建了數值在 [0,127] 範圍的緩存資料 就是因為有裝箱與常量池，所有整型包裝類物件之間值的比較，全部使用 equals 方法比較才不會踩坑 基本雜問 Java中只有值傳遞 Java是Pass by Value傳值，將參數值複製後傳遞 如果參數是基本類型的話，很簡單，傳遞的就是基本類型的字面量值的拷貝，會創建副本 如果參數是參考類型，傳遞的就是實參所引用的物件在堆中位址值的拷貝，同樣也會創建副本 throw與throws的區別? throws通常被應用在聲明方法時，表示我這個方法會拋啥異常，誰要調用方法時必須要拋出異常或者使用try-catch語句處理異常 throw是在執行語句中，真的在這拋出一個異常 結束循環的區別 continue: 指跳出當前的這一次迴圈，繼續下一次迴圈 break: 指跳出整個循環體，繼續執行迴圈下的語句 return: 用於跳出所在方法，結束該方法的運行 靜態方法為什麼不能調用非靜態成員?</description>
    </item>
    
    <item>
      <title>商城初級高級篇總和與展示</title>
      <link>https://yoziming.github.io/post/220214-gulimall-26/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220214-gulimall-26/</guid>
      <description>柚子商城 基於SpringBoot、SpringCloud的大型分散式微服務架構B2C商城項目 項目由業務集群 + 後台管理系統構成，主要練習微服務架構、服務註冊與發現、遠程調用、網關、Restful接口、數據校驗、高併發處理、MQ訊息中心、限流降級、鏈路追蹤、性能監控、壓力測試等等 專案背景(Background) 本項目參考自 尚硅谷java微服務課程: https://www.bilibili.com/video/BV1np4y1C7Yf?p=342 個人學習過程的詳細筆記(共26篇): https://yoziming.github.io/post/220118-gulimall-01/ 項目架構圖 解析 使用者通過任意客户端（app/Web）向伺服器發送請求，請求首先來到Nginx集群，Nginx將請求轉交給Api網關（SpringCloud Gateway） Api網關: 根據當前請求，動態路由到指定的服務 如果服務出現問題，也可以在網關通過Sentinel做熔斷降級與限流，例如超過負荷時暫時顯示排隊頁面，只放伺服器能乘載的輛 Nacos註冊中心：微服務的註冊與發現 Feign：微服務之間的遠程調用 OAuth2.0認證中心：登入與請求權限的管理 快取：使用Redis結合spring cache與redsson分布式鎖 持久化：使用MySQL 消息隊列：使用Rabbit MQ實現微服務之間的非同步解耦，包括完成分佈式事務的最終一致性 全文檢索：使用Elastic Search實現 圖片存儲：使用MinIO存儲服務 Sleuth + Zipkin：服務的可視化追蹤 其他運維部分暫時沒完成 服務模組 檔案結構 mall-parent ├── auth-server -- 登入認證中心 ├── cart -- 購物車服務 ├── common -- 工具類及通用程式碼 ├── coupon -- 優惠服務 ├── gateway -- 網關 ├── member -- 會員服務 ├── order -- 訂單服務 ├── preset -- 啟動需要的前置工作(docker、sql語句等等) ├── product -- 商品服務 ├── search -- 商品搜尋服務 ├── seckill -- 秒殺優惠服務(高併發所以獨立出來) ├── third-party -- 第三方服務 ├── ware -- 倉儲服務 ├── renren-fast -- 後台管理系統 ├── renren-generator -- 人人開源項目的代碼生成器 renren-fast-vue -- 後台管理系統 技術選型 後端技術 技術 説明 官網 SpringBoot 容器+MVC框架 https://spring.</description>
    </item>
    
    <item>
      <title>微服務商城之高可用集群篇</title>
      <link>https://yoziming.github.io/post/220213-gulimall-25/</link>
      <pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220213-gulimall-25/</guid>
      <description>高可用集群篇 微服務做到現在，終於要開始部署了，首先要認識Kubernetes(K8S) 之前也有稍微了解過K8S，見筆記 https://yoziming.github.io/post/211006-k8s/ 簡單來說就是用來管理doker的總控 Master API Server: API介面 etcd: K-V形式的消息隊列 Scheduler: 監視Pod、調度叢集 kube-controller-manager: 操作進程的管理員 節點控制器（Node Controller）: 負責在節點出現故障時進行通知和回應 任務控制器（Job controller）: 監測代表一次性任務的 Job 物件，然後創建 Pods 來運行這些任務直至完成 端點控制器（Endpoints Controller）: 填充端點(Endpoints)對象(即加入 Service 與 Pod) 服務帳戶和權杖控制器（Service Account &amp;amp; Token Controllers）: 為新的命名空間創建默認帳戶和 API 訪問權杖 Noede Container Runtime: 正常就是Docker，負責運行容器 kubelet: 工頭，每個節點的負責人，管理Pod kube-proxy: 節點的網路接口，負責通訊 Fluentd: 日誌 Pod K8s管理的最小單元 裡面可以有多個容器，共用一個網路位置 其他名詞 Controllers: Pod的高層抽象，用來實際執行部署 Service: 也是抽象，Pod組成的一個服務 Namespace: 邏輯隔離資源 暫時停下 要運行K8S對資源的要求(主要是ram)太狠了，我的小破電腦已經扛不住了 課程只好暫時先停在這，整理一下手邊的資源，先去準備工作的事 </description>
    </item>
    
    <item>
      <title>用Heroku部署Tomcat網站</title>
      <link>https://yoziming.github.io/post/220211-javaweb-heroku/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220211-javaweb-heroku/</guid>
      <description>Heroku部署JavaWeb項目 我自己的JavaWeb是運行在Tomcat的，所以要用heroku提供的Tomcat，叫做webapp-runner
用法也很簡單，本地maven引用webapp-runner，打包成war，push到heroku倉庫，自動就能運行起來了
首先在專案根目錄新增Procfile，沒有副檔名
web: java $JAVA_OPTS -jar target/dependency/webapp-runner.jar --port $PORT target/*.war 加入webapp-runner依賴，注意它版本是跟Tomcat的，我用8版Tomcat所以選8.5.68 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;copy&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;artifactItems&amp;gt; &amp;lt;artifactItem&amp;gt; &amp;lt;groupId&amp;gt;com.heroku&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;webapp-runner&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.5.68.1&amp;lt;/version&amp;gt; &amp;lt;destFileName&amp;gt;webapp-runner.jar&amp;lt;/destFileName&amp;gt; &amp;lt;/artifactItem&amp;gt; &amp;lt;/artifactItems&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 打包完成專案長這樣 我是有安裝heroku cli，比較方便一點，可以直接在本地用heroku指令，也可以在網頁版上面做到一樣的步驟
建立heroku倉庫，可以自己取名，但不能跟別人重複(因為到時候網址就是heroku倉庫，它叫app的名稱)，不自訂就讓系統生成，反正之後都可以改
heroku create 初始化、推送 git init git add . git commit -m &amp;#34;Ready to deploy&amp;#34; git push heroku master 分支master或main都能自動找到
部署成功，使用指令heroku open，或是在網頁點Open app就能打開專案的index
成功看到網頁，DB也有連上，但是css跑掉了，排查原因是CORS跨域問題 因為我在本地開發都是用http，但部屬到heroku後預設是https，這樣也算跨域，可以看到一些靜態資源是OK的，但JS或ajax請求就全被擋 在heroku使用mySQL 它的插件叫cleardb，免費，heroku有很多插件，自己去官網查，安裝也都很簡單就不多提
安裝成功後輸入heroku addons查看插件</description>
    </item>
    
    <item>
      <title>高併發方案、Sentinel限流、Sleuth鏈路追蹤</title>
      <link>https://yoziming.github.io/post/220210-gulimall-24-sentinel/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220210-gulimall-24-sentinel/</guid>
      <description>高併發關注重點 單一職責: 專門的服務模組，就只幹這件事，不論要擴容或是掛了都方便 鏈結加密: 每場商品都有隨機產生的Token，防有心人提早準備(台鐵搶票系統學一下好嗎?) 預熱、扣減: 既然知道會讀多寫少，提前把要被查的資料放Redis；用信號量做令牌，只放行這些數量 動靜分離: 靜態資源從網關就打回去，確保來到伺服的都是動態請求 攔截惡意請求: 在網關設定，判斷那些非人的操作(例如同IP超快超大量的)，直接擋回去 流量錯峰: 用干擾手段使人的操作時間不同(就是噁心用戶)，爭取錯開請求進來的時間 限流、熔斷、降級: 降級就是負載超過上限，Show一個&amp;quot;當前流量過高，請稍後重試&amp;quot;之類的惱人畫面給用戶看 延遲隊列: 終極手段，管你多少請求只要通過驗證就放進隊列，之後慢慢處理，總會給你處理到，但不保證是現在 Sentinel 官方: https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D
用來限流、保護資源 Sentinel分為核心庫 與 Dashboard可視化界面，核心庫不依賴Dashboard 工作原理主要分為三個步驟: 定義資源: 叫做&amp;quot;埋點&amp;quot;，即聲明要保護的資源，可以是服務、方法、甚至單純一段程式碼 方法很多，最簡單就是用註解或try-catch https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8 定義規則: 流量控制規則、熔斷降級規則、系統保護規則、來源訪問控制規則 和 熱點參數規則 最簡單就是開啟Dashboard用可視化界面建立規則(但這樣用的設定保存在記憶體，重開會消失) 檢驗規則是否生效 使用 引包 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-sentinel&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2021.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 設定application.properties 注意他有2端口，一個是訪問dashboard本身，預設是8080 另一個是微服務傳給sentinel中心，預設是8719 # sentinel控制台 spring.cloud.sentinel.transport.dashboard=localhost:8333 # 微服務與控制台傳輸數據的端口 spring.cloud.sentinel.transport.port=8719 載Dashboard: https://github.com/alibaba/Sentinel/releases
啟動Dashboard
預設埠是8080可能衝突，所以自己指定一個 java -jar sentinel-dashboard-1.8.3.jar --server.port=8333 訪問 localhost:8333，賬號密碼都是sentinel 點進去看啥都沒有，因為有訪問的時候才會加載 測試 啟動監控後，調用一次API讓Dashboard發現資源 隨便手動設定一個限流，然後嘗試快速連續訪問 即時監控 pom.xml 注意actuator是依賴於springboot，小心循環依賴 &amp;lt;!--springboot 收集健康狀況信息，提供給sentinel使用--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>柚子書城</title>
      <link>https://yoziming.github.io/post/220209-javaweb-book-market/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220209-javaweb-book-market/</guid>
      <description>柚子書城 柚子書城是一個不依賴Spring框架，純粹的JavaWeb項目，主要練習HTTP基本功、Servlet、Session等原理，以及JDBC、資料庫連接池等基礎的SQL操作。
專案背景(Background) 本項目參考自 尚硅谷java web課程 https://www.bilibili.com/video/BV1Y7411K7zz 個人學習過程的詳細筆記(共14篇): https://yoziming.github.io/post/220101-agg-javaweb-01/ 我修復了一些邏輯並完善功能，並成功將網站部署到雲端，可以透過公開網址訪問 展示網站(Website) 已將專案部署到heroku，由於dyno長時間沒用會自動休眠，有時候訪問可能需要等待約30秒雲端server啟動時間 https://my-javaweb-book-market.herokuapp.com/ 可自行註冊帳號，管理員權限帳號密碼為 admin 學習技術 前端 html、css、javascript的基礎認識
例如: 各種標籤&amp;lt;a href&amp;gt;、&amp;lt;input type&amp;gt;、&amp;lt;form&amp;gt; jsp、jQuery、JSTL標籤庫、EL運算式
例如: &amp;lt;c:if test=&amp;quot;&amp;quot;&amp;gt;、${key1}、綁定點擊事件&amp;hellip;等等 Ajax，非同步請求的基礎構成，例如: $.getJSON()
後端 不依賴Spring框架的http請求與響應操作 Servlet、Filter、Listener、Cookie、Session、JSON 驗證資訊、權限隔離、防止重複提交 JDBC、資料庫連接池、DAO操作SQL MVC與三層架構、搭建javaweb專案 web容器的運作與部屬 實現功能(Service) 柚子書城是簡單的商城項目，依業務劃分可分為五個主要模組 模組 需求 用戶 能驗證資訊(ajax)即時提示的會員註冊、登入(透過cookie)功能 商品 能夠分頁顯示商品(圖書)、可依照價格區間篩選 購物車 以Session實現的購物車，用戶可以快速地瀏覽、增刪購物項目 訂單 提交訂單、查看訂單詳情、確認收貨等等 管理後台 能驗證管理員帳號，增刪改查商品訊息、訂單訊息 演示(Demo) 以下透過gif簡單展示相關功能，若顯示有問題，可以移至個人blog觀看 https://yoziming.github.io/post/220209-javaweb-book-market/ 登入與註冊 以Ajax請求，即時驗證填入的資訊，並做出提醒(如用戶名重複等等) 驗證碼防止機器人與重複註冊 價格篩選 同樣有輸入驗證，即使使用者亂輸入也會在稍後自動校正 可指定頁數直接跳轉的分頁導航 購物車 提示剛剛加入購物車的商品 可修改數量，並且也有輸入驗證與校正 刪除項目、清空購物車 訂單 下單成功後可察看訂單詳情 並且會將購物車正確清空 用戶資訊保護 必須為正確的登入狀態才可以查看訂單相關模組 管理後台 能驗證是否為具有管理員權限 增刪改查商品訊息、訂單訊息 用戶收貨 當商城出貨後，用戶可以執行確認收貨的動作 友善的錯誤提示頁面 版本(Version) 本專案使用的環境: JDK8、MySQL5.</description>
    </item>
    
    <item>
      <title>秒殺優惠模組、Cron表達式</title>
      <link>https://yoziming.github.io/post/220209-gulimall-23-sec-kill/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220209-gulimall-23-sec-kill/</guid>
      <description>秒殺優惠活動 流程 秒殺分兩部分，一是營運人員後台系統新增秒殺場次到DB，然後關聯商品到場次中 後台系統新增場次隸屬於Coupon優惠模組之下 這邊把活動的訊息封裝到資料庫，大部分生成器都做好了，只有少數搜尋條件等等要調整，就不一一列出 網關 注意，後台是網址帶有/api/，請求來自renren-fast-admin的(例如營運人員上架商品、促銷活動)，再重寫URL轉發給其他模組
用戶訪問商城網站，是來自nginx轉發的，斷言是Host=cart.mall.com
application.yml
- id: coupon_route uri: lb://coupon predicates: - Path=/api/coupon/** filters: - RewritePath=/api/(?&amp;lt;segment&amp;gt;.*),/$\{segment} - id: mall_seckill_route uri: lb://seckill predicates: - Host=seckill.mall.com 秒殺模組 這邊負責實際業務邏輯的執行，秒殺有瞬間高併發的特點，必須要做限流＋異步＋緩存 + 頁面靜態化+ 獨立部署，還需要處理定時任務等等 定時任務將最近三天的場次 + 關聯商品上傳到redis中 高併發用redis Cron表達式 用來定義定時任務的週期 由6個空格分開7個域 域 是否必填 值以及範圍 通配符 秒 是 0-59 , - * / 分 是 0-59 , - * / 時 是 0-23 , - * / 日 是 1-31 , - * ?</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA File scope</title>
      <link>https://yoziming.github.io/post/220208-idea-file-scpoe/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220208-idea-file-scpoe/</guid>
      <description>IDEA篩選檔案 IDEA預設的檔案瀏覽器真的很不優，我以前都很蠢的用搜尋然後一個一個翻。原來他還是能做到篩選的，就是步驟挺麻煩 首先要去scope裡面自己設定規則，還可以設定顏色之類的，參考官方: https://www.jetbrains.com/help/phpstorm/configuring-scopes-and-file-colors.html#predefined-scopes-list 一樣記得要設在&amp;quot;用於每個新專案&amp;quot;的設定，否則只會在當前專案生效 例如只想顯示設定檔，可以設定規則: file:*.properties||file:*.yml||file:*.yaml 回到檔案瀏覽區，最好勾上compact，省得太多層資料夾會把列表拉得很長 切換到自定的scope規則，然後全部展開，就可以快速切換許多子模組的設定了 其他實用的篩選還有pom.xml、*config等等，可以自己發揮 </description>
    </item>
    
    <item>
      <title>Maven微服務多模組管理</title>
      <link>https://yoziming.github.io/post/220209-maven-parent-module/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220209-maven-parent-module/</guid>
      <description>Maven多模組管理 groupId、artifactId、version稱為gav，三個必要項組成座標 &amp;lt;project&amp;gt; ... &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;實際項目&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;模塊&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;版本&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;依賴類型&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;依賴範圍&amp;lt;/scope&amp;gt; &amp;lt;optional&amp;gt;依賴是否可選&amp;lt;/optional&amp;gt; &amp;lt;!—主要用於排除傳遞性依賴--&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;…&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;…&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependencies&amp;gt; ... &amp;lt;/project&amp;gt; compile，預設的依賴範圍，表示依賴需要參與當前項目的編譯，後續的測試、運行週期也參與其中，是比較強的依賴。
test，表示依賴僅僅參與測試相關的工作，包括測試代碼的編譯和運行。比較典型的如 junit。
runntime，表示依賴無需參與到項目的編譯，不過後期的測試和運行需要其參與其中。
provided，表示打包的時候可以不用包進去，別的容器會提供。和 compile 相當，但是在打包階段做了排除的動作。
system，從參與程度上來説，和 provided 類似，但不通過 Maven 倉庫解析，可能會造成構建的不可移植，要謹慎使用。
部分引用自 沉默王二 鏈接：https://juejin.cn/post/7033652977973854244
父項目的作用 父項目繼承spring框架 繼承spring-boot-starter-parent同時也會繼承properties例如java.version、UTF-8，就不用自己指定 只在父項目定義版本號 在父項目dependencyManagement列出版本號但在父項目自己不用，子模組繼承後，顯式聲明某依賴(但不寫版本號)就可以獲取父項目的版本號 好比你爸列了一個購物清單，沙發=黑色真皮、桌巾=紅色，但你爸沒有真的去買 去購物的是你，如果有買到沙發，你自己沒特別想要的款式那就是預設黑色真皮沙發 你爸的購物清單可以很長，沒有說全都要買，他只負責列出來，只出一張嘴 你自己有特殊想法那也可以指定版本，不過最好不要這樣很容易亂。統一交給你爸管理 父項目讓子模塊之間可以相互引用 spring-boot-dependencies spring-boot-starter-parent 又繼承自 spring-boot-dependencies
而 spring-boot-dependencies 沒有 parent， 它是頂級pom，其中 &amp;lt;properties&amp;gt; 內定義了很多常見項目的版本號，舉例:
spring-boot-test spring-boot-starter-web mysql-connector-java 各種jdbc java web常用依賴 commons-lang3.version org.apache.httpcomponents javax.servlet org.projectlombok 所以spring-boot很多時候都不用再寫版本號，因為常用的幾乎都可以往上找 其他dependencies 只要引用或繼承了XXX-dependencies，就相當於把相關的版本號選擇都交給了它來處理，有這種BOM可以優先選用，能省下很多版本衝突的困擾，尤其是spring cloud這種要求配套的 spring-cloud-dependencies spring-cloud-kubernetes.</description>
    </item>
    
    <item>
      <title>串接第三方支付</title>
      <link>https://yoziming.github.io/post/220208-gulimall-22-pay/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220208-gulimall-22-pay/</guid>
      <description>商城支付 非對稱加密 RSA 加密跟解密是不同的鑰匙 我用私鑰加密，發給給你，你用公鑰解密，你不知道我的私鑰 加簽: 根據明文(例如: &amp;ldquo;我給小明100元&amp;rdquo;)用MD5生成一個簽名，如果明文任意字符修改，簽名就會天差地別(MD5特性) 驗簽: 確定 明文與簽名是否對應(明文是否被篡改) NAT穿透 Network Address Translation Traversal
內部IP就是192.168.X.X開頭的那些，穿透技術就是讓外部可以透過公有IP訪問到你的內部IP 原理就是透過各種網路服務供應商幫你搭橋 使用場景: 開發測試，取得暫時的對外域名讓外部可以訪問本機 智慧家電連網，例如出門在外用手機網路可以看家裡監控那種 遠程控制，遠端桌面 以前玩Minecraft架server有用過類似的東西 支付沙盒 大部分的電子支付API都有提供一個sandbox做測試開發用 LinePay的 https://pay.line.me/jp/developers/techsupport/sandbox/creation?locale=zh_TW 但是這個申請都要有店家資格，不好弄 我研究了一下這個EcPAY的 https://www.ecpay.com.tw/Service/API_Dwnld 大致使用流程就是申請帳號，然後下載支付網站提供的API與SDK，包到自己的專案之下，填上各種授權key，串接付款與跳轉的頁面這樣 支付串接流程 PayWebController.java 這邊接收前端來的訂單號@RequestParam(&amp;quot;orderSn&amp;quot;)，用訂單號去查詢訂單內容，然後帶著訂單內容往支付的API @GetMapping(value = &amp;#34;/payOrder&amp;#34;, produces = &amp;#34;text/html&amp;#34;) public String payOrder(@RequestParam(&amp;#34;orderSn&amp;#34;) String orderSn) throws AlipayApiException { PayVo payVo = orderService.getOrderPay(orderSn); String pay = alipayTemplate.pay(payVo); System.out.println(pay); return pay; } AlipayTemplate.java 這個是由第三方提供的，台灣的我查了一下接近的有綠界的站內付2.0，但是他屬於高級會員才有的服務，API也沒有對外公開。只能說台灣在支付這塊真的落後很多，大部分是要自己寫一個前端頁面給顧客填付款資訊，把資訊串進第三方金流提供的SDK，生成付款的訂單訊息，就沒那麼方便 他這個Template都已經做好付款、退款、查詢等功能，只要填入自己支付的私鑰、公鑰、支付完要跳轉到的成功頁面，串上訂單號、金額、商品描述等等就能使用 用戶點支付，就從訂單跳轉到專屬生成的支付頁面(SDK直接生成的一個html頁面)，付完就回到成功頁面，串接真的是超簡單 並且只要支付成功，會發一個異步通知給商戶(一樣提前設定好notify_url)，收到通知驗證一下簽名(用商戶的key)，就能從裡面取出支付的詳細內容，根據這個內容，在後台修改訂單狀態、保存交易的流水號等訊息，自此完成一個完整的支付 會員查詢訂單 他把會員的訂單歸到會員模組了
整理新建模組要幹的事:
引入thymeleaf、放頁面、放靜態檔案 設定網域與網關轉發 由於會員需要登入，設定登入攔截器、註冊WebMvcConfigurer 登入狀態存在session，所以還要導入spring-session與data-redis 其實應該用Spring Security的OA2做登入權限的統一管理會更好，否則這有些還要給feign調用放行特別寫規則還挺麻煩的 MemberWebController.</description>
    </item>
    
    <item>
      <title>Seata、消息隊列分佈式事務</title>
      <link>https://yoziming.github.io/post/220207-gulimall-21-delay-queue/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220207-gulimall-21-delay-queue/</guid>
      <description>Spring cloud alibaba Seata 有很多模式，這邊只演示最簡單的AT模式 簡單來說就是多包一層，額外開一個伺服器去監控多個分佈式模組，誰出問題就讓大家都回滾 使用@GlobalTransactional就可以達成分佈式事務
利用的機制是在DB增加一個undo_log表，這個表相當於存快照的地方，當要回滾就從這邊還原
AT模式簡單，代價就是面對併發效率不高 這玩意才幾個版本設定就變好多次，具體使用還是看官網吧
https://seata.io/zh-cn/docs/ops/deploy-guide-beginner.html 延遲隊列 Delay Queue，使用 消息隊列 + 庫存工作單表 來控制分佈式事務
下訂單後，要鎖定庫存，這是個分佈式事務，需要保證鎖定的庫存能回滾，首先在DB使用兩張表 wms_ware_order_task 庫存工作單表，訂單、工作單id、倉庫id wms_ware_order_task_detail 庫存工作單詳情表，訂單、工作單id、倉庫id、skuId、鎖庫存數量 鎖庫存的時候往工作單表、工作單詳情表插入數據 創建隊列與交換機 在RabbitMQ
創建訂單時，遠程調用orderLockStock創建了庫存工作單，並且鎖定庫存 那邊發了&amp;quot;stock-event-exchange&amp;quot;, &amp;quot;stock.locked&amp;quot;, lockedTo，lockedTo裡面就是庫存工作單id 當遠程調用創建庫存工作單成功，本地也發一個&amp;quot;order-event-exchange&amp;quot;, &amp;quot;order.create.order&amp;quot;，裡面存的是訂單本體 改良，省下一個交換機，帶有&amp;quot;order.create.order&amp;quot;路由鍵的訂單會進到order.delay.queue這個延遲隊列，而這個隊列還是指向order-event-exchange交換機 但是他設有過期時間，當時間到了就把路由鍵換成order.release.order 也就是說，所有的訂單最終都會進到order.release.order.queue，並且被listener消費，這個listener會調用closeOrder方法 closeOrder方法查看訂單是否已經支付，若已支付就完事，訂單可以安心離開隊列。若沒支付就查詢訂單最新狀態，再發到&amp;quot;order-event-exchange&amp;quot;, &amp;quot;order.release.other.unlock&amp;quot;, order 這個&amp;quot;order.release.other.unlock&amp;quot;路由鍵就會把訂單送到stock.release.stock.queue，嘗試進行庫存解鎖的動作 之前學了用AmqpAdmin創建交換機與隊列的方法，有更省事的可以直接用@Bean讓spring自動創建 Broker中沒有該名字的隊列、交換機才會創建 不會重複創建覆蓋(一旦創好，不能更新)，如果同名的隊列其中設定(例如過期時間)對不上會報錯 第一次使用隊列的時候才會創建 MyMQConfig.java @Configuration public class MyMQConfig { // 延遲隊列 @Bean public Queue orderDelayQueue() { /* Queue(String name, 隊列名字 boolean durable, 是否持久化 boolean exclusive, 是否排他 boolean autoDelete, 是否自動刪除 Map&amp;lt;String, Object&amp;gt; arguments) 屬性【TTL、死信路由、死信路由鍵】 */ HashMap&amp;lt;String, Object&amp;gt; arguments = new HashMap&amp;lt;&amp;gt;(); arguments.</description>
    </item>
    
    <item>
      <title>阿里巴巴Java開發手冊</title>
      <link>https://yoziming.github.io/post/220207-alibaba-java-guide/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220207-alibaba-java-guide/</guid>
      <description>阿里巴巴Java開發手冊 學sentinel時翻了一下alibaba的github，按照star排序第2名是個p3c，好奇點進去看原來是一份Java Coding Guidelines
官方: https://github.com/alibaba/p3c 線上電子書: https://www.cntofu.com/book/78/index.html 他甚至有一個用來檢查的IDEA插件，厲害 個人知識重點 已經掌握的知識就不記了，以下都是我以前犯過的錯誤或是不懂原理的地方
【強制】類名使用UpperCamelCase風格，但以下情形例外：DO / BO / DTO / VO / AO / PO等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion
【強制】杜絕完全不規範的縮寫，避免望文不知義。 反例：AbstractClass“縮寫”命名成AbsClass；condition“縮寫”命名成 condi，此類隨意縮寫嚴重降低了代碼的可閲讀性。
【強制】POJO類中布爾類型的變量，都不要加is前綴，否則部分框架解析會引起序列化錯誤。 反例：定義為基本數據類型Boolean isDeleted；的屬性，它的方法也是isDeleted()，RPC框架在反向解析的時候，“誤以為”對應的屬性名稱是deleted，導致屬性獲取不到，進而拋出異常。
【強制】long或者Long初始賦值時，使用大寫的L，不能是小寫的l，小寫容易跟數字1混淆，造成誤解。
【強制】不允許任何魔法值（即未經預先定義的常量）直接出現在代碼中。
【強制】避免通過一個類的對象引用訪問此類的靜態變量或靜態方法，無謂增加編譯器解析成本，直接用類名來訪問即可。
【強制】Object的equals方法容易拋空指針異常，應使用常量或確定有值的對象來調用equals。 正例：&amp;ldquo;test&amp;rdquo;.equals(object);
【強制】所有的相同類型的包裝類對象之間值的比較，全部使用equals方法比較。 説明：對於Integer var = ? 在-128至127範圍內的賦值，Integer對象是在IntegerCache.cache產生，會複用已有對象，這個區間內的Integer值可以直接使用==進行判斷，但是這個區間之外的所有數據，都會在堆上產生，並不會複用已有對象，這是一個大坑，推薦使用equals方法進行判斷。
關於基本數據類型與包裝數據類型的使用標準如下：
【強制】所有的POJO類屬性必須使用包裝數據類型。 【強制】RPC方法的返回值和參數必須使用包裝數據類型。 【推薦】所有的局部變量使用基本數據類型。 説明：POJO類屬性沒有初值是提醒使用者在需要使用時，必須自己顯式地進行賦值，任何NPE問題，或者入庫檢查，都由使用者來保證。 正例：數據庫的查詢結果可能是null，因為自動拆箱，用基本數據類型接收有NPE風險。 反例：比如顯示成交總額漲跌情況，即正負x%，x為基本數據類型，調用的RPC服務，調用不成功時，返回的是預設值，頁面顯示為0%，這是不合理的，應該顯示成中劃線。所以包裝數據類型的null值，能夠表示額外的信息，如：遠程調用失敗，異常退出。 【強制】定義DO/DTO/VO等POJO類時，不要設定任何屬性預設值。 反例：POJO類的gmtCreate預設值為new Date();但是這個屬性在數據提取時並沒有置入具體值，在更新其它字段時又附帶更新了此字段，導致創建時間被修改成當前時間。
【推薦】避免採用取反邏輯運算符。 説明：取反邏輯不利於快速理解，並且取反邏輯寫法必然存在對應的正向邏輯寫法。
【推薦】表達異常的分支時，少用if-else方式 説明：用if過濾即可，太多else會導致維護困難
【強制】在高併發場景中，避免使用”等於”判斷作為中斷或退出的條件。 説明：如果併發控制沒有處理好，容易產生等值判斷被“擊穿”的情況，使用大於或小於的區間判斷條件來代替。
反例：判斷剩餘獎品數量等於0時，終止發放獎品，但因為併發處理錯誤導致獎品數量瞬間變成了負數，GG
【強制】類、類屬性、類方法的註釋必須使用Javadoc規範，使用/*內容/格式，不得使用// xxx方式。 説明：在IDE編輯窗口中，Javadoc方式會提示相關注釋，生成Javadoc可以正確輸出相應註釋；在IDE中，工程調用方法時，不進入方法即可懸浮提示方法、參數、返回值的意義，提高閲讀效率。
【強制】方法內部單行註釋
【強制】所有的枚舉類型字段必須要有註釋，説明每個數據項的用途。</description>
    </item>
    
    <item>
      <title>提交訂單: 冪等性、分散式交易的一致性</title>
      <link>https://yoziming.github.io/post/220206-gulimall-20-idempotent/</link>
      <pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220206-gulimall-20-idempotent/</guid>
      <description>冪等性 idempotent
多次提交，結果不變，常見有這些辦法: Token 令牌或驗證碼 伺服器存儲了一個令牌，然後頁面要帶上這個令牌比較，一樣才可以提交 提交後刪除掉token，再次點擊提交就會失敗 但是F5刷新的話就不一樣了，會有新的token產生 注意: 獲取redis令牌 + 令牌匹配 + redis刪除，全程要保證原子性，使用lua腳本 鎖 數據庫悲觀鎖 Pessimistic Lock
就是排他鎖，所謂悲觀在於覺得總有刁民想亂搞我的data，所以自己拿到鎖就把data藏到大衣裡，完全不給其他人用，連看都不給看 當一個SQL command獲得悲觀鎖後，其他的SQL command 無法讀取無法修改，直到悲觀鎖被釋放後才能執行，例如: select* from xxx where id = 1 for update; 悲觀鎖使用時一般伴隨事務一起使用，數據鎖定時間可能會很長，需要根據實際情況選用 另外要注意的是，id字段一定是主鍵或者唯一索引，不然可能造成鎖表的結果，處理起來會非常麻煩 資料庫中的行鎖，表鎖，讀鎖，寫鎖，以及syncronized實現的鎖均為悲觀鎖 數據庫樂觀鎖 Optimistic Lock
允許多個 SQL command 來操作 table，但是要帶上版本號 當 SQL command 想要變更欄位 data 時會先把之前取出 version 跟 table 現在的 version 做對比，如果相同就代表這段期間沒人修改可以執行；如果不同就會禁止這次的操作 這種方法適合在更新的場景中，例如: update t_goods set count = count-1,version =version + 1 where good_id=2 and version = 1 樂觀鎖主要使用於處理讀多寫少的場景 分佈式鎖 不管多少服務，限制同時都只有一人能操作 參考之前的筆記: https://yoziming.</description>
    </item>
    
    <item>
      <title>確認訂單、feign請求頭問題</title>
      <link>https://yoziming.github.io/post/220205-gulimall-19/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220205-gulimall-19/</guid>
      <description>商城訂單模組 訂單通常是最複雜的模組之一
涉及三流: 信息流：商品信息、優惠信息 資金流：退款、付款 物流：發送、退貨 訂單流程 訂單流程是指從訂單產生到完成的過程
不同的產品類型或業務類型在系統中的流程會千差萬別，比如線上實物訂單和虛擬訂單與o20訂單等，所以需要根據不同的類型進行構建訂單流程
不管類型如何訂單都包括正向流程和逆向流程，對應的場景就是購買商品和退換貨流程，正向流程就是一個正常的網購步驟
訂單生成-&amp;gt; 支付訂單-&amp;gt; 賣家發貨-&amp;gt; 確認收貨-&amp;gt; 交易成功 而每個步驟的背後，訂單是如何在多系統之間交互流轉的，可概括如下圖
正向流程 訂單創建前需要預覽訂單，選擇收貨信息等 訂單創建需要鎖定庫存，庫存有才可創建，否則不能創建 訂單創建後超時未支付需要解鎖庫存 支付成功後，需要進行拆單，根據商品打包方式，所在倉庫，物流等進行拆單 支付的每筆流水都需要記錄，以待查賬 訂單創建，支付成功等狀態都需要給MQ發送消息，方便其他系統感知訂閲 逆向流程 修改訂單，用户沒有提交訂單，可以對訂單一些信息進行修改，比如配送信息， 優惠信息，及其他一些訂單可修改範圍的內容，此時只需對數據進行變更即可。 訂單取消，用户主動取消訂單和用户超時未支付，兩種情況下訂單都會取消訂單，而超時情況是系統自動關閉訂單，所以在訂單支付的響應機制上面要做支付的 訂單狀態 待付款: 用户提交訂單後，訂單進行預下單，目前主流電商網站都會便於用户快速完成支付，需要注意的是待付款狀態下可以對庫存進行鎖定，鎖定庫存需要配置支付超時時間，超時後將自動取消訂單，訂單變更為關閉狀態 已付款/待發貨: 用户完成訂單支付，訂單系統需要記錄支付時間，支付流水單號便於對賬，訂單下放到WMS系統，倉庫進行調撥，配貨，分揀，出庫等操作 待收貨/已發貨: 倉儲將商品出庫後，訂單進入物流環節，訂單系統需要同步物流信息，便於用户實時知悉物品物流狀態 已完成: 用户確認收貨後，訂單交易完成。後續支付側進行結算，如果訂單存在問題進入售後狀態 已取消: 付款之前取消訂單。包括超時未付款或用户商户取消訂單都會產生這種訂單狀態 售後中: 用户在付款後申請退款，或商家發貨後用户申請退換貨。售後也同樣存在各種狀態，當發起售後申請後生成售後訂單，售後訂單狀態為待審核，等待商家審核，商家審核通過後訂單狀態變更為待退貨，等待用户將商品寄回，商家收貨後訂單狀態更新為待退款狀態，退款到用户原賬户後訂單狀態更新為售後成功 前端頁面 等待付款，詳情頁：
訂單頁：
收銀頁：
整理各種POJO與規範 feign包放在common模組下，用TO(Transfer Object)來跨模組接收、傳遞物件 VO(View Object) 是專門返回給前端、給人看的東西 Entity實體，也稱為PO(Persistant Object)，屬性基本和資料表欄位一一對應。一個實體即是真實存在的一筆資料，必須要有唯一標識(例如id)以區分其它實體 DAO(Data Access Object)封裝了PO在資料庫的CRUD等操作 實作 登入攔截 點結算時，沒登入就讓用戶先去登入
LoginUserInterceptor.java 記得造一個config實現WebMvcConfigurer註冊攔截器 攔截器記得用@Component讓spring載入 /** * 登入攔截器 * 從session中獲取了登入信息（redis中），封裝到了ThreadLocal中 */ @Component public class LoginUserInterceptor implements HandlerInterceptor { public static ThreadLocal&amp;lt;MemberResponseTo&amp;gt; loginUser = new ThreadLocal&amp;lt;&amp;gt;(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 獲取登入的用戶信息 MemberResponseTo attribute = (MemberResponseTo) request.</description>
    </item>
    
    <item>
      <title>RabbitMQ與訊息確認</title>
      <link>https://yoziming.github.io/post/220204-gulimall-18-rabbitmq/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220204-gulimall-18-rabbitmq/</guid>
      <description>Message Queue Message queue 訊息佇列
佇列（queue），又稱為隊列，特性是先進先出(FIFO) 訊息佇列是一個中間件，又是經典的&amp;quot;加一層&amp;quot;操作，抽出一個專門存放溝通訊息的地方，就是訊息佇列 可以理解成去銀行辦事，那個領號碼牌的機器 市面上常見的MQ: ActiveMQ、RabbitMQ、RocketMQ、Kafka 目的 縮短調用時間: 透過序列分發後續的異步調用，不需要一步一步往下走等返回 就像去醫院，醫生開了檢查要你去抽血跟照X光，哪邊方便就先去做，總之檢查單開了醫生就不管了，你總會去做完檢查 解耦: 模組間溝通用訂閱佇列的形式，只需要關注收發訊息，減少業務邏輯的侵入 比如到了抽血站，拿檢驗單去掃機器就能完成抽血報名，不需要醫生打電話告知抽血站誰要抽什麼血 削峰: 流量控制，錯開高併發，依順序處理 隊列是有序、可控制流量的，不會突然1000人擠爆抽血站 名詞 消息代理（message broker）: 安裝了消息中間件的伺服器，發送消息和接收消息都要連上它
冒險者公會的任務看板 目的地（destination）: 目的地表示生產者發送消息給消息代理之後，是存儲到消息代理中哪一個具體的目的地（隊列或主題）
隊列（queue）：點對點通信，1個發送者，n個接受者，但一個信息只會被一個接受者消費（消費後移出隊列）
理解為拋繡球 主題（topic）：發佈/訂閲，多個發送者+多個訂閲者。多個訂閲者會同時接收到
廣播 JMS (Java Message Service): 基於JAVA API定義的標準介面
類似JDBC與資料庫廠商之間的關係
ActiveMQ、HornetMQ是JMS實現
參考 https://openhome.cc/Gossip/EJB3Gossip/JavaMessageService.html
AMQP(Advanced Message Queuing Protocol)
高級消息隊列協議，也是一個消息代理的規範，兼容JMS RabbitMQ是AMQP的實現 不管JMS或AMQP，Spring都有提供支持，只要實現ConnectionFactory來連接消息代理，Spring Boot也都有自動配置
Spring真的是無敵，一統Java江湖 RabbitMQ 這一Part講的超清晰，講的太好了 https://www.bilibili.com/video/BV1np4y1C7Yf?p=250&amp;amp;spm_id_from=pageDriver
publisher發送message message由消息頭 + 消息體組成(類似HTTP)，發送到Message Broker消息代理伺服器上 在Broker中，Exchange交換機綁定Queue，並識別route key(消息要去哪) 消費者訂閱隊列，建立一條Connection長連接(連接上開闢有多條channel信道) 類似高速公路有6車道那樣 長連接能監聽消費者是否斷開，如果斷開了就回收消息，不至於丟失 在Broker中，Exchange與Queue可以組成VHost虛擬主機，類似命名空間互相隔離，可以用來區分不同平台或是dev與pub 啟用 官方: https://www.rabbitmq.com/networking.html
docker run -d --name rabbitmq --restart=always -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management 這是章魚不是兔子吧，這麼多端口</description>
    </item>
    
    <item>
      <title>cookie&amp;redis實現訪客購物車</title>
      <link>https://yoziming.github.io/post/220203-gulimall-17-offline-cart/</link>
      <pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220203-gulimall-17-offline-cart/</guid>
      <description>購物車需求分析 訪客購物車 沒登入也能放地購物車，是我才不搞那麼多，沒登入就讓用戶登一下不就好了，唉當練習吧
意外的是這個項目是仿京東，結果京東現在也不提供這種功能了，一律先登入再說
可以把資料暫存在客戶端，例如:
localstorage cookie WebSQL 但何種商品被放到購物車本身是一個有價值的資訊，所以選擇放到伺服端的redis
用户購物車 一樣採用redis，優勢在於 極高的讀寫併發性能 好組織數據結構 redis也有持久化策略，AOF 登入後會將離線購物車合併 操作分析 增（添加商品到購物車） 刪（刪除某個商品） 改（修改商品數量） 查（查詢購物車中的商品） 商品是否被選中，下次進來還是選中狀態 用户可以使用購物車多件商品一起結算下單 在購物車中展示商品優惠信息 提示購物車商品價格變化 資料庫設計 Redis數據結構用Hash，造一個雙層Map來存 Map&amp;lt;String, Map&amp;lt;String, String&amp;gt;&amp;gt; 第一個key是用户id，value是購物車信息 第二個key是skuId，value是購物項數據 Vo設計 類似之前做的書城項目
CartVo是完整的一台車，這邊有CartItemVo構成的List、總件數、總價 CartItemVo略等同於Sku，就是車中的某項商品，加上件數與價格 在CartVo.java 將計算總價等等方法封裝起來 public BigDecimal getTotalAmount() { BigDecimal amount = new BigDecimal(&amp;#34;0&amp;#34;); // 計算購物項總價 if (!CollectionUtils.isEmpty(items)) { for (CartItemVo cartItem : items) { if (cartItem.getCheck()) { amount = amount.add(cartItem.getTotalPrice()); } } } // 計算優惠的價格 return amount.subtract(getReduce()); } 實作 攔截器 當用戶想用購物車，必須判斷是否已登入，若無登入，創造一個臨時用戶cookie:user-key</description>
    </item>
    
    <item>
      <title>註冊、登入與Spring Session</title>
      <link>https://yoziming.github.io/post/220202-gulimall-16-spring-session/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220202-gulimall-16-spring-session/</guid>
      <description>WebMvcConfigurer 參考 https://blog.csdn.net/pan_junbiao/article/details/120039885
複習SpringMVC WebMvcConfigurer是一個接口，用JavaBean的方式代替web.xml，常用於: 攔截器，例如: @Override public void addInterceptors(InterceptorRegistry registry) { super.addInterceptors(registry); registry.addInterceptor(new TestInterceptor()).addPathPatterns(&amp;#34;/**&amp;#34;).excludePathPatterns(&amp;#34;/emp/toLogin&amp;#34;,&amp;#34;/emp/login&amp;#34;,&amp;#34;/js/**&amp;#34;,&amp;#34;/css/**&amp;#34;,&amp;#34;/images/**&amp;#34;); } 跨域設定，例如: // 跨域 @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&amp;#34;/**&amp;#34;) .allowedOrigins(&amp;#34;*&amp;#34;) //浏览器允许所有的域访问 / 注意 * 不能满足带有cookie的访问,Origin 必须是全匹配 .allowCredentials(true) // 允许带cookie访问 .allowedMethods(&amp;#34;GET&amp;#34;, &amp;#34;POST&amp;#34;, &amp;#34;PUT&amp;#34;, &amp;#34;DELETE&amp;#34;, &amp;#34;OPTIONS&amp;#34;) .allowedHeaders(&amp;#34;token&amp;#34;) .maxAge(3600); } 更多關於跨域，參考 https://segmentfault.com/a/1190000019485883
映射html頁面 前後綴一樣由thymeleaf加上 @Configuration public class MallWebConfig implements WebMvcConfigurer { // View映射，省下造controller一個一個設定 @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&amp;#34;/&amp;#34;).setViewName(&amp;#34;login&amp;#34;); registry.addViewController(&amp;#34;/login.html&amp;#34;).setViewName(&amp;#34;login&amp;#34;); registry.addViewController(&amp;#34;/reg.html&amp;#34;).setViewName(&amp;#34;reg&amp;#34;); } } /* 相當於 @GetMapping(value = &amp;#34;/login.</description>
    </item>
    
    <item>
      <title>商品詳情</title>
      <link>https://yoziming.github.io/post/220201-gulimall-15/</link>
      <pubDate>Tue, 01 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220201-gulimall-15/</guid>
      <description>商品詳情 View 商品詳情也是子網域，設定網關: nginx就不用改了，因為之前設的規則是*.mall.com 導入頁面item.html與靜態資源 前端頁面一樣用thymeleaf渲染 thymeleaf中動態網址的寫法，用|包住網址前後，中間${參數} &amp;lt;a th:href=&amp;#34;|http://item.mall.com/${product.skuId}.html|&amp;#34;&amp;gt; 格式化數字，前面3是整數位，2是小數位 &amp;lt;span th:text=&amp;#34;${#numbers.formatDecimal(item.info.price,3,2)}&amp;#34;&amp;gt; sku組合切換，太偏前端了，有用到再來學 https://www.bilibili.com/video/BV1np4y1C7Yf?p=208&amp;amp;spm_id_from=pageDriver
另外我發現thymeleaf是不是有病，一般的HTML註解&amp;lt;!--他竟然還是會解析，不顯示但是會解析 可以參考 https://blog.csdn.net/sun_jy2011/article/details/40299821 比如一塊代碼有問想先註解掉，整塊用快捷鍵選起來ctrl+/先註解掉還不行，他就是硬要解析，如果有BUG就會一直讀出BUG，真的是有病耶，這樣設計是腦子被門夾到嗎。一定要用下面這樣的格式包起來的才不會解析 &amp;lt;!--/*--&amp;gt; xxxx OOOO &amp;lt;!--*/--&amp;gt; Controller ItemController.java 我才搞懂return &amp;quot;item&amp;quot;是因為前面說的thymeleaf自動會加上前後綴，就相當於templates/item.html @GetMapping(&amp;#34;/{skuId}.html&amp;#34;) public String skuItem(@PathVariable(&amp;#34;skuId&amp;#34;) Long skuId, Model model) throws ExecutionException, InterruptedException { System.out.println(&amp;#34;準備查詢&amp;#34; + skuId + &amp;#34;詳情&amp;#34;); SkuItemVo vos = skuInfoService.item(skuId); model.addAttribute(&amp;#34;item&amp;#34;, vos); return &amp;#34;item&amp;#34;; } Model Vo設計 /** * 1、sku基本信息【標題、副標題、價格】pms_sku_info * 2、sku圖片信息【每個sku_id對應了多個圖片】pms_sku_images * 3、spu下所有sku銷售屬性組合【不只是當前sku_id所指定的商品】 * 4、spu商品介紹【】 * 5、spu規格與包裝【參數信息】 */ SkuItemVo.java 其他太詳細的就不貼了，我感覺如果封裝的子類只有它用，那就乾脆造內部類可能會整齊一點 //1、sku基本信息的獲取 pms_sku_info private SkuInfoEntity info; private boolean hasStock = true; //2、sku的圖片信息 pms_sku_images private List&amp;lt;SkuImagesEntity&amp;gt; images; //3、獲取spu的銷售屬性組合【一個vo是一個銷售屬性】 private List&amp;lt;SkuItemSaleAttrVo&amp;gt; saleAttr; //4、獲取spu的介紹 private SpuInfoDescEntity desc; //5、獲取spu的規格參數信息【以組為單位】 private List&amp;lt;SpuItemAttrGroupVo&amp;gt; groupAttrs; 異步獲取商品詳情 使用自訂的線程池，由於3 4 5要等1完成，所以最後順序調了下 SkuInfoServiceImpl.</description>
    </item>
    
    <item>
      <title>線程池與CompletableFuture異步編排</title>
      <link>https://yoziming.github.io/post/220131-gulimall-14-thread/</link>
      <pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220131-gulimall-14-thread/</guid>
      <description>多線程 初始化線程的4種方式 繼承 Thread 實現 Runnable接口 實現 Callable接口 + FutureTask（可以拿到返回結果，可以處理異常） 線程池 複習 https://yoziming.github.io/post/211204-agg-ja-19/
區別 1、2不能得到返回值。3可以獲取返回值 1、2、3都不能控制資源 4可以控制資源，性能穩定，不會一下子所有線程一起運行 實際開發中，只用線程池，因為高併發狀態開啓了n個線程，會直接耗盡資源 線程池的優勢 降低資源的消耗: 省得在那創了又刪，刪了又創 提高響應速度: 已經在池子那等了，來活就幹 提高線程的可管理性: 例如系統中可以創建兩個線程池，核心線程池、非核心線程池，有需要時可以關閉非核心線程池釋放記憶體資源 就像公司分兩部門，壓力大就把非核心的部門關了 手動創建線程池 可以new ThreadPoolExecutor(參數)手動創建線程池，七大參數: // ThreadPoolExecutor.java 原始碼 corePoolSize – the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set maximumPoolSize – the maximum number of threads to allow in the pool keepAliveTime – when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</description>
    </item>
    
    <item>
      <title>用ElasticSearch實現商品搜索</title>
      <link>https://yoziming.github.io/post/220130-gulimall-13/</link>
      <pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220130-gulimall-13/</guid>
      <description>搜索頁面 搜尋頁面有自己的子網域，網址是 http://search.mall.com/
我觀察了一下，台灣的商城網站大多是用子目錄，例如:
https://www.momoshop.com.tw/search/ https://www.etmall.com.tw/Search? https://shopping.friday.tw/ec2/search? 而用子網域的通常是大陸的電商網站，經過查詢兩者其實沒太大差異
通常來說，屬於網站下的附屬小功能，用子目錄；而體量大到可以分割出去才用會用子網域
子網域複雜了一點，反正都學學吧
設定網段 改host模擬DNS nginx 採了坑，改完忘記要重開服務 網關 - id: mall_search_route uri: lb://search predicates: - Host=search.mall.com 靜態資源 這邊一樣用thymeleaf渲染，引包 關閉 spring.thymeleaf.cache=false 調整 list.html，確認一下跟首頁的超連結是否正確 寫Vo 這可就複雜了，需要考慮各種搜尋條件、返回的結果&amp;hellip;
搜尋條件 SearchParam.java @Data public class SearchParam { /** * 頁面傳遞過來的全文匹配關鍵字 */ private String keyword; /** * 品牌id,可以多選 */ private List&amp;lt;Long&amp;gt; brandId; /** * 三級分類id */ private Long catalog3Id; /** * 排序條件：sort=price/salecount/hotscore_desc/asc */ private String sort; /** * 是否有貨 */ private Integer hasStock; /** * 價格區間查詢 */ private String skuPrice; /** * 按照屬性進行篩選 */ private List&amp;lt;String&amp;gt; attrs; /** * 頁碼 */ private Integer pageNum = 1; /** * 原生的所有查詢條件 */ private String _queryString; } 返回的結果 SearchResult.</description>
    </item>
    
    <item>
      <title>Redisson與SpringCache</title>
      <link>https://yoziming.github.io/post/220129-gulimall-12-redisson/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220129-gulimall-12-redisson/</guid>
      <description>Redisson Java操作Redis的框架，主要用他的分布式鎖的功能
加鎖的方法與邏輯幾乎都跟java.util.concurrent包下的一樣
JUC包: ReentrantLock那些，如果沒印象了看下面個種鎖的範例就會回想起來 前置設定 https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95
引包 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.16.8&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 造config類 注意import org.redisson.config.Config @Configuration public class RedissonConfig { /** * 所有對Redisson的使用都是通過RedissonClient * * @return * @throws IOException */ @Bean(destroyMethod = &amp;#34;shutdown&amp;#34;) public RedissonClient redisson() throws IOException { // 創建配置 Config config = new Config(); config.useSingleServer().setAddress(&amp;#34;redis://localhost:6379&amp;#34;); // 根據Config創建出RedissonClient實例 // Redis url should start with redis:// or rediss:// RedissonClient redissonClient = Redisson.create(config); return redissonClient; } } 注入RedissonClient，開始造鎖 @Autowired RedissonClient redisson; Lock 基本鎖 只要鎖的名字(例如: &amp;quot;myLock&amp;quot;)一樣，就是同一把鎖 預設為阻塞式等待，過期時間沒指定是30s 自動續期，如果業務超長，運行期間自動鎖上新的30s 如果手動指定了過期時間就不會自動續期，除非再使用看門狗 但何必搞那麼多，讓他預設30秒自動續就挺好 RLock lock = redisson.</description>
    </item>
    
    <item>
      <title>Redis緩存與分佈式鎖</title>
      <link>https://yoziming.github.io/post/220128-gulimall-11-synchronized-lock/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220128-gulimall-11-synchronized-lock/</guid>
      <description>緩存 誰適合進緩存? 讀多寫少 即時性、一致性要求不高的 例如: 物流資訊、排行榜 實現 請求來了，緩存中是否已有資料?
無，去DB拿一份給他，並且存到緩存中 有，直接從緩存拿給他 本地緩存: 最簡單實現就是寫一個Map，把東西存裡面。然而在分布式會有問題
負載均衡: 每次輪到可能每個分散的機站都要去DB取一份資料 資料一致性: 某處更新了，其他處已經緩存中的不會更新 於是就會用到Redis這種noSQL
Spring Redis 引包: spring-boot-starter-data-redis application.properties設定端口與密碼(如果有) spring.redis.host=localhost spring.redis.port=6379 造一個StringRedisTemplate 用.opsForXXX()方法造出操作子，XXX是要存的value類型 拿造出的操作子開始set、get @Autowired StringRedisTemplate stringRedisTemplate; @Test void test1() { ValueOperations&amp;lt;String, String&amp;gt; ops = stringRedisTemplate.opsForValue(); ops.set(&amp;#34;hello&amp;#34;, &amp;#34;world_&amp;#34; + UUID.randomUUID()); System.out.println(&amp;#34;ops.get(\&amp;#34;hello\&amp;#34;) = &amp;#34; + ops.get(&amp;#34;hello&amp;#34;)); } 推薦使用這個小軟體來查看管理Redis https://github.com/qishibo/AnotherRedisDesktopManager/releases
優化實作 回到之前的CategoryServiceImpl.java // 從redis獲取所有分類 @Override public Map&amp;lt;String, List&amp;lt;Catalogs2Vo&amp;gt;&amp;gt; getCatalogJson() { // 先去緩存拿 ValueOperations&amp;lt;String, String&amp;gt; ops = stringRedisTemplate.opsForValue(); String catalogJson = ops.</description>
    </item>
    
    <item>
      <title>Nginx&amp;網關、壓測與性能優化</title>
      <link>https://yoziming.github.io/post/220127-gulimall-10-stress-testing/</link>
      <pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220127-gulimall-10-stress-testing/</guid>
      <description>Nginx反向代理 正向代理，例如Proxy、VPN，我透過它去訪問別人。例如我暗戀班上正妹但不敢講，拜託正妹的閨密轉交情書，正妹只知道情書來自閨密轉交但不知道是誰送的(除非閨密把我賣了) 閨密對我而言就是正向代理(前向代理) 反向代理，例如某殺手組織內有多個專業殺手，跟一個對外的業務窗口。當委託人想下任務只能找到窗口，而組織內的任務實際由哪位殺手完成外人無從得知。委託人最終只知道任務的結果 窗口對於殺手組織而言就是反向代理 目的: 負載均衡、安全(對外只暴露一個IP，內部伺服器真實網址別人不知道) 模擬部署 首先docker拉一個nginx，並且把設定檔文件夾掛載出來，方便修改 乍看有點混亂，nginx.conf是主配置檔 而conf.d是子資料夾，裡面可以放多個xxx.conf，為從配置 第三個掛載是為了放html靜態資源 最後一個是log docker run -p 80:80 --name nginx -v /mydata/nginx/nginx.conf:/etc/nginx/nginx.conf -v /mydata/nginx/conf.d:/etc/nginx/conf.d -v /mydata/nginx/html:/usr/share/nginx/html -v /mydata/nginx/logs:/var/log/nginx -d nginx 為了模擬DNS的效果，用SwitchHosts修改本機 SwitchHosts: https://github.com/oldj/SwitchHosts/releases 進到虛擬機，修改nginx轉發的規則，讓它指向本機IP 把服務都開起來，有點樣子了 其實目前只是繞一圈回來，接著再來設定網關 結合網關 大的HTTP 使用nginx注意{}閉合與結尾的; 小的Server 通過nginx的時候，會把請求頭裡面很多訊息都削掉 所以這邊要手動把頭加回去，否則下面的網關沒辦法靠Host=XX來辨識斷言 把檔案名稱保存為mall.conf 網關 - id: mall_host_route uri: lb://product predicates: - Host=**.mall.com,mall.com 域名映射最終效果 訪問mall.com透過DNS(假的，現在通過改HOST充當)轉到server對外唯一地址(虛擬機的IP) nginx作為看門保全，把人帶給服務台(網關)，並且這個保全預設會把客人的頭砍了，要設定讓它把頭還回來 到了網關識別客人的host來自mall.com，預設轉發到商品首頁 內部的API請求也一樣，只要域名滿足條件，都可以透過nginx反向代理給網關，網關再負載均衡給各個微服務子模組 壓力測試 找出系統負荷的瓶頸 不測不知道: 記憶體流失(memory leak): 小問題透過大累積才出現 併發: 單機OK，多人play就出事 指標 TPS: Transactions Per Second，每秒處理的事務數目，注意不是指資料庫的那個交易，而是指用戶幹了一件&amp;quot;事&amp;quot;，用來衡量整個業務流程，單位是筆/秒 QPS: Queries Per Second，每秒能處理查詢數目，通常用來衡量接口API的訪問量，單位是次/秒 RT: Response Time，響應時間，用戶發出請求到系統做出反應的間隔，通常會關注90%響應時間，避免考慮極端情況 吞吐量: 處理量，系統每秒能處裡的請求數、任務數 錯誤率: 顧名思義，一批請求中的錯誤比例 壓測工具JMeter 官方下載: https://jmeter.</description>
    </item>
    
    <item>
      <title>JVM模型與GC策略</title>
      <link>https://yoziming.github.io/post/220126-jvm-gc/</link>
      <pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220126-jvm-gc/</guid>
      <description>JVM記憶體模型 GC Garbage Collection 垃圾回收是影響程式效能的重中之重
誰是垃圾? Reachability Analysis 可達性分析: 把所有引用的物件看成一棵樹，從樹的根結點 GC Roots 出發，持續遍歷找出所有連接的樹枝物件，能連到的就是&amp;quot;可達&amp;quot;的存活物件 沒有任何引用相連的就是垃圾 在Java中GC Roots包括: 虛擬機棧中引用的物件 方法區中類靜態屬性實體引用的物件 方法區中常量引用的物件 本地方法棧中JNI引用的物件 引用的擴充 自 JDK 1.2 以後，Java 對引用的概念進行了擴充
String Reference 強引用：類似 &amp;ldquo;Object obj = new Object()&amp;rdquo; 屬於強引用，只有引用還在，垃圾收集器永遠不會回收掉被引用對象 Soft Reference 軟引用：用來描述一些還有用但不是必須的物件。對於軟引用相關的物件，在系統將要發生 OOM（記憶體溢出）時，將會把軟引用對象列進回收範圍並進行二次回收。如果這次回收後還是沒有足夠記憶體才會拋出 OOM 異常 Weak Reference 弱引用：也是用來描述非必須物件，但它的強度比軟引用更弱，被弱引用的對象只會生存到下一次垃圾回收之前。當進行 GC 時，無論當前記憶體是否足夠，都會回收掉弱引用的物件 Phantom Reference 虛引用：又稱幽靈引用或幻影引用，最弱的引用關係。無法通過虛引用獲取物件的實例，為物件設置虛引用唯一的目的就是能在該物件被垃圾收集器回收時收到一個系統通知 清理機制 GC發生在堆HEAP上
新物件創在Eden區，放不下就MinorGC小清理 MinorGC小清理把Eden區中能搬的搬到隔壁Survivor倖存者區 Eden區清了還是放不下，就對倖存者區也MinorGC，嘗試放到倖存者區 每次MinorGC倖存者區中的物件就變老，待在倖存者區太久超過域值，就趕去老年區養老 倖存者區還是放不下，表示是個大物件，嘗試放在老年區 老年區還是放不下，執行大掃除FullGC，來個大風吹 還是放不下，報OOM(OutOfMemory Error)錯誤 算法 GC的算法各有優劣，實際上是綜合使用
我都是把記憶體想像成冰箱的製冰盒，每盤上有一格一格那樣
標記清除（Mark-Sweep） 最簡單直觀，標誰清誰，缺點是會留下空間碎片 複製（Copying） 需要額外一個製冰盒，整理的時候把有用的搬到新家，剩的垃圾整盤丟掉，缺點是空間利用率低 標記整理（Mark-Compact） 在同一盤上把垃圾清掉，有用的搬動，壓縮整理成緊實的一區，缺點是效率低，適合用在老年區</description>
    </item>
    
    <item>
      <title>抽取關鍵字至ES、Thymeleaf模板引擎</title>
      <link>https://yoziming.github.io/post/220126-gulimall-09-thymeleaf/</link>
      <pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220126-gulimall-09-thymeleaf/</guid>
      <description>商品上架 上架，除了把狀態改成上架，為了商品能被快速搜索到，還要提取出關鍵訊息存到ES 簡單來說就是把該商品的sku提取出來，存到ES的index中，當用戶搜索商品時，就可以依照分組動態產生篩選條件，依照得分呈現商品屬性 很繁瑣，但是不難 SpuInfoController.java // 上架 @PostMapping(&amp;#34;/{spuId}/up&amp;#34;) public R spuUp(@PathVariable Long spuId) { spuInfoService.up(spuId); return R.ok(); } SpuInfoServiceImpl.java 知識點:用stream把list轉map // 商品上架 @Override public void up(Long spuId) { // 先從spuID查出對應的所有sku List&amp;lt;SkuInfoEntity&amp;gt; skuInfoEntities = skuInfoService.getSkusBySpuId(spuId); // 先查出當前sku的所有可以被用來檢索的規格屬性 List&amp;lt;ProductAttrValueEntity&amp;gt; baseAttrs = productAttrValueService.baseAttrListforspu(spuId); List&amp;lt;Long&amp;gt; attrIds = baseAttrs.stream().map(ProductAttrValueEntity::getAttrId).collect(Collectors.toList()); // sku當初填值時就有一欄是&amp;#34;是否能被檢索 List&amp;lt;Long&amp;gt; searchAttrIds = attrService.selectSearchAttrs(attrIds); // 轉換為Set集合 Set&amp;lt;Long&amp;gt; idSet = searchAttrIds.stream().collect(Collectors.toSet()); // 過濾留下能被檢索的Attrs List&amp;lt;SkuEsModel.Attrs&amp;gt; attrsList = baseAttrs.stream().filter(item -&amp;gt; { return idSet.contains(item.getAttrId()); }).map(item -&amp;gt; { // 封裝進SkuEsModel.</description>
    </item>
    
    <item>
      <title>商品屬性維護、庫存模組、基礎篇總結</title>
      <link>https://yoziming.github.io/post/220124-gulimall-07/</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220124-gulimall-07/</guid>
      <description>商品屬性維護 spu檢索 一個快速找到API的方法 裝上插件RestfulTool，直接貼上文檔給的URL瞬間就能定位 SpuInfoServiceImpl.java 處理多條件模糊搜索 @Override public PageUtils queryPageByKeyword(Map&amp;lt;String, Object&amp;gt; params) { /* key: &amp;#39;華為&amp;#39;,//檢索關鍵字 catelogId: 6,//三級分類id brandId: 1,//品牌id status: 0,//商品狀態 */ QueryWrapper&amp;lt;SpuInfoEntity&amp;gt; wrapper = new QueryWrapper&amp;lt;&amp;gt;(); String key = (String) params.get(&amp;#34;key&amp;#34;); if (StringUtils.isNotBlank(key) &amp;amp;&amp;amp; !&amp;#34;0&amp;#34;.equalsIgnoreCase(key)) { wrapper.and(w -&amp;gt; { // 模糊搜索為了怕蓋掉下面的所以用and，其實也能放最後就好 // 優先 NOT&amp;gt;AND&amp;gt;OR w.eq(&amp;#34;id&amp;#34;, key).or().like(&amp;#34;spu_name&amp;#34;, key); }); } String status = (String) params.get(&amp;#34;status&amp;#34;); if (StringUtils.isNotBlank(status)) { wrapper.eq(&amp;#34;publish_status&amp;#34;, status); } String catelogId = (String) params.get(&amp;#34;catelogId&amp;#34;); if (StringUtils.isNotBlank(catelogId) &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>array、list多型與BaseMapper之謎</title>
      <link>https://yoziming.github.io/post/220123-array-list-polymorphism/</link>
      <pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220123-array-list-polymorphism/</guid>
      <description>Array Java學著學著，有天用了一下go解題，才驚覺java中很少用Xxx[]，都快忘記為什麼了
數組、陣列，例如Cat[] 長度固定，造的時候就要指定 可以間隔存null 不能泛型、但是協變 String[] is subtype of Object[] 聽說是早期因為沒有泛型所以做的設計，沒人用了 List List本身是接口，無法new List()
ArrayList是它的主要實現類 另一個兄弟是LinkedList(鏈表，在高頻重複拔插有利) 還有一個被遺忘的vector，特色是執行緒安全，但幾乎沒人用 ArrayList 真正最常來當&amp;quot;數組&amp;quot;用的有序列表
長度可變
多型 目的是為了複用性與擴展性
不需要每個子類都造相同的方法 同一個行為具有多個不同表現形式或形態的能力
三個必要條件:
繼承或實現: 總之有上下關係
重寫: 子類中重寫同名方法
父類的引用指向子類: 子類賦給父類，例如List list = new ArrayList()
動態綁定: 在編譯期虛擬調用，在執行期才確定調用的方法
編譯看左，運行看右(子類) 靜態多型: 成員屬性與靜態方法看父類的(左邊)
結論: new誰就調用誰的方法，引用是誰，就用誰的成員和靜態
接口與類的關係 https://www.zhihu.com/question/19890792
Class （類）是一張圖紙——比如 F16 戰鬥機的設計藍圖 Interface （介面）是一種要求——比如“能發射導彈” Instance （實例）是一個具體的東西——比如一架編號為 A123 的 F16 類可以實現介面，比如—— F16 的設計圖，是一張能夠發射導彈的飛機的設計圖
介面可以用來描述類，比如——這堆飛機設計圖都設計了“發射導彈”這個功能
所以，介面可以用來描述實例，比如—— F16 戰鬥機能發射導彈
現在假設你是個資深飛行員，但不是機械師。也就是說，你知道怎麼讓飛機發射導彈，雖然你不知道怎麼造出一架能發射導彈的飛機。那麼，如果你對機械師說，“給我一架能發射導彈的飛機”，你其實並不在乎他給你的究竟是 F15 還是 F16，也不關心這架飛機具體怎麼實現”發射導彈“這個功能，只要它能發射導彈就好。
Java8特性: 接口中定義的靜態方法，只能透過接口去調用(類似工具類) 預設方法:使用default修飾，實現類的物件，可以調用接口中的預設方法；若實現時重寫了方法，那調用的還是重寫的方法。只是說用default修飾，可以免去把抽象方法一一實現的過程而直接調用預設的方法 BaseMapper之謎 在MybatisPlus中，為何只要繼承了BaseMapper，就能@Autowired出那個接口的&amp;quot;實例&amp;quot;然後執行各種方法，往上查BaseMapper只是繼承了一個空的Mapper，他們都是接口沒看到實現類，這是什麼巫術?</description>
    </item>
    
    <item>
      <title>保存sku、spu，feign遠程調用</title>
      <link>https://yoziming.github.io/post/220123-gulimall-06-feign/</link>
      <pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220123-gulimall-06-feign/</guid>
      <description>銷售屬性 AttrController.java 獲取的API跟先前幾乎一樣，所以改造之前的queryBasePageCatelogId，順便換名字 /** * 規格參數列表 */ @GetMapping(&amp;#34;/{attrType}/list/{catelogId}&amp;#34;) //@RequiresPermissions(&amp;#34;product:attr:list&amp;#34;) public R baseAttrList(@RequestParam Map&amp;lt;String, Object&amp;gt; params, @PathVariable(&amp;#34;catelogId&amp;#34;) Long catelogId, @PathVariable(&amp;#34;attrType&amp;#34;) String attrType ) { PageUtils page = attrService.queryBaseAttrPage(params, catelogId, attrType); return R.ok().put(&amp;#34;page&amp;#34;, page); } AttrServiceImpl.java @Override public PageUtils queryBaseAttrPage(Map&amp;lt;String, Object&amp;gt; params, Long catelogId, String attrType) { QueryWrapper&amp;lt;AttrEntity&amp;gt; qw = new QueryWrapper&amp;lt;&amp;gt;(); // 判斷是要銷售還是基本屬性，1=基本，0=銷售 qw.eq(&amp;#34;attr_type&amp;#34;, &amp;#34;base&amp;#34;.equalsIgnoreCase(attrType) ? 1 : 0); 順便修改保存方法 為了不留技術債(只有自己知道的神秘代號)，新增一個枚舉類來表示 把剛剛用的1、0都換成ProductConstant.ATTR_TYPE_BASE.getCode() 查詢、修改的方法也都判斷一下是基本屬性才往下做 分組關聯 接口API: 沒有多的屬性，可以直接用AttrEntity作為DATA返回 AttrGroupController.java 注意調用的是attrService /** * 根據分組ID查找關聯 * * @param attrgroupId * @return */ @GetMapping(&amp;#34;/{attrgroupId}/attr/relation&amp;#34;) public R attrRelation(@PathVariable(&amp;#34;attrgroupId&amp;#34;) Long attrgroupId) { List&amp;lt;AttrEntity&amp;gt; entities = attrService.</description>
    </item>
    
    <item>
      <title>Java中finally與return的順序</title>
      <link>https://yoziming.github.io/post/220122-java-try-finally-return/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220122-java-try-finally-return/</guid>
      <description>直接上結論 總之finally都會在最後執行 不管有沒有出現異常，finally塊中代碼都會執行 當try和catch中有return時，finally仍然會執行 finally是在return後面的運算式運算之後執行的 return的先後涉及值改變的情況 try語句在返回前，將其他所有的操作執行完，保留好要返回的值，而後轉入執行finally中的語句，而後分為以下三種情況
情況一：如果finally中有return語句，則會將try中的return語句“覆蓋”掉，直接執行finally中的return語句，得到返回值，這樣便無法得到try之前保留好的返回值。
情況二：如果finally中沒有return語句，也沒有改變要返回值，則執行完finally中的語句後，會接著執行try中的return語句，返回之前保留的值。
情況三：如果finally中沒有return語句，但是改變了要返回的值，這裡有點類似與引用傳遞和值傳遞的區別，又分以下兩種情況
如果return的資料是基底資料型別或文本字串，則在finally中對該基本資料的改變不起作用，try中的return語句依然會返回進入finally塊之前保留的值
如果return的資料是引用資料類型，而在finally中對該引用資料類型的屬性值的改變起作用，try中的return語句返回的就是在finally中改變後的該屬性的值</description>
    </item>
    
    <item>
      <title>後台-商品屬性，多對多非外鍵表操作</title>
      <link>https://yoziming.github.io/post/220122-gulimall-05-sku-spu/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220122-gulimall-05-sku-spu/</guid>
      <description>後台-商品屬性 先認識名詞
SPU（Standard Product Unit） 「標準產品單位」，是商品資訊聚合的最小單位，是一組可複用、易檢索的標準化資訊的集合，該集合描述了一個產品的特性，例如: 「iPhone 13」 SKU（Stock Keeping Unit） 「最小庫存單位」，對應具體規格的商品，即貨號（或料號），例如: 「iPhone 13(256G)」、「潮男衝鋒衣-M-Blue」 既然是商城項目，現在需要呈現幾種關聯: 選中一個品牌，他有哪些品項的產品，例如: 蘋果:手機、平板&amp;hellip; 選中一個品項(分類)，裡面有他的規格等參數，例如: 手機{CPU:高通880, 尺寸:6吋&amp;hellip;} 選中一個SPU，他有那些共通屬性，例如: iPhone 13的廠商都是蘋果、作業系統都是IOS&amp;hellip; 選中一個SKU，有哪些獨特屬性，例如: 顏色、有多少庫存&amp;hellip; 以上有些是多對多的關係，還挺複雜的，一一拆解來實現 標題大綱是學習的知識點 資料庫表的名詞對應 我直到跟著做完整個商品管理，才弄清他資料庫設計背後的商業邏輯，因為沒有外鍵又要多對多關聯，整個挺複雜的，這塊是難點
brand = 品牌，一個品牌之下可能存在多個category 蘋果 有 手機、平板 在品牌中操作關聯 = 操作pms_category_brand_relation category = 分類，品項 attr_group = 屬性分組 隸屬於某個category之下 例如: 手機的基本信息集合(裡面有長寬、大小、材質等等) attr = 屬性 隸屬於某個category之下，例如: 手機的外殼有白色、黑色 其中attr_type = 1 表示基本屬性(規格參數)，例如: 三星S21的充電口是typeC(每個型號都一樣) 其中attr_type = 0 表示銷售屬性，例如哀鳳13的顏色(有多種對應的貨號) 屬性不一定有分組，因為他建立的時候不一定要填 建立關聯就是操作pms_attr_attrgroup_relation這張表 可以在規格參數頁面中對某條參數修改，指定他屬於某分組 也可以在分組頁面中將同品項未納入分組的屬性關聯到旗下 父子節點訊息傳遞 首先從品項出發，要呈現的效果是這樣 左邊的品項三級分類直接拿先前做好的來用
attrgroup是父節點，引用了&amp;quot;../common/category&amp;quot;用來顯示三級分類
../表示上一層 .</description>
    </item>
    
    <item>
      <title>逆向生成前端頁面、JSR303、雲儲存圖片</title>
      <link>https://yoziming.github.io/post/220121-gulimall-04-jsr303/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220121-gulimall-04-jsr303/</guid>
      <description>逆向生成前端頁面 首先一樣造出側邊欄 找到當初生成器產的那些，好樣的原來當初都一併造了，通通複製過去 另外去前端把權限驗證先暫時關了，全部返回true 查看效果，什麼新增修改基本的CRUD人家全做好了，哭阿 簡單修飾 顯示狀態換成開關 去餓了嗎找模板 :active-value，:是v-bind縮寫 相當於把showStatus的值在1跟0切換，而showStatus本就是pojo的屬性，所以直接傳給後端API就完事 &amp;lt;el-table-column prop=&amp;#34;showStatus&amp;#34; header-align=&amp;#34;center&amp;#34; align=&amp;#34;center&amp;#34; label=&amp;#34;顯示狀態&amp;#34; &amp;gt; &amp;lt;template slot-scope=&amp;#34;scope&amp;#34;&amp;gt; &amp;lt;el-switch v-model=&amp;#34;scope.row.showStatus&amp;#34; active-color=&amp;#34;#13ce66&amp;#34; inactive-color=&amp;#34;#ff4949&amp;#34; :active-value=&amp;#34;1&amp;#34; :inactive-value=&amp;#34;0&amp;#34; @change=&amp;#34;updateBrandStatus(scope.row)&amp;#34; &amp;gt;&amp;lt;/el-switch&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/el-table-column&amp;gt; 下面綁定一個監聽@change的方法，調用後端API更新 updateBrandStatus(data) { console.log(&amp;#34;最新信息&amp;#34;, data); let { brandId, showStatus } = data; //發送請求修改狀態 this.$http({ url: this.$http.adornUrl(&amp;#34;/product/brand/update/status&amp;#34;), method: &amp;#34;post&amp;#34;, data: this.$http.adornData({ brandId, showStatus }, false), }).then(({ data }) =&amp;gt; { this.$message({ type: &amp;#34;success&amp;#34;, message: &amp;#34;狀態更新成功&amp;#34;, }); }); }, 後端手動造一個API去更新 /** * 切換顯示狀態 */ @RequestMapping(&amp;#34;/update/status&amp;#34;) //@RequiresPermissions(&amp;#34;product:brand:update&amp;#34;) public R updateStatus(@RequestBody BrandEntity brand) { brandService.</description>
    </item>
    
    <item>
      <title>後台:商品分類、網關轉發微服務、跨域</title>
      <link>https://yoziming.github.io/post/220120-gulimall-03-gateway/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220120-gulimall-03-gateway/</guid>
      <description>後台頁面 別的項目學過了，這邊快速跳過，只記幾個新知識
計算屬性與監聽器 過濾器 組件化 可以復用的模板
沒有el屬性，不與頁面中的元素綁定 template就是他的HTML模板 data()必須是一個函數而非物件 局部組件 用componments聲明，其中的key名就是標簽名 生命週期 參考 https://book.vue.tw/CH1/1-7-lifecycle.html 腳手架創建表單 之前這邊手動要先去router創建右邊的導航欄，腳手架可以用可視化工具直接創造，非常方便 自己要實現的部分只剩接後端API的網址與資料呈現 javax問題 啟動renren-fast服務時因為引用了common模組(為了讓後台的server也能上nacos服務發現)，又出了點問題，排查了半天 package javax.validation.constraints does not exist 解法: &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-validation&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 我感覺人人開源這個項目已經跟不上時代了，網路上目前2022年1月比較推薦的是若依腳手架，他這個star超高全站第2，也有一直在維護，issue處理很積極，有機會嘗試看看 https://gitee.com/y_project/RuoYi 後端 現在要實現在後台檢視商品列表功能，進到product模組的controller，寫查詢的控制器與服務、實現類 要返回的資料是這種表格 三級樹形列表，老師這邊一次sql查出全部資料然後用stream工具類操作賦好值，實在太強。我想看懂就花了大半天，還是老實for循環，或是多查幾次SQL吧&amp;hellip; /** * 三級樹型列表 * * @return */ @Override public List&amp;lt;CategoryEntity&amp;gt; listTree() { // 查所有分類 List&amp;lt;CategoryEntity&amp;gt; entities = baseMapper.selectList(null); // lamdba表達式左邊形參，右邊方法 List&amp;lt;CategoryEntity&amp;gt; levelMenus = entities.stream() .filter(e -&amp;gt; e.getParentCid() == 0) // 先篩出第一級，set他的子級，調用下面的方法 .map((menu) -&amp;gt; { menu.setChildren(findChildren(menu, entities)); return menu; }) .</description>
    </item>
    
    <item>
      <title>服務註冊nacos、feign、Gateway</title>
      <link>https://yoziming.github.io/post/220119-gulimall-02-nacos/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220119-gulimall-02-nacos/</guid>
      <description>SpringCloud自由配 結合SpringCloud Alibaba最終的技術搭配方案
SpringCloud Alibaba - Nacos: 註冊中心 (服務發現/註冊) SpringCloud Alibaba- Nacos: 配置中心 (動態配置管理) SpringCloud Ribbon: 負載均衡 SpringCloud Feign: 聲明式HTTP客户端(調用遠程服務) SpringCloud Alibaba - Sentinel: 服務容錯(限流、降級、熔斷) SpringCloud Gateway: API 網關 (webflux 編程模式) SpringCloud Sleuth: 調用鏈監控 SpringCloud Alibaba - Seata: 原Fescar, 即分佈式事務解決方案 版本需求關係 SpringCloud 版本配不上，開都開不起來
https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E
Nacos註冊 https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html
導依賴 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.6.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; docker啟動nacos --env 配置環境 MODE=standalong 單節點 --name nacos 映象名稱為nacos -d 背景啟動 # 拉映像 docker pull nacos/nacos-server # 啟動容器 docker run --env MODE=standalone --name nacos -d -p 8848:8848 -e JVM_XMS=256m -e JVM_XMX=256m -e JVM_XMN=256m -e JVM_MMS=256m nacos/nacos-server 這東西不限制會吃超多記憶體 預設網址為localhost:8848/nacos，帳號密碼都是nacos 註冊服務 在應用的 /resource /application.</description>
    </item>
    
    <item>
      <title>項目簡介 &amp; 環境搭建</title>
      <link>https://yoziming.github.io/post/220118-gulimall-01/</link>
      <pubDate>Tue, 18 Jan 2022 12:00:00 +0800</pubDate>
      
      <guid>https://yoziming.github.io/post/220118-gulimall-01/</guid>
      <description>項目簡介 市面上常見的電商模式
B2B(Business to Business)是指商家和商家建立的商業關係
B2C(Business to Consumer)就是我們經常看到的供應商直接把商品賣個用户，也就是商業零售，直接面向消費銷售產品和服務
C2B(Customer to Business)即消費者對企業，先有消費者需求產生而後有企業生產，即先有消費者提出需求，後又生產企業按需求組織生產
C2C(Customer to Consumer)客户之間把自己的東西放到網上去賣
O2O(Online To Offline)將線下商務的機會與互聯網結合在一起，讓互聯網成為線下交易前台，線上快速支付線下優質服務，如UBER
穀粒商城是一個B2C模式的電商平台
項目架構圖 微服務劃分圖 項目技術&amp;amp;特色 前後分離開發，並開發基於 vue 的 後台管理系統 SpringCloud 全新的解決方案 應用監控、限流、網關、熔斷降級、等分佈式方案，全方位涉及 透徹講解分佈式事務，分佈式鎖等分佈式系統的難點 壓力測試與性能優化 各種集群技術的區別以及使用 CI/CD 使用 環境搭建 安裝linux虛擬機 下載VirtualBox
https://www.virtualbox.org/ 下載Vagrant
https://www.vagrantup.com/downloads.html 使用Vagrant快速建立linux虛擬機，打開window cmd或power shell
// 初始化一個centos系統，看到Machine booted and ready!就是完成了 Vagrant init centos/7 // 啓動虛擬機 vagrant up // 重啟 vagrant reload // 連線至vagrant vagrant ssh // 上傳文件 vagrant upload source [destination] [name|id] 預設系統root用户的密碼是vagrant 預設在C:/user/username下會有Vagrantfile檔案，這裡可以設定虛擬機 為了讓虛擬機IP固定，先查找本機分配給虛擬網卡的IP，通常是192.</description>
    </item>
    
    <item>
      <title>醫院管理API &amp; 服務註冊與發現</title>
      <link>https://yoziming.github.io/post/220118-agg-spring-08/</link>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220118-agg-spring-08/</guid>
      <description>醫院管理系統 hospital-manage醫院管理系統，是一個已經完成的模組，功能是提供給醫院方操作，讓醫院管理人員上傳醫院的科室、排班資訊等等的一個小系統 我們的項目是預約掛號平台，要實現求診者與醫院的配對 現在就要模擬實際業務，參考提供的API文檔完成對接 連接MongoDB 練習點，這邊把醫院方上傳的資料存到mongoDB
回到service-hosp模組，先去application.properties設定資料庫連線地址 建立接口繼承MongoRepository @Repository public interface HospitalRepository extends MongoRepository&amp;lt;Hospital, String&amp;gt; {} 建立HospitalServiceImpl接口與實現類、ApiController開始對接API 上傳醫院 控制層知識點: request.getParameterMap()拿到的是String[]，最好轉成Obj方便後續操作 這邊用了base64編碼傳了一張圖片，&amp;quot;+&amp;ldquo;變成了&amp;rdquo; &amp;ldquo;空白要還原 之後用&amp;lt;img src=&amp;quot;data:image/png;base64,編碼串&amp;quot;/&amp;gt;可以把圖片還原顯示出來 @ApiOperation(&amp;#34;上傳醫院&amp;#34;) @PostMapping(&amp;#34;saveHospital&amp;#34;) public Result saveHospital(HttpServletRequest request) { Map&amp;lt;String, String[]&amp;gt; parameterMap = request.getParameterMap(); // 調用工具類把map中的string[]轉成obj Map&amp;lt;String, Object&amp;gt; stringObjectMap = HttpRequestHelper.switchMap(parameterMap); // base64編碼傳送過程中把&amp;#34;+&amp;#34;變成了&amp;#34; &amp;#34;空白，要轉換回來 String logoData = (String) stringObjectMap.get(&amp;#34;logoData&amp;#34;); logoData = logoData.replaceAll(&amp;#34; &amp;#34;, &amp;#34;+&amp;#34;); stringObjectMap.put(&amp;#34;logoData&amp;#34;, logoData); return hospitalService.save(stringObjectMap) ? Result.ok() : Result.build(230, &amp;#34;醫院編號已存在，修改請聯絡工程師&amp;#34;); } 服務層 他教學這邊用alibaba.fastjson包把stringObjectMap轉成JSON，再從JSON轉回Bean，把我看暈了 幹嘛不乾脆用apache.commons.beanutils的populate 後來發現mybatis+自帶BeanUtils.mapToBean也可以，還少導依賴 MD5加密跟修改上傳也把我看暈了，他教學這裡有點瑕疵，反正原理能懂，暫時跳過吧 @Override public boolean save(Map&amp;lt;String, Object&amp;gt; stringObjectMap) { // 將map轉成Hospital實體類物件 // String string = JSONObject.</description>
    </item>
    
    <item>
      <title>MongoDB</title>
      <link>https://yoziming.github.io/post/220117-agg-spring-07-mongodb/</link>
      <pubDate>Mon, 17 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220117-agg-spring-07-mongodb/</guid>
      <description>MongoDB 茫狗DB
屬於NoSQL，非關聯式 以JSON的格式儲存資料 強處:高併發讀寫、巨量資料、擴展好 弱點:交易 前置 # 拉取鏡像 docker pull mongo:latest # 創建和啓動容器 docker run --name mymongo -p 27017:27017 -d mongo # 進入容器 docker exec -it mymongo /bin/bash # 使用MongoDB客户端進行操作 mongo 庫操作 // Help查看命令提示 db.help() // 切換/創建資料庫(如果不存在就創建) use test // 查詢所有資料庫 show dbs // 刪除當前使用資料庫 db.dropDatabase() // 查看當前使用的資料庫 db 或 db.getName() // 顯示當前db狀態 db.stats() // 當前db版本 db.version() // 查看當前db的鏈接機器地址 db.getMongo() 剛建立的db在show看不到，直到其中存了實際的資料才算數 命名限制 不能是空字符串&amp;quot;&amp;quot; 不得含有&#39; &#39;(空格)、.、$、/、\和\0 (空字符) 避免用_下畫線開頭 應全部小寫 最多64字節 名詞對應 SQL Mongo 解釋/説明 table collection 表/集合 row document 行/文檔，即一筆資料(如:張三&amp;hellip;) column field 字段/域，欄位(如:姓名) index index 索引 join embedded 表連接，MongoDB叫嵌入但略有不同 primary key _id 主鍵，MongoDB自動將_id當主鍵，沒指定就自動創 集合操作 相當於操作&amp;quot;表&amp;quot;</description>
    </item>
    
    <item>
      <title>字典檔模組、Spring Cache&#43;Redis、Nginx</title>
      <link>https://yoziming.github.io/post/220116-agg-spring-06/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220116-agg-spring-06/</guid>
      <description>字典檔 暫時不知道作來幹嘛，就是放一些縣市級分區的資本資料
一樣分前、後端實現功能 顯示列表 後端-建模組 建立service-cmn子模組 複習一下過程，在父節點service右鍵新增 選maven，無原型，用-命名，選Parent，其他不動 到pom.xml中 刪除 &amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt; 加入描述 &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;service-cmn&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;service-cmn&amp;lt;/description&amp;gt; 把servicehosp整包複製過來，取完整新包名yoziming.ad.servicecmn，開始改造名稱 可以用重命名功能與大量取代，注意大小寫與範圍 查到mybatis plus有自動生成功能，但看了一下有點亂，用複製的挺穩也快，先將就吧 最後記得對子模組右鍵，引入框架支援 看到application.properties裡面是灰的就要想到這點 裡面連的庫名與服務端口、服務名要改 swagger的@Api註解value與tags的區別 value用於描述 tags用於分組，類的tag會覆蓋方法的 後端-寫接口 // DictController @Api(value = &amp;#34;數據字典&amp;#34;, tags = &amp;#34;數據字典&amp;#34;) @RestController @RequestMapping(&amp;#34;/admin/cmn/Dict&amp;#34;) @CrossOrigin public class DictController { @Autowired private DictService dictService; @ApiOperation(&amp;#34;根據id查詢子數據列表&amp;#34;) @GetMapping(&amp;#34;getAllChildDictById/{id}&amp;#34;) public Result getAllChildDictById(@PathVariable Long id) { return Result.ok(dictService.getAllChildDictById(id)); } } // DictServiceImpl @Service public class DictServiceImpl extends ServiceImpl&amp;lt;DictMapper, Dict&amp;gt; implements DictService { // 判斷id下面是否還有子節點 private boolean hasChildren(long id) { QueryWrapper&amp;lt;Dict&amp;gt; qw = new QueryWrapper&amp;lt;&amp;gt;(); // 以自己為爸爸查兒子數量 qw.</description>
    </item>
    
    <item>
      <title>前端:後臺模板vue-admin-template</title>
      <link>https://yoziming.github.io/post/220115-agg-spring-05/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220115-agg-spring-05/</guid>
      <description>後臺模板 非常經典的模板，被用的很廣泛
倉庫 https://github.com/PanJiaChen/vue-admin-template 解壓縮下載來的vue-admin-template-master，取個好名字放到自己的專案路徑下 進到資料夾，執行npm install安裝依賴 依賴除錯 課件給的老板本用起來很多錯誤，需要手動排查
// 載都沒載直接報錯停止，可能是npm版本太高，降版本: npm install npm@6.14.10 -g /* node-sass問題，報錯為 node-sass@4.14.1 postinstall: `node scripts/build.js` node-sass跟Node.js版本有很大關係，不相容的時候可以這樣 */ npm install gulp-sass --save-dev npm install node-sass@latest // 清除緩存 npm cache clean --force 都沒問題使用npm run dev就能啟動了 後來我是去它倉庫抓4.4版本的，依賴都沒報錯，也不用修改登入接口那些 開始搭建 新增側邊欄 左邊那些表在vue中對應叫router，修改/src/router/index.js綁定要顯示的項目 @/是設定好的別名，表示/src路徑之下 然後在view中添加要顯示的內容，新增檔案後輸入veu+table就能產生模板 串接api 到@/api下編輯接口，複製一個預設的來改，點進去發現第一行import request from &#39;@/utils/request&#39;是已經引用好axios了 但是他這邊request.js裡面成功代號預設是20000，如果與後端用的不同要自己修改 改這個最好用全局取代，因為還有其他比如登入也用到這個代碼，要統一改 修改下面的請求方法，與後端api的URL對接 import request from &amp;#39;@/utils/request&amp;#39; export default { findPageHospitalSet(current, limit, searchObj) { return request({ // ES6特性，反引號包裹強化字串 url: `http://localhost:8201/admin/hosp/hospitalSet/findPageHospitalSet/${current}/${limit}`, // url: `/admin/hosp/hospitalSet/findPageHospitalSet/${current}/${limit}`, method: &amp;#39;post&amp;#39;, // data表示使用json傳遞給後端的@RequestBody data: searchObj }) } } 暫時先用完整的url跳過需要關閉mock與跨域問題 修改請求端口號 留坑，暫時先用完整的url跳過需要關閉mock與跨域問題</description>
    </item>
    
    <item>
      <title>醫院設定模組、swagger2、統一返回/異常/日誌</title>
      <link>https://yoziming.github.io/post/220113-agg-spring-03/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220113-agg-spring-03/</guid>
      <description>搭建醫院設定模組 service-hosp，提供查詢與管理醫院設定
首先父節點service的pom已經將model設為依賴，可以引用其下的實體類model 進到service-hosp修改pom，引用spring-boot-maven-plugin，讓maven打包的時候把依賴也包進去，包成一個可以直接執行的jar包 添加application.properties，指定服務連接的名稱、端口、資料庫連接等等 # 服務端口 server.port=8201 # 服務名 spring.application.name=service-hosp # 環境設置：dev、test、prod spring.profiles.active=dev # mysql資料庫連接 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/yygh_hosp?characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=1234 #返回json的全局時間格式 spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 創建當前包servicehosp，加入啟動類 package yoziming.ad.servicehosp @SpringBootApplication public class ServiceHospApplication { public static void main(String[] args) { SpringApplication.run(ServiceHospApplication.class, args); } } 在yoziming.ad.servicehosp包下新增三個包controller、mapper、service，實現mybatis+的要求以執行CRUD操作 mapper下新增接口，繼承BaseMapper&amp;lt;bean&amp;gt; @Mapper public interface HospitalSetMapper extends BaseMapper&amp;lt;HospitalSet&amp;gt; { } service下新增接口，繼承IService&amp;lt;bean&amp;gt; public interface HospitalSetService extends IService&amp;lt;HospitalSet&amp;gt; { } service下再增加impl包，放實現類，繼承ServiceImpl&amp;lt;剛創的Mapper,bean&amp;gt;，實現接口 @Service public class HospitalSetServiceImpl extends ServiceImpl&amp;lt;HospitalSetMapper, HospitalSet&amp;gt; implements HospitalSetService { } Controller綁定網址，注入service，即可開始業務邏輯 @RestController @RequestMapping(&amp;#34;/admin/hosp/hospitalSet&amp;#34;) public class HospitalSetController { // 注入service @Autowired private HospitalSetService hospitalSetService; // 查詢醫院表所有訊息 @GetMapping(&amp;#34;findAll&amp;#34;) public List&amp;lt;HospitalSet&amp;gt; findAllHospitalSet(){ return hospitalSetService.</description>
    </item>
    
    <item>
      <title>MyBatis-Plus快速上手</title>
      <link>https://yoziming.github.io/post/220112-agg-spring-02-mybatis-plus/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220112-agg-spring-02-mybatis-plus/</guid>
      <description>MyBatis-Plus 非常好用的ORM框架
https://baomidou.com/ 它官網目前2022年1月是最新3.5.0版本，以下基於此版本與MySQL 8演示 依賴 &amp;lt;!--mybatis-plus--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--mysql依賴--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok用來簡化實體類--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring-boot-starter 如果沒有要加--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; application.properties #MySQL 8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=1234 #mybatis日誌，開啟後更好查看SQL操作 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 綁定Mapper 最傳統是在xml中一個一個綁定bean的屬性與資料庫的表格，Mapper就是他們的映射關係。
在MyBatis-Plus中只要繼承他封裝好的BaseMapper就能直接開始CRUD
在實體類(pojo/bean/entity)的包下先建立對應的實體類(例如User.java)，用@Data標記讓Lombok快速生成，不用Lombok就自己手動生成setter那些
@Data public class User { 創建包名mapper，下面建立對應的Mapper接口，繼承BaseMapper&amp;lt;User&amp;gt;，泛型&amp;lt;&amp;gt;中放bean，並用@Repository標記(為了後面測試生成實例時不泛紅報錯)，例如:
@Repository public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; { } 到springboot主入口，綁定@MapperScan，例如:
@SpringBootApplication @MapperScan(&amp;#34;com.example.demo.mapper&amp;#34;) public class DemoApplication { public static void main(String[] args) { SpringApplication.</description>
    </item>
    
    <item>
      <title>Spring框架、預約就醫項目</title>
      <link>https://yoziming.github.io/post/220112-agg-spring-01/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220112-agg-spring-01/</guid>
      <description>本筆記基於:尚医通项目:尚硅谷Java微服务+分布式+全栈项目【尚医通】 https://www.bilibili.com/video/BV1V5411K7rT
Spring 輕量(檔案才幾MB)的開源框架，用以簡化開發過程 最主要目的就是降低耦合 非侵入式:框架的API不會出現在業務邏輯中，業務邏輯本身是乾淨的方便轉移 容器:用容器管理物件的生命週期與依賴關係 Spring的核心為IoC與Aop IoC Inversion of Control，直譯控制反轉不好理解，其實就是一種依賴關係的轉移 傳統方法例如&amp;quot;貓叫&amp;quot;，我要先造一隻貓，然後讓貓執行叫方法 現在反過來，我從&amp;quot;叫&amp;quot;出發，告訴容器要執行叫的是一隻貓，這個貓由容器來提供 如果想換成&amp;quot;狗叫&amp;quot;，我一樣是從叫出發，只是跟容器說現在要給我狗 如此一來，降低了耦合(不需要親自造貓用貓)，提高了復用性(一個叫不僅貓狗，雞豬牛羊都行) 傳統依賴關係是需要先主動造貓或造狗之後用來叫，現在反過來從&amp;quot;叫&amp;quot;讓容器造對應的物件去想叫的地方，所以說是控制反轉 DI IoC算是一個思想，實作上Spring使用DI將其實現
Dependency Injection，依賴注入，是IOC思想的具體實現，即由容器建立物件，並且把物件注入到要用的地方
被依賴物件透過外部注入至依賴物件的地方使用
就是把物件實例化交給框架管理
本來Book book = new Book()
現在用工廠代理+反射交給框架創建，降低耦合
Bean管理 Spring的Bean管理，流程分為創建物件與注入屬性
想造物件首先要有一個工廠，Spring提供有兩種:
BeanFactory:框架內部用的接口，在獲取物件時才創物件
ApplicationContext:是BeanFactory的子接口，在加載時就創好物件，一般用的都是這個
AOP Aspect-Oriented Programming 切面導向程式設計，它的目的在於將許多的共同方法抽離出來，與物件導向程式設計類似，但AOP 與OOP 不同的地方就在於，AOP 不用原方法呼叫共同方法，只需要指定執行共同方法的時機點即可。 不好理解，看專業的說明吧 https://ithelp.ithome.com.tw/articles/10229664 練習項目簡介 查了一下中國看病還挺不方便的，難掛號、難排隊、看診前還要先付錢，沒繳錢不看
尚醫通即為網上預約掛號系統，網上預約掛號是近年來開展的一項便民就醫服務，旨在緩解看病難、掛號難的就醫難題，許多患者為看一次病要跑很多次醫院，最終還不一定能保證看得上醫生。網上預約掛號全面提供的預約掛號業務從根本上解決了這一就醫難題。隨時隨地輕鬆掛號！不用排長隊！ 本項目技術棧如下: 後端技術 SpringBoot：簡化新Spring應用的初始搭建以及開發過程
SpringCloud：基於Spring Boot實現的雲原生應用開發工具，SpringCloud使用的技術：（SpringCloudGateway、Spring Cloud Alibaba Nacos、Spring Cloud Alibaba Sentinel、SpringCloud Task和SpringCloudFeign等）
MyBatis-Plus：持久層框架
Redis：記憶體緩存
RabbitMQ：消息仲介軟體
HTTPClient: Http協議用戶端
Swagger2：Api介面文檔工具
Nginx：負載均衡
Lombok
Mysql：關係型資料庫
MongoDB：面向文檔的NoSQL資料庫
前端技術 Vue.</description>
    </item>
    
    <item>
      <title>JSON、AJAX、i18n</title>
      <link>https://yoziming.github.io/post/220111-agg-javaweb-11/</link>
      <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220111-agg-javaweb-11/</guid>
      <description>JSON JavaScript Object Notation
輕量(相較於xml)的資料交換格式 用一對大括號{}包裹，中間以:分隔鍵值對，用,分隔多對 裡面可以放: 數字(整數或浮點數，可用e表示指數)，不能是NaN 字串(用&amp;quot;&amp;quot;包裹) 布林值(boolean) (true 或 false) 陣列(用[]包裹) 物件 (用{ }套娃) null javaScript中 &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var jsonObj = { &amp;#34;key1&amp;#34;: 123, &amp;#34;key2&amp;#34;: &amp;#34;abc&amp;#34;, &amp;#34;ket3&amp;#34;: [&amp;#34;中&amp;#34;, &amp;#34;文&amp;#34;] }; alert(jsonObj.ket3) var jsonString = JSON.stringify(jsonObj); alert(jsonString); var jsonObj2 = JSON.parse(jsonString); &amp;lt;/script&amp;gt; JSON可以是: 物件，用於操作 字串，用於傳遞 用JSON.stringify()與JSON.parse()方法互相轉換 Java中 要引用第三方包，例如Gson或Jackson Gson範例: @Test public void test1() { User user = new User(&amp;#34;zhung3&amp;#34;, &amp;#34;pass123&amp;#34;, &amp;#34;zhung3@goo.com&amp;#34;); Gson gson = new Gson(); String userString = gson.</description>
    </item>
    
    <item>
      <title>Filter過濾器、ThreadLocal</title>
      <link>https://yoziming.github.io/post/220110-agg-javaweb-10/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220110-agg-javaweb-10/</guid>
      <description>Filter過濾器 用來修飾請求或響應
在Web資源被訪問前，檢查request物件，修改請求頭和請求正文，或對請求進行預處理操作
將請求傳遞到下一個過濾器或目標資源
在Web資源被訪問後，檢查response物件，修改回應頭和回應正文
常用來做權限控管、設定統一編碼等等
方法 Filter都是接口，用起來跟servlet一樣需要實現方法
前面都是偷雞造一個base去實現基本的方法然後繼承
init (FilterConfig filterConfig):初始化，由web容器調用
doFilter(ServletRequest request,SeivletResponse response, FilterChain chain):主要方法，在這邊對req或resp毛手毛腳，或是chain.doFilter再傳到下一個過濾器
destroy():釋放被這個filter物件占用的資源，由web容器調用
生命週期 構造、init():跟隨web工程而啟動，被執行一次 doFilter():在每次攔截請求都調用 destrory():跟隨web工程結束而消亡，也只執行一次 FilterConfig 跟Servlet基本一樣
每個Filter都有自己伴生的FilterConfig實例物件，當web容器啟動時一併被創造出來，其中包含了它Filter的訊息
filterconfig.getFilterName():
filterconfig.getInitParameter():取得初始參數(例如寫在web.xml中的&amp;lt;init-param&amp;gt;
filterconfig.getServletContext():也能獲得ServletContext
記住取出的ServletContext context是整個web工程共用的唯一一個 複習:可以用來從url網址取到對應的硬碟路徑， 例如context.getRealPath(&amp;quot;/&amp;quot;) 也可以當map用存setAttribute，與取getAttribute FilterChain 串聯多個過濾器，直到沒有chain.doFilter()，就調用目標資源的service()方法 它的執行順序，類似把doFilter()當作中隔的中序遍歷 F1上半部-F2上半部-資源-F2下半部-F1下半部 F1、F2的順序是由web.xml中標籤上下所決定 如果是用註解的，無法決定順序 實作上，每個過濾器都應該是獨立的，不應受順序影響功能 實作 引用 http://c.biancheng.net/servlet2/filter.html
web.xml &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;myFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;com.MyFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;name&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;我的Filter&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;URL&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;www.MyFilter.net&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;myFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/login&amp;lt;/url-pattern&amp;gt; &amp;lt;dispatcher&amp;gt;REQUEST&amp;lt;/dispatcher&amp;gt; &amp;lt;dispatcher&amp;gt;FORWARD&amp;lt;/dispatcher&amp;gt; &amp;lt;/filter-mapping&amp;gt; 匹配規則 規則跟servlet一樣
規則 範例 可訪問的URL 精確 以/開始，不能包含萬用字元*且必須完全匹配 /myServlet /myServlet 路徑 以/開始，並以/*結尾 /user/ /user/之下都可以 後綴 以*.</description>
    </item>
    
    <item>
      <title>Cookie與Session，書城訂單模組</title>
      <link>https://yoziming.github.io/post/220109-agg-javaweb-09/</link>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220109-agg-javaweb-09/</guid>
      <description>Cookie 因為HTTP是無狀態(stateless)的，當我們想保存資訊就要用到Cookie
伺服器通知客戶端保存鍵值對的技術 白話:叫用戶保存住某個值 應用舉例:記住用戶名 由用戶的瀏覽器維護，視生命週期存在記憶體或硬碟中 單個最多4 KB 使用 很簡單就不多說了
在Java中是Cookie類 protected void doCookie(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 設定編碼 request.setCharacterEncoding(&amp;#34;UTF-8&amp;#34;); response.setContentType(&amp;#34;text/html; charset=UTF-8&amp;#34;); // 在Java造Cookie類物件 Cookie cookie1 = new Cookie(&amp;#34;key1&amp;#34;, &amp;#34;value1&amp;#34;); // 增，注意是response叫客戶端造cookie response.addCookie(cookie1); response.getWriter().write(&amp;#34;cookie創建成功!&amp;#34;); // 取 Cookie[] cookies = request.getCookies(); // 取來的是所有cookies構成的數組 for (Cookie cookie2 : cookies) { response.getWriter().write(cookie2.getName() + &amp;#34;=&amp;#34; + cookie2.getValue() + &amp;#34;\n&amp;#34;); // 可以做些if判斷拿出想要的 } // 改 Cookie cookie3 = new Cookie(&amp;#34;key1&amp;#34;, &amp;#34;value3&amp;#34;); response.</description>
    </item>
    
    <item>
      <title>書城項目:Maven管理依賴、圖書模塊</title>
      <link>https://yoziming.github.io/post/220108-agg-javaweb-08/</link>
      <pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220108-agg-javaweb-08/</guid>
      <description>Maven管理依賴 傳統作法是建一個lib資料夾然後手動引入
項目越多就越麻煩，打包的時候還要注意引用的有沒有包到
專案重構 把專案整個重構，可以先把src下做的那些頁面跟java檔複製出來
第一層最好先造一個空的專案方便命名與分類
如果直接拿第一層的project當同名的module用，我的IDEA偶爾會有奇怪的BUG，生出兩個同名的module 後來知道原因了，就是模組根目錄下的.iml檔案裡面有重復的句子導致，備份後把它刪了讓IDEA重創一份就可 我這邊放尚硅谷課程的練習，所以project就叫atguigu
因為是空的專案，進去之後IDEA馬上會叫你建一個Module，選javaEE，模板選到webapp 如果不想重造，在專案設定 &amp;gt; Facets
右上設定部屬的描述檔案，就是那些web.xml之類 右下決定資源根目錄，如果顯示紅字可以點它自動生成 由於管理選的maven，造出來會自帶一個pom.xml，這個就是maven的設定檔，一個maven專案的標準目錄結構是這樣
點開pom.xml，裡面有一些描述，往下拉到&amp;lt;dependencies&amp;gt;標籤，在這邊告知項目要引用那些包 不像golang在終端輸入go get xxx就完事，maven導包需要寫標籤代碼，但還是能偷懶的，點開中央庫搜尋頁面 https://search.maven.org/#browse 查到想要找的包，對他一通按，點進去要引用的版本 看到右邊，貼心的代碼已經準備好了 愉快的一頓複製貼上之後，回到IDEA刷新maven，他會把這些從中央倉庫引用的jar包下載一份到(預設是我的文件中.m2資料夾)放好 所以第一次可能會比較久一點 之後有引用都是同理，從此不需要手動把jar包放進lib目錄，部屬打包的時候它也會自動去準備配菜 路徑優化 現在Servlet用註解方式引用，解放了web.xml 前端頁面用共通的head.jsp指定了動態的basePath，跳轉主頁的引用直接留空就是指向basePath，例如: &amp;lt;a href=&amp;#34;&amp;#34;&amp;gt;跳轉主頁&amp;lt;/a&amp;gt; &amp;lt;!-- 注意不是&amp;#34;/&amp;#34;，如果用/會回到http://localhost:8080/ --&amp;gt; 綜合以上，tomcat的部屬就不需要修改部屬的地址book_war_exploded/那些了 BeanUtils 用於把前端拿到的參數map，透過反射直接塞進一個bean物件，但是要注意一個字都不能差，大小寫都要對 他賦參數是透過set方法，前面講過bean物件一定要提供set，如果沒有set會失敗 String username=request.getParameter(&amp;#34;username&amp;#34;); String password=request.getParameter(&amp;#34;password&amp;#34;); String email=request.getParameter(&amp;#34;email&amp;#34;); String code=request.getParameter(&amp;#34;code&amp;#34;); User user = new User(); BeanUtils.populate(user,request.getParameterMap()); 比如這邊如果沒有特別需要使用參數去驗證啥的，String username那些都可以省略掉，反正收到ParameterMap就塞成一個bean，完事 圖書模塊 書城項目中有關書籍後台的部分，以MVC模式劃分
Model部分 相當於資料層+業務邏輯層
JavaBean pojo與dao包與他們的Impl實現類
建立資料庫表、決定需要那些欄位、設定約束 建立pojo，也就是對應的bean 建立Dao接口(xxxDao)，列出需要與資料庫互動的功能 實現接口(XxxDaoImpl extends BaseDao implements XxxDao)，實際寫出sql語句、操作資料庫 測試，造一個private XxxDao xxxDao =new XxxDaoImpl()調用看看功能 重點筆記 book的bean // 預設的圖片 private String imgPath=&amp;#34;static/img/default.</description>
    </item>
    
    <item>
      <title>檔案上傳與下載、書城項目優化</title>
      <link>https://yoziming.github.io/post/220107-agg-javaweb-07/</link>
      <pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220107-agg-javaweb-07/</guid>
      <description>檔案上傳 讓用戶從前端上傳一個檔案給伺服器
要有一個 form 標籤，method=post 請求
因為get有長度限制 form標籤的 encType 屬性值必須為 multipart/form-data 值
在 form 標籤中使用 input type=file 添加上傳的檔
編寫伺服器代碼(Servlet 程式)接收，處理上傳的資料
encType=multipart/form-data 表示提交的資料以多段(每一個表單項一個資料段)的形式進行拼接，然後整個以二進位流的形式發送給伺服器
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;#34;http://localhost:8080/book/uploadServlet&amp;#34; method=&amp;#34;post&amp;#34; enctype=&amp;#34;multipart/form-data&amp;#34;&amp;gt; 用戶名：&amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;username&amp;#34; /&amp;gt; &amp;lt;br&amp;gt; 頭像：&amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;photo&amp;#34; &amp;gt; &amp;lt;br&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;上傳&amp;#34;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 創一個UploadServlet用於接收，並且到web.xml綁定，就能用doPost接收這個二進位流 顯然自己解析這個二進位流再拆開費力不討好，這邊用別人造好的輪子 commons-fileupload 導入: commons-fileupload-1.2.1.jar commons-io-1.4.jar ServletFileUpload 類，用於解析上傳的資料。 FileItem 類，表示每一個表單項。 方法 boolean ServletFileUpload.isMultipartContent(request)判斷當前上傳的資料格式是否是多段的格式 public List&amp;lt;FileItem&amp;gt; parseRequest(request)解析上傳的數據 boolean FileItem.isFormField()判斷是否是普通的表單項 true 表示普通類型的表單項 false 表示上傳的檔案類型 String FileItem.</description>
    </item>
    
    <item>
      <title>Listener監聽器、EL表達式、JSTL標籤庫</title>
      <link>https://yoziming.github.io/post/220106-agg-javaweb-06/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220106-agg-javaweb-06/</guid>
      <description>Listener監聽器 是一個接口，用於監聽某種事物的變化 ServletContextListener 監聽器 ServletContextListener 它可以監聽 ServletContext 物件的創建和銷毀。 ServletContext 物件在 web 工程啟動的時候創建，在 web 工程停止的時候銷毀。 監聽到創建和銷毀之後都會分別調用 ServletContextListener 監聽器的方法回饋 兩個方法分別是: public interface ServletContextListener extends EventListener { // 在ServletContext 物件創建之後馬上調用，做初始化 public void contextInitialized(ServletContextEvent sce); // 在ServletContext 物件銷毀之後調用 public void contextDestroyed(ServletContextEvent sce); 使用步驟 編寫一個類去實現 ServletContextListener
實現其兩個回檔方法
到 web.xml 中去配置監聽器
監聽器實現類 public class MyServletContextListenerImpl implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(&amp;#34;ServletContext 對象被創建了&amp;#34;); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(&amp;#34;ServletContext 對象被銷毀了&amp;#34;); } } web.</description>
    </item>
    
    <item>
      <title>JSP</title>
      <link>https://yoziming.github.io/post/220105-agg-javaweb-05/</link>
      <pubDate>Wed, 05 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220105-agg-javaweb-05/</guid>
      <description>JSP Java Server Page
接收請求、處理請求已經了解，現在來到響應的部分 當有人來請求，我們用servlet接收並動態回應，比如想輸出一個html頁面作為結果，servlet可以做到但實現的辦法很蠢，就是靠out.print拼接硬刻出標籤文本格式，改進辦法就是JSP JSP將java &amp;gt; html 的過程包裝起來，可以更好的處理View的部分 底層代碼其實也是拼接，不過Java就是這樣，一層套一層 轉換過程 a.jsp &amp;gt;(被web容器翻譯成servlet) &amp;gt; a_jsp.java &amp;gt; a_jsp.class 然後類似一個servlet的生命週期，不過jsp轉來的有自己的方法名 構造 &amp;gt; _jspInit() &amp;gt; _jspService() &amp;gt; _jspDestroy() JSP與Servlet的異同 引用 https://ithelp.ithome.com.tw/articles/10133506
兩者都是HttpServlet(Servlet API)的子類 URL對應 Servlet的URL對應是需要設定的 但是JSP的對應就是它的實體路徑 如何被載入 Servlet一開始就是被編譯成class檔案，然後被http request的時候在被Web Container掛載進來 JSP是在被第一次呼叫的時候才會被Web Container先翻譯成為Servlet的java寫法，才編譯成為class檔案，放在Web Container一個 暫時的資料夾。雖然第一次執行會比Servlet慢，不過掛載以後就一樣了(因為JSP和Servlet一樣，只會掛載一次) 更新方式 Servlet如果有修改，需要重新編譯，因此需要重啟Web Container的服務 JSP頁面因為Web Container有在監控，因此，只要有修改，他會重新翻譯、編譯然後掛載。因此不需要重啟Web Container就能看到最新修改 JSP過氣? 到了2021年現在技術已經傾向前後端分離，JSP這種從後端響應結果到前端的技術確實已經少用了，但學javaweb作為基礎知識還是很有必要的，畢竟框架例如springMVC也是基於這些技術搭建，夯實地基才能建高樓
檔頭聲明 &amp;lt;!-- 這是 jsp 檔的頭聲明。表示這是 jsp 頁面 --&amp;gt; &amp;lt;%@ page language=&amp;#34;java&amp;#34; contentType=&amp;#34;text/html; charset=UTF-8&amp;#34; pageEncoding=&amp;#34;UTF-8&amp;#34; %&amp;gt; language:值只能是 java。 表示翻譯的得到的是 java 語言的 contentType:設置回應頭 contentType 的內容 pageEncoding:設置當前 jsp 頁面的編碼 import:給當前jsp 頁面導入需要使用的類包 autoFlush:設置是否自動刷新out 的緩衝區，預設為true buffer:設置out 的緩衝區大小。預設為8KB errorPage:設置當前jsp 發生錯誤後，需要跳轉到哪個頁面去顯示錯誤資訊 isErrorPage:設置當前jsp 頁面是否是錯誤頁面。是的話，就可以使用exception 異常物件 session:設置當前jsp 頁面是否獲取session 物件,預設為true extends:給伺服器廠商預留的jsp 預設翻譯的servlet 繼承於什麼類 代碼格式 要啟動一個jsp頁面，需要編寫.</description>
    </item>
    
    <item>
      <title>JavaWeb架構、Servlet頁面轉發</title>
      <link>https://yoziming.github.io/post/220104-agg-javaweb-04/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220104-agg-javaweb-04/</guid>
      <description>JavaWeb的實現 一個web程式分成用戶端(瀏覽器)B與服務端S，搭建代碼實現彼此的請求溝通，要上線一個網站簡單可分成3大步驟
架構:就是寫程式碼，決定用戶端發送怎樣的請求，服務端如何處理、業務邏輯，回應 打包:包成war 部屬:使用web容器(例如tomcat)執行war包，在瀏覽器中訪問指定的網址 MVC架構 MVC是一種設計模式，目的是讓HTML代碼和業務邏輯代碼分開
Model模型，處理應用程式中資料與業務邏輯部分，就是跟資料庫打交道 View檢視，資料顯示部分，給人看的 Controller控制，負責從檢視中讀取資料並向模型傳送資料等。看前台(View)點了啥菜，叫廚房(Model)料理然後擺盤送餐 套用到Java中 用戶端發送請求 服務端的servlet或controller接收請求（路由規則由後端制定，整個專案開發的權重大部分在後端） 調用service、dao代碼完成業務邏輯 返回jsp jsp展現一些動態的代碼 java中的MVC = JavaBean + JSP + Servlet MVC是一個分類的方法，一種設計模式；而實作WEB專案中我們的路徑劃分、包的管理通常是使用三層架構 三層架構 基於業務邏輯來分層
表現層(Presentation Layer) User Show Layer，USL、Client Application，用戶層、UI層
表現層前台: 介面顯示、與用戶互動 JSP、JS、HTML…Web前端技術(通常位於WebContent資料夾) 表現層後台(也有人稱為控制層，但嚴格意義上不能這樣說): 用於控制頁面跳轉、調用業務邏輯層 Servlet、SpringMVC的Controller、Struts2…(xxx.servlet包中) 業務邏輯層(Business Logic Layer) 簡稱BLL或Application Server，AP層、應用層、manage
承上啟下，完成業務邏輯、事務的操作也是在這 工程路徑、包名例如: com.xxx.yyy.service:service層接口 com.xxx.yyy.service.impl:service層實現 資料訪問層(Data Access Layer) 簡稱DAL、Persistence持久層
負責跟資料庫打交道，增刪改查
可能加入ORM(Object Relational Mapping，物件關聯對映)方便操作
工程路徑、包名例如:
com.xxx.yyy.dao:dao接口 com.xxx.yyy.dao.impl:dao實現類 如何理解MVC與三層架構 兩者都是為了高內聚、低耦合 MVC是基於頁面(專門把給人看的東西切成View)將代碼拆解，三層架構是基於業務邏輯分層 這裡學習了Servlet和Jsp，就是為了解決靜態頁面的問題，能夠實現動態的頁面，使維護開發更加的方便，但是也有缺點，在Servlet嵌入HTML代碼實在是太麻煩了，每次都要out.println();輸出。所以就有了Jsp，JSP中的內容就是html，為的就是方便寫html寫動態頁面 本質上JSP也是一個servlet，所以也會不可避免的要寫一些java代碼，也就是腳本，為了不讓其那麼混亂，就增加了標籤，EL運算式來儘量代替腳本。但是在寫一些項目時，還是會很麻煩，原因是業務邏輯代碼，與資料庫交互的代碼，HTML代碼這些類別，風格，作用完全不同的都混雜在了一起，造成的結果是代碼的維護性，可讀性以及擴張性都非常差，比如要改一個需求，那麼必須要把全部代碼都看完，不然你可能會因為修改了一處代碼，導致別的地方多處錯誤 到了Spring的年代時，把表現層的幕後處理請求和頁面獨立出來，形成了Controller和View，把業務邏輯層以及持久層、實體類(JavaBean)整合成一個Model。Controller就只處理請求資料，View就只處理頁面 常見框架比如Struts、Hibernate、Spring、會發現Struts是處理表現層的一個框架，而Hibernate是在dao層的一個框架，spring就是service層了 再後來就有了結合兩種開發模式，Controller只處理簡單請求，Service只處理業務邏輯，Dao只處理資料庫訪問資料，View只處理頁面，Model只處理實體類 小結:硬要連連看的話 Model=業務邏輯層+資料訪問層，JavaBean與service View=表現層的前台部分，html、Jsp等給人看的東西 Controller=表現層的後台部分，Servlet 但與其這樣硬分，不如說三層架構是為了JavaEE專案中路徑與各種包的分類，MVC是為了前後端的分離，他們負責的方向是不同的，實際開發中我們2種分類都會用到 web資源的部分 在專案中指定web.</description>
    </item>
    
    <item>
      <title>XML、Servlet</title>
      <link>https://yoziming.github.io/post/220103-agg-javaweb-03/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220103-agg-javaweb-03/</guid>
      <description>XML Extensible Markup Language 可延伸標記式語言 常用於: 保存資料 作為配置文件 傳輸(但現在json為主) 特性 格式:&amp;lt;標籤名&amp;gt;夾住的值&amp;lt;/標籤名&amp;gt; 或單標籤內用空格分開屬性&amp;lt;book id=&amp;quot;SN65421&amp;quot; name=&amp;quot;小王子&amp;quot;/&amp;gt; 標籤名不可以數字或符號開始 標籤名不可包含空格 所有標籤都必須關閉 大小寫敏感 必須正確嵌套，例如a元素在b元素中打開，也必須在b元素中關閉 屬性值必須用&amp;quot;&amp;quot;引號包住 範例 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!-- xml 聲明 version 是版本的意思 encoding 是編碼 --&amp;gt; &amp;lt;books&amp;gt; &amp;lt;!-- 這是 xml 注釋 --&amp;gt; &amp;lt;book id=&amp;#34;SN123123413241&amp;#34;&amp;gt; &amp;lt;!-- book 標籤描述一本圖書 id 屬性描述 的是圖書 的編號 --&amp;gt; &amp;lt;name&amp;gt;java 程式設計思想&amp;lt;/name&amp;gt; &amp;lt;!-- name 標籤描述 的是圖書 的資訊 --&amp;gt; &amp;lt;author&amp;gt;華仔&amp;lt;/author&amp;gt; &amp;lt;!-- author 單詞是作者的意思 ，描述圖書作者 --&amp;gt; &amp;lt;price&amp;gt;9.9&amp;lt;/price&amp;gt; &amp;lt;!-- price 單詞是價格，描述的是圖書 的價格 --&amp;gt; &amp;lt;/book&amp;gt; &amp;lt;book id=&amp;#34;SN12341235123&amp;#34;&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>jQuery</title>
      <link>https://yoziming.github.io/post/220102-agg-javaweb-02/</link>
      <pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220102-agg-javaweb-02/</guid>
      <description>jQuery 輔助JavaScript的類庫
用於簡化HTML與JavaScript之間的操作 引用 下載jquery-1.7.2.js，放到指定位置，通常在static/script/之下 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;/static/script/jquery-1.7.2.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; $(function () { // 表示頁面載入完成 之後，相當 window.onload = function () {} var $btnObj = $(&amp;#34;#btnId&amp;#34;); // 表示按 id 查詢標籤物件 $btnObj.click(function () { // 綁定按一下事件 alert(&amp;#34;jQuery 的按一下事件&amp;#34;); }); }); &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button id=&amp;#34;btnId&amp;#34;&amp;gt;SayHello&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 核心函數$ $ 是jQuery 的核心函數，能完成jQuery 的很多功能。$()就是調用$這個函數
傳入參數為 [ 函數 ] 時:表示頁面載入完成之後，相當於window.onload = function(){} 傳入參數為 [ HTML 字串 ] 時:會對我們創建這個html 標籤物件 傳入參數為 [ 選擇器字串 ] 時: $(&amp;quot;#id 屬性值&amp;quot;) id 選擇器，根據id 查詢標籤物件 `$(&amp;ldquo;標籤名&amp;rdquo;) 標籤名選擇器，根據指定的標籤名查詢標籤物件 $(&amp;quot;.</description>
    </item>
    
    <item>
      <title>Web前端:HTML、CSS與JavaScript基礎知識</title>
      <link>https://yoziming.github.io/post/220101-agg-javaweb-01/</link>
      <pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220101-agg-javaweb-01/</guid>
      <description>本筆記基於2020-02-26 尚硅谷最新版JavaWeb全套教程
https://www.bilibili.com/video/BV1Y7411K7zz
Web前端三劍客 HTML(超文本標記語言):負責網頁的結構 CSS(層疊樣式表):負責網頁的樣式(比如顏色/字體/邊框等屬性設置) JavaScript(腳本語言):負責網頁的行為(點擊/輸入輸出/滾動等等) 他前端的課程幾乎都是過眼了解的程度而已，我也就沒做詳盡的筆記了
HTML 用標籤表示語法，有幾點特性: 標籤無視大小寫 標籤要正確閉合 標籤不可嵌套使用 標籤中的屬性必須有值，屬性值必須加引號 &amp;lt;!-- 註釋 --&amp;gt; &amp;lt;標籤名&amp;gt;封裝的數據&amp;lt;/標籤名&amp;gt; &amp;lt;!--屬性必須有值，屬性值必須加引號 --&amp;gt; 正確：&amp;lt;font color=&amp;#34;blue&amp;#34;&amp;gt;Hello world&amp;lt;/font&amp;gt; &amp;lt;!--標籤的演示 div 標籤 預設獨佔一行 span 標籤 它的長度是封裝資料的長度 p 段落標籤 預設會在段落的上方或下方各空出一行來（如果已有就不再空） --&amp;gt; &amp;lt;div&amp;gt;div 標籤 1&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;div 標籤 2&amp;lt;/div&amp;gt; &amp;lt;span&amp;gt;span 標籤 1&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;span 標籤 2&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;p 段落標籤 1&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;p 段落標籤 2&amp;lt;/p&amp;gt; &amp;lt;!-- 圖片 --&amp;gt; &amp;lt;img src=&amp;#34;1.jpg&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;260&amp;#34; border=&amp;#34;1&amp;#34; alt=&amp;#34;無法顯示圖片時顯示的文字&amp;#34;/&amp;gt; &amp;lt;!-- 超連結 --&amp;gt; &amp;lt;a href=&amp;#34;http://localhost:8080&amp;#34;&amp;gt;超連結&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;http://localhost:8080&amp;#34; target=&amp;#34;_blank&amp;#34;&amp;gt;新開超連結&amp;lt;/a&amp;gt;&amp;lt;br/&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>JDK8新特性:Lambda表達式、StreamAPI、Optional類</title>
      <link>https://yoziming.github.io/post/211215-agg-ja-30/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211215-agg-ja-30/</guid>
      <description>Lambda表達式 可以簡略表達接口的匿名函數部份
用於函數式接口，即只有一個抽象方法的接口 因為當你使用這個接口就必定要實現這個唯一的方法，所以很多東西可以省略 結構 // 舉例 Comparator&amp;lt;Integer&amp;gt; com = (o1, o2) -&amp;gt; o1.compareTo(o2); -&amp;gt;:Lambda符號、箭頭符號 左邊:Lambda形參列表，就是接口中抽象方法的形參列表 參數類型可以省略(類型推斷) 如果只有一個參數，可以省略()括號 右邊:Lambda體，就是重寫的方法體，應該用{}大括號包裹 如果只有一行語句，可以省略{}大括號 如果省略{}大括號也必須省略return 應用 其實不用特別去記，IDEA寫出來他就會提示自動修改了
一. // 無參無返回 Runnable r1 = new Runnable() { @Override public void run() { System.out.println(&amp;#34;hello&amp;#34;); } }; // Lambda省略後 Runnable r1 = () -&amp;gt; System.out.println(&amp;#34;hello&amp;#34;); 二. // 方法有一個形參，無返回 Consumer&amp;lt;String&amp;gt; stringConsumer = new Consumer&amp;lt;String&amp;gt;() { @Override public void accept(String s) { System.out.println(s); } }; // Lambda省略後，左邊參數類型跟括號省掉了 Consumer&amp;lt;String&amp;gt; stringConsumer = s -&amp;gt; System.</description>
    </item>
    
    <item>
      <title>反射Reflection、動態代理</title>
      <link>https://yoziming.github.io/post/211214-agg-ja-29/</link>
      <pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211214-agg-ja-29/</guid>
      <description>反射Reflection 反射Reflection是Java被視為動態語言的關鍵，可以在運行時獲取類的內部訊息 動態語言:程式運行時，代碼可以根據某些條件改變自身結構 具體來說，當我們加載完某類之後，在記憶體中堆的方法區就產生了一個該類的Class物件，此物件包含了完整的該類的結構訊息 因此我們能透過反射的API，從一個物件取得他所屬類的屬性與方法並進行各種操作 主要API java.lang.Class:代表一個類 java.lang.reflect.Method:代表類的方法 java.lang.reflect.Field:代表類的成員變數 java.lang.reflect.Constructor:代表類的構造器 Class類 Class類即是&amp;quot;類的類&amp;quot;，為反射的源頭 Object類中定義了getClass()方法，此方法被所有類繼承 Class類的實例物件只能由系統建立，當一個.class檔案被JVM載入執行時系統在堆的方法區產生唯一對應的物件 通過Class物件可以完整獲取類的結構並進行各種操作，所以要使用反射必須先獲取Class物件 萬物皆物件、萬物皆有Class類 數組的話只要元素類型與維度相同，視為同一個Class，例如int[5]與int[20] 獲取Class實例物件 已知具體類名:Class clazz = String.class 已知全類名:Class clazz = Class.forName(&amp;quot;java.lang.String&amp;quot;) 可能拋出錯誤ClassNotFoundException 也可以透過ClassLoader ClassLoader cl = this.getClass().getClassLoader() Class clazz4 = cl.loadClass(&amp;quot;全類名&amp;quot;) 已有某類的實例物件:Class clazz = obj01.getClass() ClassLoader 補充知識點，有印象就好
類的加載實際步驟 Load:將.class檔案讀入記憶體、創建Class物件 Link:將類的二進位數據合併到JRE中、引入常量 Initialize:初始化，執行類構造器&amp;lt;clinit&amp;gt;()方法，進行static屬性或指定初始值的賦值 如果一個類的父類還沒初始化，會先進行父類的初始化 JVM會保證&amp;lt;clinit&amp;gt;()方法在多線程環境中的加鎖與同步 加載器的分類 Bootstrap:引導類，由C語言編寫，負責Java平台核心庫，無法直接獲取 Extension:擴展類，負責載入jre/lib/ext或指定目錄下的jar包 System(APPs):系統類，負責載入java.class.path目錄下的jar包，最常用的 SomeClass:自訂類 從Class創立類的實例物件 取得一個Class物件後，可以透過newInstance()方法創建對應類的實例，但有前提: 該類必須有一個空參的構造器 該構造器要有符合的訪問權限 從Class實例物件反射獲取資訊 基本都是getXXX()，沒特別聲明的會返回包含父類的public資訊
Declared用於指明&amp;quot;當前代&amp;quot;，並且無視權限修飾符
取得構造器 public Constructor&amp;lt;T&amp;gt;[] getConstructors():返回public的構造器，構造器無法繼承，這可不會拿到父類的構造器 public Constructor&amp;lt;T&amp;gt;[] getDeclaredConstructors:返回當前類的所有構造器(含private) 對於返回的Constructor類物件，還能再細探: public int getModifiers():取得修飾符 public String getName():取得方法名稱 public Class&amp;lt;?</description>
    </item>
    
    <item>
      <title>通訊協定:URL、IP與網路編程</title>
      <link>https://yoziming.github.io/post/211213-agg-ja-28/</link>
      <pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211213-agg-ja-28/</guid>
      <description>通訊協定 物理層:網路線、電話線 網路層:IP、ICMP、ARP 傳輸層:TCP、UDP 應用層:HTTP、FTP、DNS、Telnet 一般來說所謂&amp;quot;下層&amp;quot;是越靠近物理層面的那層 網路層(IP) InetAddress類
實例化 getByName(String host):host可以是IP，也可以是域名再透過DNS找到IP IP 本機:127.0.0.1或localhost 內部IP:192.168.0.0~192.168.255.255 外部IP:其他的都是 域名:www.google.com、zh.wikipedia.org&amp;hellip;等等 DNS:Domain Name System，負責找出對應的IP getLocalHost():返回本地IP 調用 getHostName():顧名思義 getHostAddress():顧名思義 port:連接埠、端口號，每個程序各自占用的通道，介於0~65536
公認端口:0~1023，例如:http=80、ftp=21、telnet=23 註冊端口:1024~49151，約定成俗的，例如MySQL=3306 IP+port=Socket
Socket才是真正實現程序間網路通信的基礎 主動發起通信的為客戶端Client，等待請求的為服務端Server 傳輸層 TCP 可靠，連接時需進行三次握手: 第一次:A發給B說&amp;quot;B 在嗎?&amp;quot; 第二次:B收到並返回&amp;quot;在，我是B，請說&amp;quot; 第三次:A收到B返回的&amp;quot;請說&amp;quot;，就認為傳輸是可靠的 適合用在大量的傳輸 傳輸完需釋放連接、效率低。四次揮手: 第一次:A發給B說&amp;quot;B 我們分手吧?&amp;quot; 第二次:B收到並返回&amp;quot;什麼?你確定?&amp;quot; 第三次:B想了一下確實該分，又返回&amp;quot;算了，那就分吧&amp;quot; 第四次:A收到B確定要分手，揮了揮手，沒人回應 UDP 將數據、源、目的封裝成數據包，不需要建立連接 數據包大小限制在64K內 不確認、不可靠，可以廣播發送 無須釋放資源，開銷小、速度快 網路編程 範例-TCP連線 實際上必須try-catch，這邊暫時用throws Exception維持代碼簡潔
client端 public void client1() throws Exception { Socket localhost = new Socket(&amp;#34;localhost&amp;#34;, 8899); OutputStream outputStream = localhost.getOutputStream(); outputStream.write(&amp;#34;哈囉你好嗎&amp;#34;.getBytes(StandardCharsets.UTF_8)); // 關鍵，這邊write完不shutdown，後面read方法會被阻塞 localhost.</description>
    </item>
    
    <item>
      <title>IO流:物件流、序列化、隨機讀寫流與NIO</title>
      <link>https://yoziming.github.io/post/211212-agg-ja-27/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211212-agg-ja-27/</guid>
      <description>標準輸出/入流 System.in:標準輸入字節流，預設是從鍵盤輸入，類型是InputStream System.out:標準輸出流，預設輸出到控制台，類型是PrintStream，繼承自FilterOutputStream，繼承自OutputStream 重定向方法 public static void setIn(InputStream in) public static void setOut(PrintStream out) 範例-讀取輸入 不使用scanner
public static void main(String[] args) { // 把標準輸入字節流先轉換成字符流 BufferedReader bufferedReader = null; try { InputStreamReader isr = new InputStreamReader(System.in); // 把字符流用bufferedReader包起來，為了調用readline方法 bufferedReader = new BufferedReader(isr); for (; true; ) { System.out.println(&amp;#34;輸入要轉換成大寫的字串...&amp;#34;); String str = bufferedReader.readLine(); if (&amp;#34;exit&amp;#34;.equalsIgnoreCase(str)) { // &amp;#34;exit&amp;#34;放前面防空指針 System.out.println(&amp;#34;離開&amp;#34;); break; } System.out.println(str.toUpperCase()); } } catch (IOException e) { e.printStackTrace(); } finally { try { bufferedReader.</description>
    </item>
    
    <item>
      <title>IO流:基礎、緩衝流、轉換流與Unicode編碼</title>
      <link>https://yoziming.github.io/post/211211-agg-ja-26/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211211-agg-ja-26/</guid>
      <description>File類 位於 java.io之下 File類的一個物件，代表一個實際的文件檔案或一個資料夾 File類只涉及檔案或資料夾的創建、刪除、改名&amp;hellip;等方法，只能碰到外殼；讀取或寫入需要IO流才能做到 File類的物件通常做為參數傳到流的構造器中，作為讀取或寫入的終點 實例化 構造器的幾種參數
File(String filepath):一般路徑 File(String parentPath, String childPath):分成父目錄與子目錄，再拼接起來 File(FileA parentFile, String childPath):相當於以 FileA為父目錄下的子目錄 路徑 不指明就是相對路徑，在IDEA中若使用 JUnit單元測試位置是 Module下(與 src資料夾同層)；若 main()方法則是在 Project下
指明則是絕對路徑，例如 &amp;quot;G:\\Java\\code\\guigu\\day26IO\\src\\hi.txt&amp;quot;
關於正反、雙斜槓等疑惑可以參考這篇:
https://yoziming.github.io/post/211212-slash-file-name/
File類中有一個常量 File.separator可以根據系統自動變換分隔符
常用方法 預設以一個File類的實例物件.調用以下方法
String getAbsolutionPath():獲取絕對路徑 String getPath():獲取相對路徑 String getName():獲取檔案名稱 String getParent():獲取上層文件夾目錄路徑(需本身是絕對路徑)，若無則返回null Long Length():獲取檔案大小，單位位元組 Long LastModified():獲取最後修改時間戳 file1.boolean renameTo(File file2):將file1搬到file2的路徑並改名成file2，必須有file1無file2(他是一個移動+改名，無法覆蓋) String[] List():獲取指定目錄下的所有資料夾名與檔案名，類似dir與ls，只適用於資料夾目錄 File[] ListFiles():獲取指定目錄下的所有資料夾與檔案的File數組，只適用於資料夾目錄 boolean isDirctory():判斷是否為文件夾 boolean isFile():判斷是否為檔案 boolean exists():判斷是否存在 boolean canRead():判斷是否能讀 boolean canWrite():判斷是否能寫 boolean isHidden():判斷是否隱藏 創建/刪除檔案 不是實例化，而是真正在硬碟中創建檔案
boolean createNewFile():創建檔案，若檔案已存在則不創建並返回 false boolean mkdir():創建資料夾，若資料夾已存在或不存在上層目錄，則不創建並返回 false boolean mkdirs():創建資料夾，若不存在上層目錄，一併創建 boolean delete():執行就馬上刪了，可不會進資源回收桶，慎用，如果是文件夾必須是空的才能刪 IO流 IO即in和out，輸入和輸出</description>
    </item>
    
    <item>
      <title>泛型Generic</title>
      <link>https://yoziming.github.io/post/211210-agg-ja-25/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211210-agg-ja-25/</guid>
      <description>泛型Generic 泛型是JDK5新增的項目
特性 帶泛型的結構在實例化時，可以指明具體的泛型類型，類似於貼&amp;lt;標籤&amp;gt; 指明完後，使用到類的地方全都換成該泛型 用一個比喻，我自訂一個帶&amp;lt;&amp;gt;泛型的校車類，當實例化具體的校車A時，在&amp;lt;&amp;gt;中指明上裝的都是&amp;lt;北一女學生&amp;gt;，那裝進去的就只能是北一女學生， 當我對這台校車A進行各種操作時，就不用考慮裡面人是啥種類(以前都用Object盛裝，然後操作時還要先instanceOf確認種類再強轉)，現在跟校車A牽扯的通通都是&amp;lt;北一女學生&amp;gt;不用囉嗦 承上例，我也可以實例化另一台校車B&amp;lt;建中男學生&amp;gt;。一個優勢在於我規劃校車這個類時，先不用考慮具體要裝的是啥類而用泛型，用這個泛型先寫好通用的方法，留著空給實例化時再去決定實際調用的類 使用範例 // 造一個指明泛型為Integer, String的Map HashMap&amp;lt;Integer, String&amp;gt; stringHashMap = new HashMap&amp;lt;Integer, String&amp;gt;(); stringHashMap.put(1, &amp;#34;小名&amp;#34;); stringHashMap.put(2, &amp;#34;老王&amp;#34;); stringHashMap.put(3, &amp;#34;阿洲&amp;#34;); // 此時如果想放進非Integer,String的東西則報錯 // 轉成EntrySet，叫Map.Entry是因為Entry是一個內部接口 Set&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; entries = stringHashMap.entrySet(); // 通通都自動帶入泛型，而不用再去判斷種類或強轉 // 試著遍歷 Iterator&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; iterator = entries.iterator(); while (iterator.hasNext()) { Map.Entry&amp;lt;Integer, String&amp;gt; next = iterator.next(); Integer key = next.getKey(); String value = next.getValue(); System.out.println(key + &amp;#34;=&amp;gt;&amp;#34; + value); } 聲明 集合接口或集合類都天生帶有泛型的結構，自建的類或接口也能聲明泛型 泛型類可能有多個參數，可以都放在&amp;lt;&amp;gt;內用&amp;quot;,&amp;ldquo;隔開，例如:&amp;lt;E1, E2, E3&amp;gt; 聲明構造器時不用寫泛型 靜態方法不能使用類的泛型(因為泛型在實例化時才決定，當能不能跟static共存) 異常類不能聲明為泛型(因為它祖宗就沒有&amp;lt;&amp;gt;，繼承再怎樣都生不出來) 實例化 實例化時，指定的泛型必須是一個實際類，不能是基本數據類型(有需要就用包裝類) 泛型可以嵌套使用 帶泛型的接口或類在實例化時如果不指定泛型，就當作Object處理，但不等價於Object 要嘛一路都用泛型，要嘛都不要用 泛型方法 在方法中出現了泛型的結構，泛形參數與類的泛型無關</description>
    </item>
    
    <item>
      <title>集合:Map、HashMap、Collections工具類</title>
      <link>https://yoziming.github.io/post/211209-agg-ja-24/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211209-agg-ja-24/</guid>
      <description>Map Map接口:雙列數據，保存具有映射關係(key-value)成對的物件
分類 HashMap:主要實現類，線程不安全、效率高、可以存null LinkedHashMap:遍歷時可以按照添加順序排列 TreeMap:可以按照key(必須都是同類)來排序，底層是紅黑樹 Hashtable:古老的實現類，注意t是小寫，線程安全、效率低、不能存null Properties:常用來處理配置文件，key跟value都是String類型 結構 key:無序、不可重複的，使用Set儲存。key決定存放位置，key的所在類必須重寫equals()與hashCode() value:無序，可重複的，使用Collection儲存，value的所在類必須重寫equals() 一對key與value構成一個Entry物件，使用Set儲存，當然也是無序、不可重複的 HashMap源碼分析 以JDK7為例
HashMap map = new HashMap();實例化時，底層創建了一個長度16的一維數組Entry[] table map.put(key1, value1);:放數據時，調用key1所在類的hashcode()方法算出哈希值，以此哈希值再經過某些位運算，得到在Entry[] table數組中的存放位置，此時: 若位置是空的，放入成功 若已經有人(可能有一個數據或鏈表)，就來比較key1跟佔位者(可能有多個，全都要比一遍)的哈希值 如果哈希值都不同，添加成功(放成鏈表) 如果key1的哈希值跟已存在的某數據(舉例為key2, value2)哈希值相同，此時再比較key1所在類的equals()方法，根據返回值: 如果equals()返回false，表示key不同只是恰好哈希值一樣，添加成功(放成鏈表) 如果equals()返回true，表示兩者key真的一樣，那就進入至尊對決，此時把put()方法理解為覆蓋，將舊的value2換成新的value1 所謂放成鏈表跟前面Set提到的一樣，類似於&amp;quot;卜&amp;quot;字的概念，從該位置延伸出去存放新的元素 擴容:超過臨界值(容量*負載因子)且要存的位置非空，就會進行擴容，預設的擴容方式為造一個新的兩倍長數組，然後將原有的複製過來 預設容量:16 預設負載因子:0.75 擴容的邏輯是這樣的，為了減少哈希碰撞(就是不希望分支的鏈表太多太長)，所以不會等他裝到滿才擴容。 假如負載因子0.9可能老是撞車導致分支很多，負載因子0.2可能一直在擴容，折衷就定負載因子為0.75效率最高 JDK8的改動 new HashMap():實例化時，底層沒有創建數組，首次調用put()方法才創建，類似懶漢式 底層數組用Node[]取代Entry[] 當數組某一個位置上的元素以鏈表形式存在的數據&amp;gt;8，且當前數組長度&amp;gt;64時，將鏈表改為紅黑樹儲存，提高查找效率 白話:分支長度&amp;gt;8且主幹長度&amp;gt;64轉紅黑樹 LinkedHashMap 繼承了HashMap的Node，但又多了before跟after兩個屬性，所以形成雙向鏈表，可以在添加時記錄前後順序
Map常用方法 預設使用一個HashMap的實例物件作為調用的主體演示
Object put(Object key, Object value):添加或修改，並且返回null或被取代的value void putAll(Map m):將m所有的對都放進去 Object remove(Object key):移除指定key的鍵值對，返回被刪除的value void clear():清空當前map中所有數據，注意與map=null不同，只是清空數據，本身還在 Object get(Object key):獲取對應的value boolean containsKey(Object key):是否有此key boolean containsValue(Object value):是否有此value int size():返回鍵值對個數 boolean isEmpty():是否size=0 boolean equals(Object key):判斷當前map與obj是否相等 遍歷Map 切出Collection的部分再用Iterator來遍歷</description>
    </item>
    
    <item>
      <title>集合:Collection接口、疊代器、List與Set</title>
      <link>https://yoziming.github.io/post/211208-agg-ja-23/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211208-agg-ja-23/</guid>
      <description>集合概述 集合、數組都是用來儲存多個數據(在記憶體中)的結構，簡稱Java容器 數組在聲明時長度跟數據類型就定死了，還強制是有序的，增刪改查都不變 Java集合分成兩種體系，有各種接口與實現類: Collection接口:單列數據，用來存一個一個的物件 List接口:元素有序、可重複，又稱為&amp;quot;動態數組&amp;quot; ArrayList LinkedList Vector Set接口:元素無序、不可重複 HashSet LinkedHashSet TreeSet Map接口:雙列數據，保存具有映射關係(key-value)成對的物件 HashMap LinkedHashMap TreeMap Hashtable Properties Collection Collection接口本身沒有直接的實現類，而是要通過其子類List與Set各自的實現類來完成物件的實例化
方法 用一個實現Collection接口的實例物件調用，例如:Collection coll = new ArrayList();
add(Object e):將Object e加入集合中
size():返回元素個數
addAll(Collection c):將集合c的內容全加進來
clear():清空元素，注意不是刪除集合本身，只是清掉其中的元素
isEmpty():判定是否為空
contains(Object obj):判斷集合中是否存在obj物件，注意這邊調用的是該類的equals()方法，也就是說預設類型他是比內容；而若自訂的類沒有重寫equals()方法，則會是比地址值(相當於&amp;quot;==&amp;quot;)，一般來說在集合用到自訂類我們都要求該類必須重寫equals()方法，不然太搞
containsAll(Collection c):判斷當前集合是否包含整個集合c，與順序無關，每個元素都有就算
boolean remove(Object obj):判斷集合中是否存在obj物件，有則移除一個並返回true
containsAll(Collection c):只要當前集合跟集合c有共通的項目，就全部移除(相當於數學上的差集)，並返回true
retainAll(Collection c):判斷當前集合與集合c的交集，只保留相同部分(重複的他不會去修改數量)
equals():判斷兩個集合所有元素是否相等，注意順序有差
toArray():將集合轉成並返回數組
Arrays.asList():Arrays的靜態方法，將數組轉為List，使用時注意可能將數組形參視為&amp;quot;一整個引用類型物件&amp;quot;，前後類別要特別寫清楚，有懷疑就用size方法看看元素個數是否吻合 iterator():返回Iterator接口的疊代器實例，用於遍歷集合元素
疊代器Iterator 專門用來遍歷Collection集合的接口
Collection繼承自Iterable接口，表明該類可以用於疊代器
當某個類實現Iterable接口時，我們就能稱這個類是一個&amp;quot;可數&amp;quot;的類，也就是可以使用iterator()方法獲取一個疊代器Iterator，然後使用這個Iterator實例去遍歷這個類
Iterator接口:如果某個類實現了Iterable接口，那麼他也需要創建一個內部類去實現一個Iterator類，讓調用Iterable接口中的iterator()時，能夠獲取到一個iterator實例
調用時創建一個疊代器物件，此時疊代器的游標指向在第一元素之前，並且有幾個常用的方法:
.next():顯示下一個元素內容，並將指針後移一位
.hasNext():判斷是否存在下一個元素內容，返回布林，可以用while配合循環遍歷集合，舉例:
Iterator iterator = col.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } // 純遍歷用foreach更快，foreach相較之下的特性是失去了索引 .remove():只能用在next()之後且一對一，用於刪除剛剛返回的元素；注意跟Collection本身的remove(Object obj)方法不一樣</description>
    </item>
    
    <item>
      <title>枚舉類enum、註解annotation</title>
      <link>https://yoziming.github.io/post/211207-agg-ja-22/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211207-agg-ja-22/</guid>
      <description>枚舉類(enum) 當類的物件數量是有限定的、確定的，例如:星期、性別、季節、支付方式、XX狀態 需要定義一組常量時，強烈建議使用枚舉類 如果類中只有一個物件，可以用單例模式 enum，發音&amp;quot;衣-囊&amp;quot;，名詞枚舉 enumerate，發音&amp;quot;以-new-merate&amp;quot;，動詞枚舉 自訂枚舉類 JDK 5以前
聲明物件的屬性，用private final修飾
將構造器私有化，給物件屬性賦上預想好的值
在本類中預先創立好物件，用public static final修飾
提供toSting方法
提供其他訴求，例如:get屬性等等
範例:
class PayMethod { private final String name; private final String desc; private PayMethod(String name, String desc) { this.name = name; this.desc = desc; } public static final PayMethod CASH = new PayMethod(&amp;#34;現金&amp;#34;, &amp;#34;真金白銀&amp;#34;); public static final PayMethod VISA = new PayMethod(&amp;#34;VISA卡&amp;#34;, &amp;#34;VISA金融卡&amp;#34;); public static final PayMethod ONLINE = new PayMethod(&amp;#34;電子支付&amp;#34;, &amp;#34;街口支付&amp;#34;); @Override public String toString() { return &amp;#34;PayMethod{&amp;#34; + &amp;#34;name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, desc=&amp;#39;&amp;#34; + desc + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } // 調用，因為是靜態，直接類名.</description>
    </item>
    
    <item>
      <title>常用類:日期時間、比較器、其他</title>
      <link>https://yoziming.github.io/post/211206-agg-ja-21/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211206-agg-ja-21/</guid>
      <description>日期時間(JDK 8前) 提前說下，這些過時的類型跟方法實際95%用不上，了解一下就夠了
System類中的currentTimeMillis():返回當下與1970年1月1日之間的時間差，單位毫秒 這一長串的數字稱為時間戳 java.util.Date類 創建
使用空參構造器:創建一個當前時間的物件，格式為Wed Dec 01 13:35:20 CST 2021
形參傳入時間戳，創建一個該時間戳的物件
方法
toString():顯示時間 getTime():返回時間戳 java.sql.Date類 本身是java.util.Date的子類，用來對應資料庫中的日期變量 為了區分，最好使用全類名例如:java.sql.Date d2 = new java.sql.Date(d1.getTime()); 創建:形參必須傳入時間戳 方法: toString():顯示時間，格式只有日期，如:2021-12-01 getTime():返回時間戳 java.util.Date與java.sql.Date轉換:形參中填入getTime()即可互轉 SimpleDateFormat類 顧名思義，把Date類格式化成String用的
創建一個形參為你想要的格式(如常見的yyyy-MM-dd hh:mm:ss)的SimpleDateFormat物件
用此物件調用format(date物件)方法返回想要的String，舉例:
Date d1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd hh:mm:ss&amp;#34;); String s1 = sdf.format(d1); System.out.println(&amp;#34;s1 = &amp;#34; + s1); 還原(解析)文字重回Date類，也要符合該物件生成時的格式，並且用try包裹，舉例:
try { Date d2 = sdf.parse(s1); System.out.println(&amp;#34;d2 = &amp;#34; + d2); } catch (ParseException e) { e.</description>
    </item>
    
    <item>
      <title>常用類:String相關類與方法</title>
      <link>https://yoziming.github.io/post/211205-agg-ja-20/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211205-agg-ja-20/</guid>
      <description>String類 String類特性 表示字符串，內容以&amp;quot;&amp;quot;包裹表示，稱為字面量的定義方式 是一個final類，不可被繼承 實現了Serializable接口，可以序列化 實現了Comparable接口，表示可以比較大小 內部定義了一個final char[] value數組來實際儲存數據，代表不可變的字符序列 當我們用字面量(區別於new)定義了一個String str1=&amp;quot;abc&amp;quot;，相當於在方法區的字符串常量池中新增了一個&amp;quot;abc&amp;quot;序列，其為不可變的 字符串常量池中不會儲存內容相同的字符串，比如我再新增一個str2=&amp;quot;abc&amp;quot;，則他們指向同一地址。 延伸str6=&amp;quot;a&amp;quot;+&amp;quot;bc&amp;quot;，在聲明時字面量相加，等於常量跟常量拼接，都是在常量池，所以指向同樣位置 而當我把str1=&amp;quot;hello&amp;quot;，或是用+拼接了其他內容，或是用replace取代了其中某一位的字，都是在常量池重新開闢空間，所謂不可變是這個意思 如果是用String str3=new String(&amp;quot;abc&amp;quot;);方法生成，則是創在堆中，str3本身是指向堆的地址，去比==都是false。這個動作實際開闢了2個記憶體空間，它在堆中的value才指向常量池 如果是new一個構造器生成時賦予的name傳入形參則跟new String是不同的，傳入形參也是類似於字面量的方法(因為顯然多在堆中開闢位置是毫無必要的) 若是用+拼接有任何涉及到變量的，例如str4=str1+&amp;quot;def&amp;quot;，都是相當於在堆空間new的操作，==去比較時全都false 但如果變量被final修飾(正常不會有人這麼做)，相當於這個變量存在常量池，又會是常量跟常量拼接，所以指向同樣位置 若是用intern()方法，例如str5=str1.intern();，返回值是在常量池中，==比較是true 面試題-判斷結果 public class StringTest { String str = new String(&amp;#34;good&amp;#34;); char[] ch = {&amp;#39;t&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;}; public void change(String str, char[] ch) { str = &amp;#34;bad&amp;#34;; ch[0] = &amp;#39;b&amp;#39;; } public static void main(String[] args) { StringTest ex = new StringTest(); ex.change(ex.str, ex.ch); System.out.println(ex.str); // good System.out.println(ex.ch); // best } } 切記傳形參時，引用類型傳的是地址值</description>
    </item>
    
    <item>
      <title>多線程:安全&amp;通信、Callable接口與線程池</title>
      <link>https://yoziming.github.io/post/211204-agg-ja-19/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211204-agg-ja-19/</guid>
      <description>線程安全 線程的生命週期 Thread.State類中定義了:
新建:Thread類的物件被創建 就緒:start()後等待分配CPU資源的階段，可能是獲取了同步鎖、被notify() 運行:拿到實際資源、開始執行run()方法 阻塞:被暫時掛起，可能是sleep()或是被join()、或等待同步鎖、wait() 死亡:跑完或提前stop()、出錯了 同步代碼塊 解決多線程安全問題
格式:
synchronized (同步器) { // 需要同步的代碼 } 同步器可以是任何物件，只需要滿足&amp;quot;它是多個線程共用的&amp;quot;，比如同類中的一個變量
若是靠實現Runnable接口方法的多線程，可以用this，因為只有一個該類，當前對象是同一個 如果是繼承類實現的多線程，則可以用static變量，或是考慮&amp;quot;類名.class&amp;quot;(這玩意也是唯一的) 但這樣做實質等於單線程了，效率不高
同步方法 解決多線程安全問題
舉例:
public class SynTest implements Runnable { int ticket = 100; @Override public void run() { show(); } private synchronized void show() { for (; ticket &amp;gt; 0; ) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &amp;#34;賣票&amp;#34; + ticket); ticket--; } } } class Test { public static void main(String[] args) { SynTest s1 = new SynTest(); Thread thread0 = new Thread(s1); Thread thread1 = new Thread(s1); Thread thread2 = new Thread(s1); thread0.</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA Live Templates</title>
      <link>https://yoziming.github.io/post/211203-idea-live-templates/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211203-idea-live-templates/</guid>
      <description>IntelliJ IDEA Live Templates 盤點IDEA中Tab的實用招式，再配上alt+insert就能橫著走了
基本聲明 psvm或main ▶ main 方法 st ▶ String prsf ▶ private static final psf ▶ public static final psfi ▶ public static final int psfs ▶ public static final String 創立物件 類名.new ▶ new 類名() new 類名().var或.val ▶ 類 物件名 = new 類(); new 類名().field ▶ 在方法外聲明一個成員變量，並在這裡初始化一個 print sout ▶ System.out.println(); souf ▶ System.out.printf(&amp;#34;&amp;#34;); &amp;#34;say something&amp;#34;.sout ▶ System.out.println(&amp;#34;say something&amp;#34;); obj.sout ▶ System.out.println(obj); obj.soutv ▶ System.out.println(&amp;#34;obj = &amp;#34; + obj); // 標準錯誤輸出流，這個無緩衝，顯示的位置可能跟你想像的不同 obj.</description>
    </item>
    
    <item>
      <title>多線程:基礎、Thread類、用法</title>
      <link>https://yoziming.github.io/post/211203-agg-ja-18/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211203-agg-ja-18/</guid>
      <description>多線程 名詞解釋 英文 台灣 中國 意義 Program 程式 程序 靜態的程式碼集合 Process 程序(進程) 進程 動態、被執行中且載入記憶體的program，也是 OS 分配資源的最小單位。打開工作管理員看到的就是這個 Thread 執行緒 線程 一個進程裡至少會有一個線程，表示內部的一條執行路徑。把進程比喻為一個工廠，線程則是工廠裡面的工人，負責任務的實際執行。同一個Process內的Thread使用相同的Memory Space，但這些Thread各自擁有其Stack。換句話說，Thread能透過reference存取到相同的Object，但是local variable卻是各自獨立的。白話:共享方法區跟堆，獨立棧跟計數器 Coroutine 協程 協程 輕量級的執行緒，由使用者掌控，例如GO的goroutine Concurrent 並行 並發 一個 CPU 會去做多件事，但是同一個時間點之內只會做一件事，像是早上做 Job1、下午做 Job2、晚上做 Job3不斷的切換，目標是希望能做更多的事 Parallel 平行 並行 多個 CPU 在同一個時間點內會去做多件事，例如會有三個人同時分別在做 Job1、Job2、Job3 的事情。目標是希望能把事情更快速的做完。 需求來源 希望同時執行複數的任務，例如一邊執行main方法，GC一邊收垃圾 需要等待的狀況，例如等用戶輸入、等IO、等網路連接 Java多線程-方法一 造一個類，繼承Thread
重寫此類的run方法(將想多線程執行的代碼包進去)
實例化此類的一個物件
透過此物件調用start();，此時啟動此線程並且調用他的run()方法
若想再啟動另一條線程，需要再new一個物件，同一物件start多次會報IllegalThreadStateException
舉例:
public class MyThread extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 10000; i++) { if (i % 2 == 0) { System.</description>
    </item>
    
    <item>
      <title>項目練習3-開發團隊調度系統</title>
      <link>https://yoziming.github.io/post/211202-agg-ja-17/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211202-agg-ja-17/</guid>
      <description>項目練習3-開發團隊調度系統 雖然不是特別難，實做一遍還是會遇到不少坑，以下個人復盤的筆記
A類中用到B類的物件，引包後可以直接&amp;quot;private B類 物件名=new B類();&amp;ldquo;一個預設的來用 忽略大小寫可用equalsIgnoreCase 繼承的子類重複用到結構類似的方法，提取出相同因子在父類做一個public的然後去子類各自重寫，也能用來解決孫子super不到爺爺的困境 遍歷時注意.length的長度是在數組建立時就定死了，絕對不等於當前數組內的元素個數，如果遍歷.length有可能去遍歷到後面null的指針而報錯 單純只是想遍歷最好用foreach 手動複製數組使用System.arraycopy 方法形參是父類，想篩選傳進來的是否為某具體子類，用if(!(物件 instanceof 子類))可以優雅的判斷 switch-case如果沒有return記得break </description>
    </item>
    
    <item>
      <title>異常處理:try-catch、finally與throws</title>
      <link>https://yoziming.github.io/post/211201-agg-ja-16/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211201-agg-ja-16/</guid>
      <description>異常的分類 在Java中，程序執行中的異常分為Exception與Error，他們都繼承自Throwable
(語法錯誤跟邏輯錯誤那不叫異常)
Error 錯誤，JVM系統內部錯誤虛擬機無法解決的問題、資源耗盡等嚴重情況，比如:
無限迴圈產生堆疊溢位(Stack Overflow)
寫錯分配導致記憶體不足(Out-Of-Memory)，
解決方法就是把它寫對
Exception 例外，發生了出乎預料的事，又依&amp;quot;受不受檢&amp;quot;分成
Checked Exception:又稱編譯時異常，通常在原始碼中必須顯式地catch並且處理，比如:
IOException、讀取文件不存在
ClassNotFoundException
這部分在compile time就會檢查
Unchecked Exception:又稱RuntimeException，運行時異常，比如:
NullPointerException，空指針訪問 ArrayIndexOutOfBoundsException，數組角標越界 ClassCastException，類型轉換異常 NumberFormatException，數字類型不合 InputMismatchException，輸入數據不符合，例如scan int結果來了字串 ArithmeticException，算法異常，例如把某數除以0 通常是透過撰寫相應程式以避免的邏輯錯誤, 可以根據當下的情境來判斷是不是要catch 異常處理 代碼執行時，一旦出現異常，就會在異常處生成一個對應異常類的物件，並將其拋出，拋出後的代碼就不再執行
try-catch 格式:
try { int num = Integer.parseInt(str); } catch (NumberFormatException e) { e.printStackTrace(); // 印出異常 } catch (Exception e) { // something } 使用try{...}將可能有異常的代碼段包起來，當運行中異常發生時，走到哪停在哪，且生成一個異常的物件
使用catch預測可能生成的異常物件類，當有對應的就進入處理(類似於switch-case結構)
catch想抓的異常類型，如果有子父類關係，必須從小到大，否則報錯
在try結構中聲明的變量，只能在try中使用，出了try就不能再被調用
try-catch-finally 格式:
@org.junit.Test public void test1() { int n = method(); System.out.println(n); } public int method() { try { int[] arr = new int[3]; System.</description>
    </item>
    
    <item>
      <title>抽象abstract、接口interface、內部類</title>
      <link>https://yoziming.github.io/post/211130-agg-ja-15/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211130-agg-ja-15/</guid>
      <description>抽象abstract 隨著繼承不斷疊代，子類越來越具體，而父類越來越通用。
類的設計必須保證子類與父類共有特徵，有時候我們將父類設計得非常抽象，以至於它沒有具體的實例，這樣的類稱為抽象類。
定義 abstract屬於Java中的關鍵字，可以用來修飾類與方法，以下分別說明 abstract修飾類 此類不能實例化 必定有構造器被繼承 開發中都會提供抽象類的子類，讓子類形成實例來調用 不能修飾final類，final類規定不能被繼承，玩毛線 abstract修飾方法 稱為抽象方法，只有聲明，沒有方法體 (就沒要讓你具體用) 此方法不能被調用 包含抽象方法的類，必定是一個抽象類。反之抽象類不一定要有抽象方法 實際開發中的調用必須是被子類繼承後重寫，所有的抽象方法都被重寫後此子類才能實例化(否則，存在繼承來的抽象方法你就是個抽象類) 不能修飾私有private方法，因為抽象就是為了被繼承，抽象與其矛盾 不能修飾靜態static方法，靜態方法跟類共存亡，可以直接被類調用，通常是去弄靜態屬性的，抽象與其矛盾 不能修飾final方法，final方法規定是不能被重寫，抽象與其矛盾 應用-模板方法設計 在軟體開發中，實現某種功能時，整體中很固定、通用的方法，在父類中就寫好了；而其他不確定、易變的就先抽象起來，交給子類去實現
匿名子類的匿名對象 在一次性使用的場合，不想實際造一個匿名類的實體子類，可以在new 匿名類()後面接{}，{內直接重寫方法，範例:
abstract public class Person { abstract public void work(); } public class Student extends Person { @Override public void work() { System.out.println(&amp;#34;學生讀書&amp;#34;); } public static void main(String[] args) { method(new Student()); method(new Person() { @Override public void work() { System.out.println(&amp;#34;用一次的街友&amp;#34;); } }); } public static void method(Person person) { person.</description>
    </item>
    
    <item>
      <title>關鍵字:static/main/final、代碼塊與單例模式</title>
      <link>https://yoziming.github.io/post/211129-agg-ja-14/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211129-agg-ja-14/</guid>
      <description>關鍵字static 意義:靜態的，類中共用的，生命週期跟隨類的 使用對象:屬性、方法、內部類、代碼塊，以下分別說明 使用static修飾屬性 稱為&amp;quot;靜態變量&amp;quot;或&amp;quot;類變量&amp;quot;
先複習關於變量的知識
實例變量是每個造出來的物件各自有的，比如:大明跟小明各自的age不同 類變量是整個類共用的，比如:大明跟小明的nation都是TW 類變量隨著類的加載而加載，可以通過&amp;quot;類.靜態變量&amp;quot;進行調用 物件沒創建之前類變量就已經存在 由於類只會加載一次，靜態變量在記憶體中也只存在一份，位於方法區的靜態域 在哪應用靜態屬性: 類中共用的，生命週期跟隨類的 舉例:構造器中自動生成編號的基數(比如從1001開始、1002..) 常量也常聲明為static，再加上final修飾 舉例:Math.PI 使用static修飾方法 稱為靜態方法，規則大致與上面相同 隨著類的加載而加載，可以通過&amp;quot;類.靜態方法&amp;quot;進行調用 不能在靜態方法中調用非靜態的屬性或方法(畢竟沒有物件) 在靜態方法中，不能使用this或super關鍵字(物件都沒出生當然不能用) 在哪應用靜態方法: 操作靜態屬性的方法，通常設為靜態 工具類的方法，比如Math、Array、Collections 單例(singleton)設計模式 定義:整個系統中，強制某個類只存在一個實例，減少資源消耗
應用場合:
網站的計數器，只造一個，不然難以同步 日誌:通常是一個日誌文件一直被開著，最好只有一個實例去操作它 資料庫的連接池 Windows的Task Manager跟Recycle Bin也是很典型的單例 &amp;ldquo;餓漢式&amp;quot;實現:
私有化的構造器
內部創建類靜態的實例 (一上來就造好，只給你訪問這個)
提供外部的靜態方法，返回類的實例
優劣:加載時間長，但線程安全
舉例:
class Bank { private Bank() { } private static Bank instance = new Bank(); public static Bank getInstance() { return instance; } } &amp;ldquo;懶漢式&amp;quot;實現:
私有化的構造器
聲明類的靜態實例，但不初始化(沒用到就不造所以稱為懶)
聲明外部的、靜態的返回當前類實例的方法
優劣:延遲創建，但線程不安全，需要加鎖
舉例:
class Order { private Order() { } private static Order instance = null; // synchronized=上同步鎖 public synchronized static Order getInstance() { if (instance == null) { instance = new Order(); } return instance; } } 關鍵字main public static void main(String[] args) {} 其實就是一個靜態的方法，作為入口，生命週期是跟隨類本身 以往寫的東西老是造對象然後透過實例調用，其實也可以透過static修飾然後直接&amp;quot;類.</description>
    </item>
    
    <item>
      <title>多態:關鍵字instanceof、Object類與包裝類</title>
      <link>https://yoziming.github.io/post/211128-agg-ja-13/</link>
      <pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211128-agg-ja-13/</guid>
      <description>多態性 類似go接口的概念，就是為了讓子類能調用父類的方法
白話:為了實現代碼的通用性
一個事物的多種形態
父類的引用指向子類的物件(子類的物件賦給父類的引用)，舉例:
Father obj = new Child(); 使用:虛擬方法調用，編譯期只能調用父類中聲明的方法，但運行時執行的是子類重寫父類的方法。多態只有在運行那一個才知道要調用哪個方法，即多態是個運行時行為，又稱為動態綁定
白話:編譯看左，運行看右 前提:類的繼承關係、方法的重寫，缺一不可
目的:避免重複寫很多重載的方法
體現:
舉例`Person`類 之下有子類 `Chinese`、`Japanese`、`American` `Person`類有`welcome`方法，被各自子類以該國語言重寫過 我的某功能調用`welcome`時能接受`Person`類，依照實際子類物件呈現不同語言的`welcome`結果 該功能即不需要`Chinese`、`Japanese`、`American`都寫一次 public class Atest { public static void main(String[] args) { Atest test = new Atest(); test.func(new Dog()); // 多態體現在這 } public void func(Animal animal) { //Animal animal=new Dog(); animal.eat(); animal.shout(); } } class Animal { public void eat() { System.out.println(&amp;#34;動物吃&amp;#34;); } public void shout() { System.out.println(&amp;#34;動物叫&amp;#34;); } } class Dog extends Animal { @Override public void eat() { System.</description>
    </item>
    
    <item>
      <title>繼承:方法重寫、關鍵字super與物件實例化過程</title>
      <link>https://yoziming.github.io/post/211127-agg-ja-12/</link>
      <pubDate>Sat, 27 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211127-agg-ja-12/</guid>
      <description>繼承 目的 減少代碼冗餘、提高復用性 便於功能擴展 為多態鋪路 格式 class A extends B{} // A延展了B A:子類、派生類、subclass B:父類、超類、基類、superclass 繪圖時，通常用空心箭頭從子指向父，例如:Student→Person，表示學生類繼承了人類
特性 A繼承B之後，子類A就獲取了B聲明的所有屬性與方法，包含了私有(private)的，但是由於封裝性的影響，子類無法直接調用父類私有(private)的屬性與方法 不允許多重繼承(一人只能有一個老爸) 可以多層繼承(允許有孫子，孫子也會繼承爺爺的特性) 一個父類可以有多個子類(允許家族開枝散葉) 所有類都繼承自java.lang.Object，換言之所有類都具有Object類的特性 權限修飾符protected的應用 之前提過protected的範圍是不同包的子類也能用，就是應在這了 實際發開中用的比較少一點 方法的重寫 子類繼承父類後，對父類同名同參數的方法，進行覆蓋
子類重寫的方法權限修飾符必須不小於父類被重寫的方法
白話:不能把公車私有化，權限範圍不能縮小 注意:不能重寫父類中聲明為private的方法(本身就見不到)，可以在子類中硬寫一個同名的方法，但那就不是構成重寫 若父類被重寫的方法返回值是void，子類重寫的方法也必須返回void
若父類被重寫的方法返回值是A類型，子類重寫的方法返回值可以是A類或A類的子類
舉例:父類返回值是動物類，子類可以重寫返回動物類或貓類狗類 若父類被重寫的方法返回值是基本數據類型，子類重寫的方法返回值必須是相同基本數據類
舉例:父類返回double子類也必須是double，不能是int期待他自動類型提升 拋出異常(throws)的規則與返回值相同
以上白話小結:權限不能小於爸爸、返回值不能大於爸爸
補充:子類與父類同名同參數的方法要嘛都聲明為非static的(考慮重寫)，要嘛都聲明為static的(不是重寫，靜態類的方法不能被覆蓋)
關鍵字super 用來表示父類中的屬性、方法、構造器
調用屬性與方法 可以在子類的方法或構造中，用&amp;quot;super.方法&amp;ldquo;或&amp;rdquo;super.屬性&amp;ldquo;來顯式調用父類中聲明的屬性或方法 就近原則，比如有人很欠揍的在A01類A02類A03類三代中都命名了同為id的屬性，我在A03調super.id會調到A02的id 方法則基本上就是用來區分重寫的子類方法，跟原先父類的同名方法 super不能突破封裝性的限制 調用構造器 在子類的構造器中，顯示使用&amp;rdquo;super(形參列表)&amp;ldquo;顯式調用父類中聲明的指定構造器
&amp;ldquo;super(形參列表)&amp;ldquo;必須聲明在子類構造器的首行
意味著&amp;rdquo;super(形參列表)&amp;ldquo;與&amp;rdquo;this(形參列表)&amp;ldquo;只能二選一 若沒寫則首行預設是一個&amp;rdquo;super()&amp;rdquo;
意味著子類構造器中必定至少存在一個構造器來自於父類 要是在父類中的空參構造器寫了某個特徵，那他所有往下的子類都帶有這個特徵 子類物件實例化的過程 從結果上來看 子類繼承父類後，就獲取了父類聲明的屬性或方法 創建子類的物件，在堆空間中就會加載所有父類中聲明的屬性 從過程上來看 當創建子類的物件時，必定會直接或間接的調用其父類的構造器，層層往上直到調用了java.lang.Object類中的空參構造器為止，正因為加載過所有父類的結構，所以才可以看到內存中有父類的結構，子類物件才可以考慮進行調用 雖然子類創立物件時調用了父類的構造器，但自始至終就只new一個子類的物件 </description>
    </item>
    
    <item>
      <title>項目練習2-客戶訊息管理系統</title>
      <link>https://yoziming.github.io/post/211126-agg-ja-11/</link>
      <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211126-agg-ja-11/</guid>
      <description>項目練習-客戶訊息管理系統 有點基礎這部分都蠻簡單的
有個知識點是這邊在&amp;quot;刪除用戶&amp;quot;的功能用到了循環鏈表的概念
public boolean deleteCustomer(int index) { if (customers[index] != null) { for (int i = index; i &amp;lt; total - 1; i++) { // 不能搬到total，否則[i+1]會越位 customers[i] = customers[i + 1]; } customers[total - 1] = null; total--; System.out.println(&amp;#34;刪除用戶成功!&amp;#34;); return true; } System.out.println(&amp;#34;索引無效，操作失敗&amp;#34;); return false; } total表示當前數組中用戶總數，這個i &amp;lt; total - 1蠻關鍵的，我原先沒想到這邊要-1，還想著讓他把後面的null往前搬就好，沒考慮到末尾可能會越位的情況。
搬完再跟customers[total - 1] = null搭配使用，這樣才是健壯的</description>
    </item>
    
    <item>
      <title>封裝性、構造器、關鍵字this、Package包</title>
      <link>https://yoziming.github.io/post/211125-agg-ja-10/</link>
      <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211125-agg-ja-10/</guid>
      <description>封裝的設計思想 高內聚:類的內部數據操作細節自己完成，不允許外部干涉
低耦合:對外露出少量的方法(API)供使用
舉例:微波爐，我不需要用戶控制燈光、波照、轉盤等等，只要他放入東西按下&amp;quot;解凍&amp;quot;即可。即所謂的&amp;quot;一鍵XX&amp;quot;功能。
封裝性的體現 將類的屬性私有化(private)，通過公共的(public)的set與get方法讓外部調用，舉例: public class Main { public static void main(String[] args) { Animal a1 = new Animal(); a1.setAge(10); System.out.println(a1.getAge()); } } class Animal { private int age; public void setAge(int i) { age = i; } public int getAge() { return age; } } 不對外公開的私有方法(比如對外是各種排序方法，內部自己寫了一個交換兩數據位置的&amp;quot;小工具&amp;quot;) 單例模式(將構造器私有化) &amp;hellip;等等 需要權限修飾符來配合 權限修飾符 JAVA中有4種權限修飾符，各自的範圍是: (從小到大，下包含上)
private:限當前類內部使用 default(缺省，就是不寫):同一個包名就可以調用 protected:不同包它的子類可以調用 public:相當於開放的 修飾的對象 以上4種可以用於修飾類的內部結構:屬性、方法、構造器、內部類 class本身的修飾只能是缺省或public，一個.java檔只能包含一個public類 構造器(constructor) 作用:創立物件、初始化物件的屬性 說明:如果沒有顯示定義構造器，則系統預設提供一個空參的構造器 格式:權限修飾符 類名(形參列表){}，注意構造器名=類名 在一個類中可以定義多個構造器，彼此構成重載，舉例: public class Main { public static void main(String[] args) { Animal a1 = new Animal(5); Animal a2 = new Animal(4, &amp;#34;狗&amp;#34;); } } class Animal { private int age; private String kind; public Animal(int a) { age = a; System.</description>
    </item>
    
    <item>
      <title>物件導向:方法的重載與參數的值傳遞</title>
      <link>https://yoziming.github.io/post/211124-agg-ja-09/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211124-agg-ja-09/</guid>
      <description>細說方法 方法的重載(overload) 定義:同一各類中，允許存在一個以上的同名方法，只要他們的參數個數或參數類型不同即可 跟方法的權限修飾符、返回值類型、形參變量名、方法體無關，判斷重點在於參數本身 可能會自動類型提升，舉例:傳入的是int形，方法中沒有int但有double，就會調用double 典型的例子就是內建的println() 可變個數形參 格式:方法名(形參類型 ... 形參名) 調用時傳入的形參數量可以是0到多個，包含數組 與本類中方法名相同，形參不同的方法間構成重載(可共存) 與本類中方法名相同，形參類型也相同的數組之間不構成重載(不可共存) PS.這是歷史遺留問題，因為可變個數形參是JDK5加入的，以前都是用數組 方法內把它當作數組使用，遍歷itar (i=0;i&amp;lt;形參名.length;i++){} 必須聲明在末尾，且最多只能有一個 方法參數的值傳遞 先複習一下變量的賦值規則 變量是基本數據類型(byte、short、int、long、char、float、double、boolean)，賦值的是變量所保存的數據值 變量是引用類型(引用類型就只有null跟地址值兩種情況)，賦值給的是所保存數據的地址值 名詞解釋 形參:方法定義時，聲明的小括號中的參數 實參:方法調用時，實際傳給形參的數據 傳參規則 跟變量的賦值規則其實相同
如果參數是基本數據類型，實參賦給形參的是數據值(類似給一份副本) 如果參數是引用類型，實參賦給形參的是地址值(包含變量的數據類型) 陷阱題 println在char[]這有個特例，要避免踩坑就是調用時多看看方法格式
int[] arr1 = new int[]{1, 2, 3}; System.out.println(arr1); // [I@1b6d3586 char[] arr2 = new char[]{&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;}; System.out.println(arr2); // abc 練習-在方法中引用其他類的方法並調用 public class Main { public static void main(String[] args) { PassObject t1 = new PassObject(); Circle c = new Circle(); t1.</description>
    </item>
    
    <item>
      <title>物件導向:基本概念與學習路線</title>
      <link>https://yoziming.github.io/post/211123-agg-ja-08/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211123-agg-ja-08/</guid>
      <description>物件導向 Object-oriented programming中國翻為&amp;quot;面向對象&amp;quot;，台灣則翻為物件導向
我個人也覺得&amp;quot;物件導向&amp;quot;翻的比較信雅達，可以參考這篇知乎問答的解釋
https://www.zhihu.com/question/22515658/answer/120754062
概念 首先用咖啡機煮咖啡為例:
過程導向(Process-oriented) 過程導向強調的是功能行為，以函數為最小單位，考慮如何做
執行加咖啡豆方法
執行加水方法
執行煮咖啡方法
執行喝咖啡方法
物件導向(Object-oriented) 物件導向則是先將功能封裝進物件，強調具備功能的物件，以類/物件為最小單位，考慮誰來做
在執行煮咖啡操作前要抽象出：人和咖啡機（分類），然後開始執行：
人.加咖啡豆
人.加水
咖啡機.煮
人.喝咖啡
物件導向的三大特徵 封裝(Encapsulation) 繼承(Inheritance) 多態(Polymorphism) 類和實例 類(class):抽象的模板、概念上的定義
物件(object):是實際存在的個體，也稱為實例(Instance)
比如說有輪子、吃汽油跑的是汽車類。小弟的車new march則為實例
類的設計 設計類其實就是設計類的成員
屬性(field):成員變量，又稱域、字段、欄位
行為(method):成員方法，又稱函數
舉例:汽車類的屬性有輪子大小、有品牌名稱；汽車的行為有吃汽油跑
練習-在JAVA創建類並實例化 class Car { // 屬性 String brand; String owner; boolean isNew = true; // 可以給預設值 // 行為(方法) public void crash() { if (isNew) { System.out.println(owner + &amp;#34;新買的&amp;#34; + brand + &amp;#34;出車禍，很嘔&amp;#34;); } else { System.out.println(&amp;#34;老車，撞就撞了&amp;#34;); } } } public class Main { public static void main(String[] args) { // 實例化 car c1 = new Car(); c1.</description>
    </item>
    
    <item>
      <title>數組:填值/複製/查找/排序、Arrays工具類</title>
      <link>https://yoziming.github.io/post/211122-agg-ja-07/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211122-agg-ja-07/</guid>
      <description>數組常用算法 數據結構 程序=數據結構+演算法
數據間的邏輯關係:集合、一對一、一對多、多對多 數據的儲存結構: 線性表:順序表(如:數組)、鏈表、棧、隊列 樹形結構:二叉樹 圖形結構 演算法-Algorithm 排序
檢索
加密
&amp;hellip;
練習題-帕斯卡三角 形狀不是很漂亮
int[][] arr = new int[10][]; for (int i = 0; i &amp;lt; arr.length; i++) { arr[i] = new int[i + 1]; // 兩外邊都是1 arr[i][0] = 1; arr[i][i] = 1; if (i &amp;gt; 1) { for (int j = 1; j &amp;lt; arr[i].length - 1; j++) { arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j]; } } } for (int i = 0; i &amp;lt; arr.</description>
    </item>
    
    <item>
      <title>數組Array</title>
      <link>https://yoziming.github.io/post/211121-agg-ja-06/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211121-agg-ja-06/</guid>
      <description>數組Array 多個相同類型的數據按一定的順序排列的集合
結構 數組名 元素 下標aka角標/索引 長度(元素的個數) 特性 數組本身是引用數據類型，其中的元素可以是任何類型 數組的排列是有序的 在記憶體中開闢一整塊連續的空間，數組名引用的是這塊連續空間的首地址 長度確定後就不可更改 聲明與初始化 數組必須初始化才能使用
方法1-靜態初始化，創建時填入已知的元素內容，由系統判定長度 int[] array1; // 聲明 array1 = new int[]{1, 2, 3}; // 靜態初始化:同時對元素賦值了 // 也可以合併成 int[] array1 = new int[]{1, 2, 3}; // 可以再縮寫成 (類型推斷) int[] array1 = {1, 2, 3}; 方法2-動態初始化，創建時填入已知的長度，元素內容為0或空(系統預設，後述) int[] array3 = new int[3]; // 動態初始化，注意後面的[5]是指長度 訪問數組內的元素 沒特別的，一樣從0~長度-1。長度=array.length
舉例:array[0]、array[1]&amp;hellip;array[array.length-1]
遍歷 直接print數組會得到類似[I@1b6d3586這樣的一個地址
for (int i = 0; i &amp;lt; array.length; i++) { System.out.println(array[i]); } 以上可用foreach縮寫</description>
    </item>
    
    <item>
      <title>流程控制:嵌套循環、break與continue</title>
      <link>https://yoziming.github.io/post/211120-agg-ja-05/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211120-agg-ja-05/</guid>
      <description>嵌套循環 就是for中有for，有時候需要多花點時間理解
內層循環整個遍歷完，外層循環才執行一次 假設外層循環要執行m次，內層循環要執行n次。整個跑完內層循環一共執行了m*n次 練習題-印菱形 Scanner scan = new Scanner(System.in); System.out.println(&amp;#34;輸入想印的菱形邊長n=...&amp;#34;); int n = scan.nextInt(); // 上半部分(含中間最長邊) for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt; n - i; j++) { System.out.print(&amp;#34; &amp;#34;); } for (int k = 0; k &amp;lt; i; k++) { System.out.print(&amp;#34;* &amp;#34;); } System.out.println(); } // 下半部分(從最長-1開始) for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt; i; j++) { System.</description>
    </item>
    
    <item>
      <title>流程控制:if、switch、for、while</title>
      <link>https://yoziming.github.io/post/211119-agg-ja-04/</link>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211119-agg-ja-04/</guid>
      <description>分支控制 if-else 基礎都一樣不多贅述
特殊情況有人不加{}，這種情境下就近原則且只控制一行(到第一個;為止)
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); System.out.println(&amp;#34;b&amp;#34;); System.out.println(&amp;#34;c&amp;#34;); 結果為 b c 只有單行時可以接else且也會就近選擇
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); else System.out.println(&amp;#34;d&amp;#34;); 結果為d 多行時直接報錯
if (1 == 2) System.out.println(&amp;#34;a&amp;#34;); System.out.println(&amp;#34;b&amp;#34;); System.out.println(&amp;#34;c&amp;#34;); else 報錯 小結:不加{}的全部拖出去打
switch-case 結構:
switch (表達式) { case 常量1: // 執行語句 break; case 常量2... ... default: // 預設執行語句 } 如果不加break;就不會跳出，而是會穿透且之下的語句全都執行一遍
基於上述特性，可以合併使用，舉例:
case 1: case 2: case 3: // 執行語句123的情況 break; case 4: ... 也可以用在需要壘加的情況，舉例 case 9: a += 10 case 8: a += 5 case 7: a += 100 .</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA設定與常用快捷鍵</title>
      <link>https://yoziming.github.io/post/211117-idea-shortkey/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-idea-shortkey/</guid>
      <description>IDEA基礎設定 安裝的根目錄，舉例&amp;hellip;\IntelliJ IDEA 2021.2.3\bin\idea64.exe.vmoptions
編輯這個idea64.exe.vmoptions，改成-Xmx1024m -Xms2048m ctrl+alt+s開啟設定 -&amp;gt; plugins插件 -&amp;gt; 搜尋chinese -&amp;gt; 安裝重啟 -&amp;gt; 中文化
plugins插件 -&amp;gt; 搜尋save actions-&amp;gt; 安裝重啟 -&amp;gt; 存檔時自動格式化
外觀-使用自定義字體打勾-Sarasa mono&amp;hellip;，大小改14
更紗黑體Sarasa-Gothic
https://github.com/be5invis/Sarasa-Gothic 特性:融合Iosevka(程式碼常用的等寬字型)跟Source Han Sans(思源黑)，有等距、繁簡中日韓不缺字，簡直完美 編譯器-字體-一樣改，大小我是設18、行高1.1
插件 常用快捷鍵 視窗 Close All Tabs : alt + w Terminal : ctrl + alt + 0 選取 ctrl + E 最近使用的檔案列表 选中下一个相同内容的快捷键(vs code中的Ctrl+D)：Alt + J 選中匹配的大括號ctrl+] 或 ctrl+[ 快速移動到警告處(黃標或紅標) 以「行」為單位 複製 : ctrl + D 移動 : ctrl + shift + ↑/↓ 註解 : ctrl + / 刪除 : ctrl+x(其實是剪下) 以「區塊」為單位 擴增選取 : ctrl + W 遞減選取 : ctrl + shift + W 更改大小寫 : ctrl + shift + U 自動功能 : 自動補全 : alt + enter 自動產生 : alt + Ins 自動排版 : ctrl + alt + L 其他 顯示形參列表:ctrl+p shift + shift 全域搜索 查找當前文件結構(有哪些方法、屬性):ctrl+F12 ctrl+alt+shift+n 找方法 Ctrl+H查看當前接口或抽象的子類 全部折疊ctrl + shift + -減號 個人設定 快捷鍵 新專案設定 新專案設定，有時候覺得奇怪不是設定過怎又跑掉，原因是在這 比較重要的是這個properties編碼跟save Actions插件的自動格式化、導包等等設定 其他舒適設定 限制開啟視窗數量:File-&amp;gt;Settings-&amp;gt;Editor-&amp;gt;General-&amp;gt;Editor Tab-&amp;gt;Tab limit 過濾顯示檔案 *.</description>
    </item>
    
    <item>
      <title>運算符:邏輯運算、賦值、位運算與三元運算</title>
      <link>https://yoziming.github.io/post/211118-agg-ja-03/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211118-agg-ja-03/</guid>
      <description>運算符 加減乘除 基本都一樣不再贅述
% 取餘的規則 結果的符號與被取餘的數符號相同，舉例-12%5=-2、12%-5=2、-12%-5=-2 實際開發中取餘常用來判斷是否能除盡 自增自減的規則 ++a，(前++)先運算後取值，舉例a=2;b=++a;結果a=3;b=3 a++，先取值後運算，舉例a=2;b=a++;結果a=3;b=2 --a，先運算後取值，舉例a=2;b=--a;結果a=1;b=1 a--，先取值後運算，舉例a=2;b=a--;結果a=1;b=2 自增減不會改變數據類型(但可能會溢位) 不可連用，舉例a++++會報錯 另外+也能用在字符串聯接，舉例&amp;quot;he&amp;quot;+&amp;quot;llo&amp;quot;=&amp;quot;hello&amp;quot;
= 賦值的規則 可以連續賦值，舉例int i1,i2; i1=i2=10; int i3=10,j3=20; +=、-=、*=、/=、%= 不會改變數據類型 面試題n=10; n+=(n++)+(++n); n=? 解: 拆成 n = n + 10 + 12 =32 寫==則是比較運算符，返回boolean 邏輯運算符 乍看邏輯跟短路結果是一樣，實際使用上差異為短路後的東西就不執行了 舉例: b=false; n=10; b &amp;amp;&amp;amp; (n++&amp;gt;0)=false，但n=10 位運算符 操作的都是整數 &amp;laquo; 向左移一位相當於*2，&amp;raquo;向右移一位相當於/2，有可能溢位 三元運算符 結構: (條件表達式) ? 表達式1 : 表達式2 說明: 條件表達式=boolean，如果是true則執行表達式1，反之執行2 表達式1 與 表達式2 要求類型一致(至少能裝進同一個類型) 其實就是簡易版的if，可以嵌套使用 優先級 基本原則是從上到下，從左到右，括號優先 自增減、賦值運算、三元運算才從右往左看 </description>
    </item>
    
    <item>
      <title>關鍵字、變量、數據類型與轉換</title>
      <link>https://yoziming.github.io/post/211117-agg-ja-02/</link>
      <pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211117-agg-ja-02/</guid>
      <description>關鍵字 關鍵字 有特殊含意與用途，所有關鍵字都是小寫
例如:if、new&amp;hellip;等等，後面都會一一接觸到
保留字 未來版本可能會用到而保留
例如:goto、const
標識符(identifier) 可以自己命名的(類、變量、函數&amp;hellip;等)就叫標識符
由字母、數字、_、$組成
數字不可為開頭
能包含關鍵字但不能純用關鍵字
嚴格區分大小寫
不能包含空格
標識符的命名規範 不強制但最好遵守
包名:多單詞所有字母小寫aaabbbccc
類名、接口名:大駝峰(首字母大寫)AaaBbbCcc
變量名、方法名:開頭小寫後面首字母大寫(小駝峰)aaaBbbCcc
常量名:全大寫，用下畫線相連AAA_BBB_CCC
命名要有意義，見名知意
變量(variable) 記憶體中的一個儲存區域，使用的基本單位
必須先聲明，後使用 作用域在其定義所在的一對{}內，只在其作用域中有效 同一作用域中不可重複 數據類型 基礎數據類型 六種數字類型（四個整數型，兩個浮點型），一種字符類型，還有一種布爾型
byte byte數據類型是8位、有符號的，以二進制補碼表示的整數 最小值是-128（-2^7）最大值是127（2^7-1）預設值是0 byte類型用在大型數組中節約空間，主要代替整數，因為byte變量佔用的空間只有int類型的四分之一 例子：byte a = 100，byte b = -50 short short數據類型是16位、有符號的以二進制補碼表示的整數 最小值是-32768（-2^15）最大值是32767（2^15 - 1）預設值是0 Short數據類型也可以像byte那樣節省空間 一個short變量是int型變量所佔空間的二分之一 例子：short s = 1000，short r = -20000 int int數據類型是32位、有符號的以二進制補碼表示的整數 最小值是-2,147,483,648（-2^31）最大值是2,147,483,647（2^31 - 1）預設值是0 一般整型變量預設為int類型 例子：int a = 100000, int b = -200000 long long數據類型是64位、有符號的以二進制補碼表示的整數 最小值是-9,223,372,036,854,775,808（-2^63） 最大值是9,223,372,036,854,775,807（2^63 -1） 這種類型主要使用在需要比較大整數的系統上 必須以L(大小都可)結尾，不加自動被當成int 預設值是0L 例子： long a = 100000L，Long b = -200000L float float的儲存結構是1個符號位，8個指數位，23個尾數，符合IEEE 754標準的浮點數 可以看做float只有24位來表示精度，所以int或long轉``float可能會有精度損失 必須以F(大小都可)結尾，不加報錯 預設值是0.</description>
    </item>
    
    <item>
      <title>Java簡介、環境配置、HelloWorld</title>
      <link>https://yoziming.github.io/post/211116-agg-ja-01/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/211116-agg-ja-01/</guid>
      <description>本筆記基於這份2019年4月的公開教學影片 尚硅谷Java入门视频教程(在线答疑+Java面试真题) https://www.bilibili.com/video/BV1Kb411W75N?p=1
認識Java、環境配置 常用DOS操作 就是windows的cmd，影視中駭客情節常常出現的小黑窗，可以用文字操作基本的軟體功能
cd=進入指定目錄
cd..=回上層
cd=回到根目錄
變更硬碟目錄=直接輸入d:
dir=列出當前目錄下的清單
del=刪除檔案(對文件夾使用=刪除文件內所有檔案)
md=創建目錄
rd=刪除目錄
exit=退出
Java體系在不同平台的版本演化 Java SE，標準版，桌面級應用等，基礎API Java EE，企業版，主要用於Web開發，包含Servlet、JSP等技術 Java ME，小型版，古老的PDA、手機等，已過時 Java Card，面向小程序(Applets)，運行在小設備(如智能卡)等平台 Java語言特性 由繼承的脈絡可說JAVA是類C語言
強制物件導向:總是基於&amp;quot;某件東西去做事&amp;quot;，得先搞懂何謂&amp;quot;類&amp;quot;與&amp;quot;物件&amp;quot; 三大特性:封裝、繼承、多態 健壯性:強類型、異常處理、GC(垃圾回收)、丟棄指針等 跨平台:只要平台能跑JVM(虛擬機)就能跑JAVA Java的運行環境 JDK包含JRE包含JVM
JDK，Java Development Kit，開發工具包，給開發人員用的，包含了JRE以及編譯工具(javac.exe)、打包工具(jar.exe)&amp;hellip;等等。 JRE，Java Runtime Environment，運行環境，包含JVM虛擬機和運作需要的核心類庫等等，簡單說就是運行由JDK做好的東西。 Java環境配置 下載JDK 8u202版本，最後的商用免費版(若純個人使用不論版本都是免費的)
https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html 配置環境變數(win10為例)
PATH=windows cmd執行命令語句時搜索執行檔的位置
WIN10-設定-系統(左上)-關於(左下)-進階系統設定(右方)-進階-環境變數-系統變數 PATH=%JAVA_HOME%;%JAVA_HOME%\bin JAVA_HOME=G:\Java\jdk1.8.0_202\ (你的JDK安裝位置) 檢驗，任意處開一個cmd，輸入
java -version javac.exe Java的編譯 .java(源文件) -&amp;gt; javac.exe(編譯) -&amp;gt; .class(二進制文件) -&amp;gt; java.exe(運行) -&amp;gt; 結果
HelloWorld 記事本創建一個HelloWorld.java
class HelloWorld { public static void main(String[] args) { System.</description>
    </item>
    
    <item>
      <title>Java UML類圖</title>
      <link>https://yoziming.github.io/post/220102-java-uml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yoziming.github.io/post/220102-java-uml/</guid>
      <description>Java UML類圖 引用 https://blog.51cto.com/u_15060461/3937024
思緒不清晰的時候，畫圖可以有效幫助解決問題 繪圖軟體推薦:draw.io，開源免費公認好用 也有線下版 https://github.com/jgraph/drawio-desktop/releases/tag/v16.1.2 類圖 ![uml (1)](uml (1).png)
-:private，當前類 ~:default，同包 #:protected，可跨包的子類 +:public 斜體:抽象 _:static，靜態 關係圖 ![uml (2)](uml (2).png)
空心三角形實線:extends繼承
空心三角形虛線:implement實現接口
或是棒棒糖 虛線箭頭:依賴，就是用到，比如用到它的屬性或作為方法參數、返回
動物需要氧氣進行呼吸方法 實線箭頭:關聯，就是指向，類似SQL的外鍵
人與身分證關聯 空心菱形+實線(箭頭):聚合，強調部分與整體，但部分可脫離整體
菱形是整體，例如電視◇-遙控器 兩者生命週期不同，比如大雁群死了一個大雁還存在 實心菱形+實線(箭頭):組合，也是部分與整體，但強調不可脫離
兩者生命週期一致，如鳥⬥-翅膀，人⬥-腦袋 類之間關係的強弱：依賴 &amp;lt; 關聯 &amp;lt; 聚合 &amp;lt; 組合 &amp;lt; 泛化（繼承）</description>
    </item>
    
  </channel>
</rss>
