<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yoziming&#39; Blog</title>
    <link>https://yoziming.github.io/</link>
    <description>Recent content on yoziming&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>yoziming</copyright>
    <lastBuildDate>Tue, 23 Nov 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yoziming.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>尚硅谷JAVA基礎課-DAY08筆記</title>
        <link>https://yoziming.github.io/post/211123-%E5%B0%9A%E8%AA%B2java-day08/</link>
        <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211123-%E5%B0%9A%E8%AA%B2java-day08/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211123-%E5%B0%9A%E8%AA%B2java-day08/ -&lt;h1 id=&#34;day08-物件導向&#34;&gt;DAY08-物件導向&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Object-oriented programming中國翻為&amp;quot;面向對象&amp;quot;，台灣則翻為物件導向，我個人也是認為&amp;quot;物件導向&amp;quot;翻的比較信雅達，可以參考這篇知乎問答的解釋&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/22515658/answer/120754062&#34;&gt;https://www.zhihu.com/question/22515658/answer/120754062&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;過程導向物件導向的區別&#34;&gt;過程導向/物件導向的區別&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用咖啡機煮咖啡為例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;過程導向process-oriented-programming&#34;&gt;過程導向(Process-oriented programming)：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;執行加咖啡豆方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;執行加水方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;執行煮咖啡方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;執行喝咖啡方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;過程導向強調的是功能行為，以&lt;strong&gt;函數為最小單位，考慮如何做&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;物件導向object-oriented-programming&#34;&gt;物件導向(Object-oriented programming)：&lt;/h4&gt;
&lt;p&gt;在執行煮咖啡操作前要抽象出：人和咖啡機（分類），然後開始執行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;人.加咖啡豆&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;人.加水&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;咖啡機.煮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;人.喝咖啡&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;物件導向則是先將功能封裝進物件，強調具備功能的物件，以&lt;strong&gt;類/物件為最小單位，考慮誰來做&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;物件導向的三大特徵&#34;&gt;物件導向的三大特徵&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;封裝(Encapsulation)&lt;/li&gt;
&lt;li&gt;繼承(Inheritance)&lt;/li&gt;
&lt;li&gt;多態(Polymorphism)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;類和實例&#34;&gt;類和實例&lt;/h3&gt;
&lt;p&gt;類(class):抽象的模板、概念上的定義&lt;/p&gt;
&lt;p&gt;物件(object):是實際存在的個體，也稱為實例(Instance)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比如說有輪子、吃汽油跑的是汽車類。小弟的車new march則為實例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;類的設計&#34;&gt;類的設計&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;設計類其實就是設計類的成員&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;屬性(field):成員變量，又稱域、字段、欄位&lt;/p&gt;
&lt;p&gt;行為(method):成員方法，又稱函數&lt;/p&gt;
&lt;p&gt;舉例:汽車類的屬性有輪子大小、有品牌名稱；汽車的行為有吃汽油跑&lt;/p&gt;
&lt;h3 id=&#34;練習-在java創建類並實例化&#34;&gt;練習-在JAVA創建類並實例化&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Car {
    // 屬性
    String brand;
    String owner;
    boolean isNew = true; // 可以給預設值

    // 行為(方法)
    public void crash() {
        if (isNew) {
            System.out.println(owner + &amp;quot;新買的&amp;quot; + brand + &amp;quot;出車禍，很嘔&amp;quot;);
        } else {
            System.out.println(&amp;quot;老車，撞就撞了&amp;quot;);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // 實例化
        car c1 = new Car();
        c1.owner = &amp;quot;小弟&amp;quot;;
        c1.brand = &amp;quot;march&amp;quot;;

        // 調用
        c1.crash();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;屬性成員變量與局部變量的差異&#34;&gt;屬性(成員變量)與局部變量的差異&lt;/h3&gt;
&lt;h4 id=&#34;聲明的位置&#34;&gt;聲明的位置:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;屬性:直接放在類的一對{}內&lt;/li&gt;
&lt;li&gt;局部變量:聲明在方法、方法形餐、代碼塊、構造器形參、構造器內部的變量&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;記憶體中位置&#34;&gt;記憶體中位置:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;屬性:對於非static的屬性，放在堆。
&lt;ul&gt;
&lt;li&gt;static為線程共享，在類加載階段就實例化，放在方法區&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局部變量:放在棧&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;權限修飾符&#34;&gt;權限修飾符:&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;封裝時會用到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;屬性:可以在聲明時修飾權限，常見的有private、public、protected、缺省&lt;/li&gt;
&lt;li&gt;局部變量:只允許使用final&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;默認初始化狀態&#34;&gt;默認初始化狀態:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;屬性:根據其類型有對應的默認值，也可以在聲明時自定義&lt;/li&gt;
&lt;li&gt;局部變量:沒有默認初始化值，調用之前一定要顯示賦值，否則報錯。
&lt;ul&gt;
&lt;li&gt;形參則是調用時賦值即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法的聲明與使用&#34;&gt;方法的聲明與使用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;方法:描述類應該具有的功能，例如:狗類會汪汪叫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;聲明格式&#34;&gt;聲明格式:&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;方法名是標示符，依規範用小駝峰(舉例:touchCat)表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;權限修飾符 返回值類型 方法名(形參列表){
//方法體
}
舉例:public void sleep(int hour){} // void=無返回值
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;權限修飾符-1&#34;&gt;權限修飾符:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;常見的4種為private、public、protected、缺省&lt;/li&gt;
&lt;li&gt;進階的有static、final、abstract後面封裝時再講&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;返回值與形參&#34;&gt;返回值與形參:&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;有沒有返回值跟形參，要看具體情境判斷&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果有返回值，必須在聲明時指定返回值的類型，且方法中必須使用&amp;quot;return 數據&amp;quot;返回該類型的變量或常量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若沒有返回值，聲明時用void，通常就不用return；也可以用，但只能純&amp;quot;return&amp;quot;表示結束方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以聲明0或多個形參，格式:數據類型1 形參1,數據類型2 形參2,&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用注意&#34;&gt;使用注意:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;方法中可以調用當前類的屬性或其他方法&lt;/li&gt;
&lt;li&gt;也可以調用自己(遞歸調用)，但切記要能閉合而不是造成無限循環&lt;/li&gt;
&lt;li&gt;方法中不能再定義方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;練習-建立一個學生類的數組&#34;&gt;練習-建立一個學生類的數組&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;創建一個學生類，包含學號1~20、隨機的年級與成績，用數組表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Student[] stus = new Student[20];
        for (int i = 0; i &amp;lt; 20; i++) {
            stus[i] = new Student(); // 相當於給數組中的每個元素賦值
            stus[i].number = i + 1;
            stus[i].state = (int) (Math.random() * 6 + 1);
            stus[i].score = (int) (Math.random() * 101);
        }
        for (int i = 0; i &amp;lt; stus.length; i++) {
            System.out.println(&amp;quot;學號&amp;quot; + stus[i].number + &amp;quot;,年級是&amp;quot; + stus[i].state + &amp;quot;,成績是&amp;quot; + stus[i].score);
        }
    }
}

class Student {
    int number;
    int state;
    int score;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重點:new了數組stus後，其中每一個物件stus[n]也都需要new才能使用&lt;/p&gt;
&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;h3 id=&#34;學習物件導向的三條主線&#34;&gt;學習物件導向的三條主線&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;類及類的成員:屬性、方法、構造器；代碼塊、內部類&lt;/li&gt;
&lt;li&gt;物件導向特徵:封裝、繼承、多態、抽象&lt;/li&gt;
&lt;li&gt;其他關鍵字:this、super、abstract、interface、static、final、package、import&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;類與物件的操作順序&#34;&gt;類與物件的操作順序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;創建類，定義屬性、方法&lt;/li&gt;
&lt;li&gt;類的實例化(new一個該類的物件)&lt;/li&gt;
&lt;li&gt;調用物件的結構(物件.屬性、物件.方法)&lt;/li&gt;
&lt;/ol&gt;
- https://yoziming.github.io/post/211123-%E5%B0%9A%E8%AA%B2java-day08/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>尚硅谷JAVA基礎課-DAY07筆記</title>
        <link>https://yoziming.github.io/post/211122-%E5%B0%9A%E8%AA%B2java-day07/</link>
        <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211122-%E5%B0%9A%E8%AA%B2java-day07/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211122-%E5%B0%9A%E8%AA%B2java-day07/ -&lt;h1 id=&#34;day07-數組常用算法&#34;&gt;DAY07-數組常用算法&lt;/h1&gt;
&lt;h2 id=&#34;數據結構簡述&#34;&gt;數據結構簡述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;程序=數據結構+演算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;數據結構&#34;&gt;數據結構&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;數據間的邏輯關係:集合、一對一、一對多、多對多&lt;/li&gt;
&lt;li&gt;數據的儲存結構:
&lt;ul&gt;
&lt;li&gt;線性表:順序表(如:數組)、鏈表、棧、隊列&lt;/li&gt;
&lt;li&gt;樹形結構:二叉樹&lt;/li&gt;
&lt;li&gt;圖形結構&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;演算法-algorithm&#34;&gt;演算法-Algorithm&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檢索&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;練習題-帕斯卡三角&#34;&gt;練習題-帕斯卡三角&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;形狀不是很漂亮&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;image-20211120160204410.png&#34; alt=&#34;image-20211120160204410&#34;&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int[][] arr = new int[10][];
for (int i = 0; i &amp;lt; arr.length; i++) {
    arr[i] = new int[i + 1];
    // 兩外邊都是1
    arr[i][0] = 1; 
    arr[i][i] = 1;
    if (i &amp;gt; 1) {
        for (int j = 1; j &amp;lt; arr[i].length - 1; j++) {
            arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j];
        }
    }
}
for (int i = 0; i &amp;lt; arr.length; i++) {
    for (int j = 0; j &amp;lt; arr[i].length; j++) {
        System.out.print(arr[i][j] + &amp;quot;\t&amp;quot;);
    }
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;題外話-關於行列&#34;&gt;題外話-關於行列&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;台灣教育部規定跟小學老師教的是&amp;quot;直行橫列&amp;quot;，但這個已經不合時宜了&lt;/p&gt;
&lt;p&gt;比如說&amp;quot;一行文字&amp;quot;，現代人直覺想到是橫的一行字；程式碼&amp;quot;line幾&amp;quot;我們也說&amp;quot;第幾行&amp;quot;&lt;/p&gt;
&lt;p&gt;如果溝通時混淆可以用英文，這有個記憶小訣竅&lt;/p&gt;
&lt;p&gt;column，看col中的l就是直的，列。而row，寫w是橫著寫過去，所以是橫的，行&lt;/p&gt;
&lt;p&gt;中國、日本都是這樣用，確實比較合理。現在連公文都橫式了，台灣教育部不改革真的失職&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;難題-螺旋矩陣&#34;&gt;難題-螺旋矩陣&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;這個leetcode中等難度了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int n = 5;
int[][] arr = new int[n][n];
int count = 0; // 填入的數值
int maxX = n - 1; // x軸最大下標
int maxY = n - 1;
int minX = 0; // x軸最小下標
int minY = 0;
while (minX &amp;lt;= maxX) {
    for (int x = minX; x &amp;lt;= maxX; x++) { // 左到右
        arr[minY][x] = ++count; // y不變，x從0、1、2..直到填滿
    }
    minY++; // 走到右上角頂了，此時x固定，開始加+Y往下走
    for (int y = minY; y &amp;lt;= maxY; y++) { // 右到下
        arr[y][maxX] = ++count;
    }
    maxX--;
    for (int x = maxX; x &amp;gt;= minX; x--) { // 下到左
        arr[maxY][x] = ++count;
    }
    maxY--;
    for (int y = maxY; y &amp;gt;= minY; y--) { // 左到上
        arr[y][minX] = ++count;
    }
    minX++;
}
// 印
for (int i = 0; i &amp;lt; arr.length; i++) {
    for (int j = 0; j &amp;lt; arr[i].length; j++) {
        System.out.print(arr[i][j] + &amp;quot;\t&amp;quot;);
    }
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;java產生隨機數&#34;&gt;JAVA產生隨機數&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Math.random()方法是返回一個0到1之間，前閉後開[)aka含前不含後的double值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(int)(Math.random()*10) // 返回0到9的隨機整數
(int)(Math.random()*n) // 返回0到n-1的隨機整數
(int)(Math.random()*100)+1 // 返回1到100的隨機整數
(int)(Math.random() * (99 - 10 + 1) + 10) // 返回2位正整數[10,99]
(int)(Math.random()*(MAX-min+1)) + min // 返回min到m的隨機整數
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;數組的淺複製&#34;&gt;數組的淺複製&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;JAVA中引用類型互相賦值其實是傳遞指針，舉例:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int[] arr1 = {1, 2, 3};
int[] arr2;
arr2 = arr1; // 其實是指到同一個記憶體地址了，畢竟沒有new東西
arr2[0] = 9;
System.out.print(&amp;quot;arr2=\t&amp;quot;);
for (int j : arr2) { // 順便練習一下for-each遍歷數組
    System.out.print(j + &amp;quot;\t&amp;quot;);
}
System.out.print(&amp;quot;arr1=\t&amp;quot;);
for (int j : arr1) {
    System.out.print(j + &amp;quot;\t&amp;quot;);
}
// arr1跟arr2的[0]都變成9
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;真正複製數組&#34;&gt;真正複製數組&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;new一個然後一一對應賦值，舉例:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int[] arr2 = new int[10];
for (int i = 0; i &amp;lt; arr1.length; i++) {
    arr2[i] = arr1[i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;數組序列反轉&#34;&gt;數組序列反轉&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;記得/2，不然又全換回去&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (int i = 0; i &amp;lt; arr.length / 2; i++) {
    int tmp = arr[i];
    arr[i] = arr[arr.length - i - 1];
    arr[arr.length - i - 1] = tmp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 方法2
for (int i = 0, j = arr.length - 1; i &amp;lt; j; i++, j--) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;數組的查找&#34;&gt;數組的查找&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;比對String是否相同使用.equals()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String[] arr = {&amp;quot;李四&amp;quot;, &amp;quot;王五&amp;quot;, &amp;quot;劉六&amp;quot;, &amp;quot;張三&amp;quot;};
String dest = &amp;quot;張三&amp;quot;;
boolean flag = true;
for (int i = 0; i &amp;lt; arr.length; i++) {
    if (dest.equals(arr[i])) {
        flag = false;
        System.out.println(&amp;quot;找到對應元素，下標為&amp;quot; + i);
    }
}
if (flag) {
    System.out.println(&amp;quot;查無結果&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;二分查找&#34;&gt;二分查找&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;重點在於建立head、middle、end三個下標索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int[] arr = {1, 20, 22, 41, 52, 53, 67, 75, 80, 99};
int dest = 80;
// 二分查找
int head = 0; // 索引首
int end = arr.length - 1; // 索引尾
boolean flag = true;
while (head &amp;lt;= end) {
	int mid = (head + end) / 2; // 這個mid每輪都要更新不能放在while外
	if (dest == arr[mid]) {
		System.out.println(&amp;quot;找到了，下標為&amp;quot; + mid);
		flag = false;
		break;
	} else if (dest &amp;lt; arr[mid]) {
		end = mid - 1;
	} else {
		head = mid + 1;
	}
}
if (flag) {
	System.out.println(&amp;quot;沒找到&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;h3 id=&#34;衡量排序法優劣的指標&#34;&gt;衡量排序法優劣的指標&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;時間複雜度:比較的次數、移動的次數&lt;/li&gt;
&lt;li&gt;空間複查度:所需記憶體&lt;/li&gt;
&lt;li&gt;穩定性:若序列中A與B的關鍵字值相等，排序後A、B次序保持不變，稱為穩定的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;排序分類&#34;&gt;排序分類&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;內部排序:不需要額外的儲存器(如硬碟)，在記憶體中就能完成&lt;/li&gt;
&lt;li&gt;外部排序:參與的數據量極大，需藉由外部儲存協助完成，常見的有多路歸併排序。可以認為外部排序是多次配部排序組成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;十大經典排序法&#34;&gt;十大經典排序法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hustcc/JS-Sorting-Algorithm&#34;&gt;https://github.com/hustcc/JS-Sorting-Algorithm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;動態圖文講解+各大語言實例，簡直完美&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;確定性算法的五大特徵&#34;&gt;確定性算法的五大特徵&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;輸入:有0或多個輸入數據，必須清楚描述與定義&lt;/li&gt;
&lt;li&gt;輸出:至少1個輸出結果，不可沒有結果&lt;/li&gt;
&lt;li&gt;有限性:不可無限循環，且每步驟在可接受的時間內完成&lt;/li&gt;
&lt;li&gt;明確性:每一步都有明確含意，不可有歧意&lt;/li&gt;
&lt;li&gt;可行性:每一步都是清楚可行的，能讓用戶紙筆記算求出答案&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java冒泡排序bubble-sort&#34;&gt;JAVA冒泡排序(Bubble Sort)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;N個元素要進行冒泡排序，最多總共進行N-1趟排序，第i趟的比較次數為(N-i)次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (int i = 0; i &amp;lt; arr.length - 1; i++) { // 外圈循環趟數
    for (int j = 0; j &amp;lt; arr.length - i - 1; j++) { // 內圈比較次數
        if (arr[j] &amp;gt; arr[j + 1]) { // 若前比後大則交換。排完由小到大
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;arrays工具類的使用&#34;&gt;Arrays工具類的使用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;util包提供常用的功能如下，還有很多可以自己探索&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Arrays.equals(arr1,arr2)，判斷2數組是否完全相符
Arrays.toString(arr)，將arr完整轉成string，方便印出
Arrays.fill(arr,n)，將n作為元素填滿數組，方便初始化
Arrays.sort(arr)，快速排序
Arrays.binarySearch(arr,dest)，二分查找返回下標或負數(找不到)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;生成0到99長度為n的序列並排序&#34;&gt;生成0到99長度為n的序列並排序&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// creat and print array
int n = 10; // arr.length
int[] arr = new int[n];
for (int i = 0; i &amp;lt; arr.length; i++) {
    arr[i] = (int) (Math.random() * 100);
}
System.out.println(&amp;quot;arr=&amp;quot; + Arrays.toString(arr));
// sort
Arrays.sort(arr);
// print array after sort
System.out.println(&amp;quot;arr&#39;=&amp;quot; + Arrays.toString(arr));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;數組常見的錯誤&#34;&gt;數組常見的錯誤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ArrayIndexOutOfBoundsException，下標越界&lt;/li&gt;
&lt;li&gt;NullPointerException，空指針異常，比如想存取一個引用類型其中某元素但沒賦值的情況&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211122-%E5%B0%9A%E8%AA%B2java-day07/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>尚硅谷JAVA基礎課-DAY06筆記</title>
        <link>https://yoziming.github.io/post/211121-%E5%B0%9A%E8%AA%B2java-day06/</link>
        <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211121-%E5%B0%9A%E8%AA%B2java-day06/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211121-%E5%B0%9A%E8%AA%B2java-day06/ -&lt;h1 id=&#34;day06-數組array&#34;&gt;DAY06-數組Array&lt;/h1&gt;
&lt;h2 id=&#34;一維數組&#34;&gt;一維數組&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;多個相同類型的數據按一定的順序排列的集合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;結構&#34;&gt;結構&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;數組名&lt;/li&gt;
&lt;li&gt;元素&lt;/li&gt;
&lt;li&gt;下標aka角標/索引&lt;/li&gt;
&lt;li&gt;長度(元素的個數)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;特性&#34;&gt;特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;數組本身是引用數據類型，其中的元素可以是任何類型&lt;/li&gt;
&lt;li&gt;數組的排列是有序的&lt;/li&gt;
&lt;li&gt;在記憶體中開闢一整塊連續的空間，數組名引用的是這塊連續空間的首地址&lt;/li&gt;
&lt;li&gt;長度確定後就&lt;strong&gt;不可更改&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;聲明與初始化&#34;&gt;聲明與初始化&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;數組必須初始化才能使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;方法1-靜態初始化，創建時填入已知的元素內容，由系統判定長度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int[] array1; // 聲明
array1 = new int[]{1, 2, 3}; // 靜態初始化:同時對元素賦值了
// 也可以合併成
int[] array1 = new int[]{1, 2, 3};
// 可以再縮寫成 (類型推斷)
int[] array1 = {1, 2, 3};
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;方法2-動態初始化，創建時填入已知的長度，元素內容為0或空(系統默認，後述)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int[] array3 = new int[3]; // 動態初始化，注意後面的[5]是指長度
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;訪問數組內的元素&#34;&gt;訪問數組內的元素&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;沒特別的，一樣從0~長度-1。長度=array.length&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;舉例:array[0]、array[1]&amp;hellip;array[array.length-1]&lt;/p&gt;
&lt;h3 id=&#34;遍歷&#34;&gt;遍歷&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;直接print數組會得到類似[I@1b6d3586這樣的一個地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (int i = 0; i &amp;lt; array.length; i++) {
    System.out.println(array[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上可用for-each縮寫&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (int j : array) {
    System.out.println(j);
}
// 這是JAVA5後增加的for-each寫法，用在不管下標，專門只遍歷的情境，格式為
for(元素的數據類型 變量 : Collection集合or數組){
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;各種元素的系統默認值&#34;&gt;各種元素的系統默認值&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;剛剛提到動態初始化時，只定了長度，元素內容由系統賦予默認值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;整型(byte、short、int)為0&lt;/li&gt;
&lt;li&gt;浮點數為0.0&lt;/li&gt;
&lt;li&gt;char為\u0000(ASCII碼的null)，不是&#39;0&amp;rsquo;也不是空格(空格的編號是\u0020)，就顯示為空，要注意&lt;/li&gt;
&lt;li&gt;boolean為false&lt;/li&gt;
&lt;li&gt;引用數據類型則為null，就是空&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一維數組在記憶體中的情況&#34;&gt;一維數組在記憶體中的情況&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;比較複雜，引用課堂的截圖&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Kb411W75N?p=146&amp;amp;t=763.1&#34;&gt;https://www.bilibili.com/video/BV1Kb411W75N?p=146&amp;amp;t=763.1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;image-20211119215010800.png&#34; alt=&#34;image-20211119215010800&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;棧裡面放局部變量&lt;/li&gt;
&lt;li&gt;堆裡面放new出來的東西&lt;/li&gt;
&lt;li&gt;這張圖是簡單表示執行右上角的程式碼時記憶體中發生的事&lt;/li&gt;
&lt;li&gt;有瑕疵，因為string也是引用類型，那個劉德華、張學友其實不是那樣&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;練習題-學生成績分級&#34;&gt;練習題-學生成績分級&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;輸入學生人數與成績，找出最高分，並依照最高分-10以內為A級、-20為B、-30為C、其餘不及格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Scanner scan = new Scanner(System.in);
System.out.println(&amp;quot;輸入學生人數&amp;lt;數字正整數&amp;gt;...&amp;quot;);
int stuNum = scan.nextInt();
int[] stuScore = new int[stuNum];
int maxScore = 0;
for (int i = 0; i &amp;lt; stuNum; i++) {
    System.out.println(&amp;quot;輸入學生編號&amp;quot; + (i + 1) + &amp;quot;的成績&amp;lt;數字正整數&amp;gt;...&amp;quot;);
    stuScore[i] = scan.nextInt();
    if (stuScore[i] &amp;gt; maxScore) {
        maxScore = stuScore[i];
    }
}
System.out.println(&amp;quot;成績登記完畢，最高分為&amp;quot; + maxScore);
for (int i = 0; i &amp;lt; stuNum; i++) {
    if ((maxScore - stuScore[i]) &amp;lt;= 10) {
        System.out.println(&amp;quot;學生編號&amp;quot; + (i + 1) + &amp;quot;的成績為A等級&amp;quot;);
    } else if ((maxScore - stuScore[i]) &amp;lt;= 20) {
        System.out.println(&amp;quot;學生編號&amp;quot; + (i + 1) + &amp;quot;的成績為B等級&amp;quot;);
    } else if ((maxScore - stuScore[i]) &amp;lt;= 30) {
        System.out.println(&amp;quot;學生編號&amp;quot; + (i + 1) + &amp;quot;的成績為C等級&amp;quot;);
    } else {
        System.out.println(&amp;quot;學生編號&amp;quot; + (i + 1) + &amp;quot;的成績不及格&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;二維數組&#34;&gt;二維數組&lt;/h2&gt;
&lt;h3 id=&#34;聲明&#34;&gt;聲明&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 靜態初始
int[][] arr1 = new int[][]{{1, 2}, {3, 4, 5}, {6}};
// 靜態+類型推斷
int[][] arr2 = {{1, 2}, {3, 4, 5}, {6}};
// 動態初始1
String[][] arr3 = new String[4][5]; //相當於一個4X5的表格
// 動態初始2
String[][] arr4 = new String[3][]; // 已知行，省略列。反之報錯
String[][][] arr6 = new String[3][][]; //相當於3X?X?的表格，總之第一個[](外層元素)必須指定長度

// 也正確的寫法，容易混淆不建議
int[] arr5[] = {{1, 2}, {3, 4, 5}, {6}};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;遍歷-1&#34;&gt;遍歷&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int[][] arr = {{1, 2, 3}, {4, 5}};
for (int i = 0; i &amp;lt; arr.length; i++) {
    for (int j = 0; j &amp;lt; arr[i].length; j++) {
        System.out.print(arr[i][j]);
    }
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;記憶體解析&#34;&gt;記憶體解析&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int[][] arr = new int[3][4];
System.out.println(arr);
// [[I@1b6d3586，[[表示二維數組
System.out.println(arr[0]);
// 得到[I@4554617c，[表示一維數組，I表示類型是int，@地址位置
int[][] arr2 = new int[3][];
System.out.println(arr2[0]); // 得到null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;image-20211120132815535.png&#34; alt=&#34;image-20211120132815535&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;外層元素在棧，也是外層元素(第一個[])必須指定長度的原因&lt;/p&gt;
&lt;h3 id=&#34;練習題-二維數組邏輯判斷&#34;&gt;練習題-二維數組邏輯判斷&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image-20211120135915226.png&#34; alt=&#34;image-20211120135915226&#34;&gt;&lt;/p&gt;
- https://yoziming.github.io/post/211121-%E5%B0%9A%E8%AA%B2java-day06/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>台灣IT人常唸錯的英文單字</title>
        <link>https://yoziming.github.io/post/211120-%E5%8F%B0%E7%81%A3it%E4%BA%BA%E5%B8%B8%E5%94%B8%E9%8C%AF%E7%9A%84%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/</link>
        <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211120-%E5%8F%B0%E7%81%A3it%E4%BA%BA%E5%B8%B8%E5%94%B8%E9%8C%AF%E7%9A%84%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211120-%E5%8F%B0%E7%81%A3it%E4%BA%BA%E5%B8%B8%E5%94%B8%E9%8C%AF%E7%9A%84%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/ -&lt;h1 id=&#34;台灣it人常唸錯的英文單字&#34;&gt;台灣IT人常唸錯的英文單字&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;目標非最正宗精準的發音，而是不要太離譜、甚至產生歧意，便於溝通理解就可以&lt;/p&gt;
&lt;p&gt;非母語有一些口音在所難免，不要太care不重要的小細節&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;null，有些人念&amp;quot;怒偶&amp;quot;，正確美式念法應為&amp;quot;那歐&amp;quot;(歐音近乎省略)，鬧，或NO，但這跟區域、國籍很有關係，大致都能懂不用太強求&lt;/p&gt;
&lt;p&gt;modem，錯誤&amp;quot;某店&amp;quot;，正確&amp;quot;ㄇㄡ-等&amp;quot;&lt;/p&gt;
&lt;p&gt;mobile，錯誤&amp;quot;摸比歐&amp;quot;，正確&amp;quot;ㄇㄡ-ㄅㄛˇ&amp;quot;&lt;/p&gt;
&lt;p&gt;maintain，man-ten，動詞維護&lt;/p&gt;
&lt;p&gt;maintenance，名詞維護，念&amp;quot;咩-特-ㄋㄜˇ-死&amp;quot;4個音，重音在特&lt;/p&gt;
&lt;p&gt;module，正確&amp;quot;媽-啾&amp;quot;&lt;/p&gt;
&lt;p&gt;lambda，正確&amp;quot;ㄌ一ㄢ-打&amp;quot;&lt;/p&gt;
&lt;p&gt;hidden，錯誤&amp;quot;嗨-等&amp;quot;，正確&amp;quot;he-等&amp;quot;&lt;/p&gt;
&lt;p&gt;suite，錯誤&amp;quot;訴-特&amp;quot;，正確&amp;quot;sweet&amp;quot;，發音相同都是swēt&lt;/p&gt;
&lt;p&gt;virtual，錯誤&amp;quot;V-糗&amp;quot;，正確&amp;quot;ver-秋歐&amp;quot;，虛擬的&lt;/p&gt;
&lt;p&gt;Visual，正確&amp;quot;V-九歐&amp;quot;，視覺的，微軟的vs code是這個&lt;/p&gt;
&lt;p&gt;register，錯誤&amp;quot;re-季-ster&amp;quot;，正確&amp;quot;ㄌㄩㄝ-幾-ster&amp;quot;&lt;/p&gt;
&lt;p&gt;Arduino，正確&amp;quot;阿督衣no&amp;quot;&lt;/p&gt;
&lt;p&gt;Azure，正確&amp;quot;阿九兒&amp;quot;，連一起速念&lt;/p&gt;
&lt;p&gt;parameter，錯誤&amp;quot;怕拉-咪特&amp;quot;，正確&amp;quot;ㄆ˙-ㄌㄩㄚ-ㄇ-特&amp;quot;4個音，第一是輕聲ㄆ，重音在第二個音節&lt;/p&gt;
&lt;p&gt;error，錯誤&amp;quot;ㄟ摟&amp;quot;，正確&amp;quot;ㄟ-惹&amp;quot;&lt;/p&gt;
&lt;p&gt;copy，錯誤&amp;quot;摳比&amp;quot;，正確&amp;quot;咖匹&amp;quot;&lt;/p&gt;
&lt;p&gt;result，錯誤&amp;quot;re-造&amp;quot;，正確&amp;quot;re-奏特&amp;quot;，奏特連念&lt;/p&gt;
&lt;p&gt;chrome，錯誤&amp;quot;恐龍米&amp;quot;，正確&amp;quot;窟窿&amp;quot;連念到近乎一個音&lt;/p&gt;
&lt;p&gt;record，做名詞紀錄時，正確&amp;quot;ㄌㄩㄝ-渴d&amp;quot;，d幾乎不發音&lt;/p&gt;
&lt;p&gt;record，做動詞紀錄時，正確&amp;quot;re-扣d&amp;quot;，規律幾乎都是名詞重音在前，動詞重音在後&lt;/p&gt;
&lt;p&gt;resume，做名詞履歷時，正確&amp;quot;ㄌㄩㄝ-su-美&amp;quot;，重音在前&lt;/p&gt;
&lt;p&gt;resume，做動詞恢復時，正確&amp;quot;re-zoom&amp;quot;，重音在後&lt;/p&gt;
&lt;p&gt;archive，錯誤&amp;quot;阿起府&amp;quot;，正確&amp;quot;阿-凱f&amp;quot;，f幾乎不發音&lt;/p&gt;
&lt;p&gt;confirm，錯誤&amp;quot;康鳳&amp;quot;，正確&amp;quot;ken-firm&amp;quot;，firm=&amp;ldquo;份兒&amp;quot;連念。這是認證、確認的意思&lt;/p&gt;
&lt;p&gt;conform，錯誤&amp;quot;康鳳&amp;rdquo;，正確&amp;quot;ken-form&amp;quot;。這是符合的意思，兩字常常誤用誤念&lt;/p&gt;
&lt;p&gt;cancel，正確&amp;quot;ken-叟&amp;quot;，取消&lt;/p&gt;
&lt;p&gt;cancer，正確&amp;quot;ken-ser&amp;quot;，癌症，兩字常常誤用誤念&lt;/p&gt;
&lt;p&gt;query，錯誤&amp;quot;誇-李&amp;quot;，正確&amp;quot;ㄎㄨ一-ㄜˇ-ry&amp;quot;3音連速念&lt;/p&gt;
&lt;p&gt;guarantee，正確&amp;quot;ㄍㄟ-掄-替&amp;quot;&lt;/p&gt;
&lt;p&gt;standard，錯誤&amp;quot;stan-打&amp;quot;，正確&amp;quot;stan-得兒&amp;quot;&lt;/p&gt;
&lt;p&gt;execute，正確&amp;quot;ㄟ-ser-cute&amp;quot;&lt;/p&gt;
&lt;p&gt;cache，它和 cash (現金)同音&lt;/p&gt;
&lt;p&gt;compile，正確&amp;quot;康-派-偶&amp;quot;，動詞編譯&lt;/p&gt;
&lt;p&gt;compiler，正確&amp;quot;康-派l-惹&amp;quot;，l幾乎不發音，名詞編譯器&lt;/p&gt;
&lt;p&gt;exit，正確&amp;quot;ㄟㄎ-sit&amp;quot;，常誤念成exist&amp;quot;以-xit&amp;quot;&lt;/p&gt;
&lt;p&gt;image，錯誤&amp;quot;一美舉&amp;quot;，正確&amp;quot;一米舉&amp;quot;&lt;/p&gt;
&lt;p&gt;Algorithm，正確&amp;quot;凹狗-rithm&amp;quot;&lt;/p&gt;
&lt;p&gt;SQL，錯誤&amp;quot;circle&amp;quot;，正確&amp;quot;see-qual&amp;quot;&lt;/p&gt;
- https://yoziming.github.io/post/211120-%E5%8F%B0%E7%81%A3it%E4%BA%BA%E5%B8%B8%E5%94%B8%E9%8C%AF%E7%9A%84%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>尚硅谷JAVA基礎課-DAY05筆記</title>
        <link>https://yoziming.github.io/post/211120-%E5%B0%9A%E8%AA%B2java-day05/</link>
        <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211120-%E5%B0%9A%E8%AA%B2java-day05/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211120-%E5%B0%9A%E8%AA%B2java-day05/ -&lt;h1 id=&#34;day05-流程控制練習&#34;&gt;DAY05-流程控制練習&lt;/h1&gt;
&lt;h2 id=&#34;嵌套循環&#34;&gt;嵌套循環&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;就是for中有for，有時候需要多花點時間理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;內層循環整個遍歷完，外層循環才執行一次&lt;/li&gt;
&lt;li&gt;假設外層循環要執行m次，內層循環要執行n次。整個跑完內層循環一共執行了m*n次&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;練習題-印菱形&#34;&gt;練習題-印菱形&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Scanner scan = new Scanner(System.in);
System.out.println(&amp;quot;輸入想印的菱形邊長n=...&amp;quot;);
int n = scan.nextInt();
// 上半部分(含中間最長邊)
for (int i = 1; i &amp;lt;= n; i++) {
    for (int j = 0; j &amp;lt; n - i; j++) {
        System.out.print(&amp;quot; &amp;quot;);
    }
    for (int k = 0; k &amp;lt; i; k++) {
        System.out.print(&amp;quot;* &amp;quot;);
    }
    System.out.println();
}
// 下半部分(從最長-1開始)
for (int i = 1; i &amp;lt;= n; i++) {
    for (int j = 0; j &amp;lt; i; j++) {
        System.out.print(&amp;quot; &amp;quot;);
    }
    for (int k = 0; k &amp;lt; n - i; k++) {
        System.out.print(&amp;quot;* &amp;quot;);
    }
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;練習題-乘法表&#34;&gt;練習題-乘法表&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (int i = 1; i &amp;lt;= 9; i++) {
    for (int j = 1; j &amp;lt;= 9; j++) {
        System.out.print(i + &amp;quot;*&amp;quot; + j + &amp;quot;=&amp;quot; + i * j + &amp;quot;\t&amp;quot;);
    }
    System.out.println();
}
// 只想要半邊則第二行j&amp;lt;=9改成j
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;練習題-找完全數&#34;&gt;練習題-找完全數&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;完全數（Perfect number），又稱完美數或完備數，是一些特殊的自然數：它所有的真因子（即除了自身以外的因數）的和，恰好等於它本身。例如6，它有因數1、2、3、6，除去它本身6外，其餘3個數相加，{1}+{2}+{3}=6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (int i = 1; i &amp;lt;= 1000; i++) {
    int sum = 0;
    for (int j = 1; j &amp;lt; i; j++) {
        if (i % j == 0) {
            sum += j;
        }
    }
    if (sum == i) {
        System.out.println(i + &amp;quot;為完全數&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;練習題-找質數&#34;&gt;練習題-找質數&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;直觀版&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;boolean flag = true; // 若把這行放在第一個循環中，則會聲明99次，占資源
for (int i = 2; i &amp;lt;= 10000; i++) {
    for (int j = 2; j &amp;lt; i; j++) {
        if (i % j == 0) { // i被某數(2~自己-1)除盡
            flag = false; // 不是質數
        }
    }
    if (flag) {
        System.out.println(i + &amp;quot;是質數&amp;quot;);
    }
    flag = true; // 重置flag
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小優化版&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;boolean flag = true; // 若把這行放在第一個循環中，則會聲明99次，占資源
for (int i = 2; i &amp;lt;= 10000; i ++) {
    for (int j = 2; j &amp;lt; Math.sqrt(i); j++) { // 優化1.開平方
        if (i % j == 0) { // i被某數(2~自己-1)除盡
            flag = false; // 不是質數
            break; // 優化2.找到一個因數就停
        }
    }
    if (flag) {
        System.out.println(i + &amp;quot;是質數&amp;quot;);
    }
    flag = true; // 重置flag
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;label簡潔版&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;label:
for (int i = 2; i &amp;lt;= 10000; i++) {
    for (int j = 2; j &amp;lt; Math.sqrt(i); j++) { // 優化1.開平方
        if (i % j == 0) { // i被某數(2~自己-1)除盡
            continue label; // 找到任何因數就跳出(這裡要連跳出兩層，所以用label)
        }
    }
    System.out.println(i + &amp;quot;是質數&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;補充-計算運行耗時&#34;&gt;補充-計算運行耗時&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;學到單元測試之前先用耗時當作運行效率的參考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;long start = System.currentTimeMillis();
// ...待測程式碼
long end = System.currentTimeMillis();
System.out.println(&amp;quot;耗時為&amp;quot; + (end - start) + &amp;quot;毫秒&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;break與continue&#34;&gt;break與continue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;break會&lt;strong&gt;跳出循環體&lt;/strong&gt;，舉例:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (int i = 1; i &amp;lt;= 10; i++) {
    if (i % 5 == 0) {
        break;
    }
    System.out.print(i);
}
// 結果為1234
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;continue是&lt;strong&gt;跳過該次&lt;/strong&gt;循環體語句，舉例:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (int i = 1; i &amp;lt;= 10; i++) {
    if (i % 5 == 0) {
        continue;
    }
    System.out.print(i);
}
// 結果為12346789
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共通點:break跟continue之下都不能再聲明執行語句，否則報錯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;break跟continue都只會跳過&lt;strong&gt;一層&lt;/strong&gt;(就近原則)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在break跟continue後面接label使用達成跳轉，強烈不推薦&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;實作練習-家庭收支系統&#34;&gt;實作練習-家庭收支系統&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.Objects;
import java.util.Scanner;

public class FamilyAccount {
    public static void main(String[] args) {
        int money = 10000;
        String detail = &amp;quot;收支\t變動\t餘額\t說明\n初始\t金額\t&amp;quot; + money + &amp;quot;\t系統給你的&amp;quot;;
        Scanner scan = new Scanner(System.in);
        boolean flag = true;
        while (flag) {
            System.out.println(&amp;quot;===家庭收支系統===&amp;quot;);
            System.out.println(&amp;quot;===1.查看明細===&amp;quot;);
            System.out.println(&amp;quot;===2.登記收入===&amp;quot;);
            System.out.println(&amp;quot;===3.登記支出===&amp;quot;);
            System.out.println(&amp;quot;===4.退    出===&amp;quot;);
            System.out.println(&amp;quot;請輸入&amp;lt;1-4&amp;gt;...&amp;quot;);
            String input = scan.next(); // 獲取使用者輸入
            switch (input) {
                case &amp;quot;1&amp;quot;:
                    System.out.println(&amp;quot;===1.查看明細===&amp;quot;);
                    System.out.println(detail);
                    System.out.println(&amp;quot;明細結束!&amp;quot;);
                    break;
                case &amp;quot;2&amp;quot;:
                    System.out.println(&amp;quot;===2.登記收入===&amp;quot;);
                    System.out.println(&amp;quot;輸入金額...&amp;quot;);
                    String moneyInStr = scan.next();
                    int moneyIn = Integer.parseInt(moneyInStr);
                    money += moneyIn;
                    System.out.println(&amp;quot;輸入說明...&amp;quot;);
                    String infoIn = scan.next();
                    detail += &amp;quot;\n收入\t&amp;quot; + moneyInStr + &amp;quot;\t\t&amp;quot; + money + &amp;quot;\t&amp;quot; + infoIn;
                    System.out.println(&amp;quot;登記成功!&amp;quot;);
                    break;
                case &amp;quot;3&amp;quot;:
                    System.out.println(&amp;quot;===3.登記支出===&amp;quot;);
                    System.out.println(&amp;quot;輸入金額...&amp;quot;);
                    String moneyOutStr = scan.next();
                    int moneyOut = Integer.parseInt(moneyOutStr);
                    money -= moneyOut;
                    System.out.println(&amp;quot;輸入說明...&amp;quot;);
                    String infoOut = scan.next();
                    detail += &amp;quot;\n支出\t&amp;quot; + moneyOutStr + &amp;quot;\t\t&amp;quot; + money + &amp;quot;\t&amp;quot; + infoOut;
                    System.out.println(&amp;quot;登記成功!&amp;quot;);
                    break;
                case &amp;quot;4&amp;quot;:
                    System.out.println(&amp;quot;確認退出?&amp;lt;Y/N&amp;gt;不分大小寫...&amp;quot;);
                    String confirmExit = scan.next(); // 獲取使用者輸入
                    if (Objects.equals(confirmExit, &amp;quot;y&amp;quot;) || Objects.equals(confirmExit, &amp;quot;Y&amp;quot;)) {
                        flag = false;
                        System.out.println(&amp;quot;歡迎下次使用!&amp;quot;);
                        break;
                    } else if (Objects.equals(confirmExit, &amp;quot;n&amp;quot;) || Objects.equals(confirmExit, &amp;quot;N&amp;quot;)) {
                        System.out.println(&amp;quot;繼續使用&amp;quot;);
                        break;
                    }
                default:
                    System.out.println(&amp;quot;輸入有誤，請重新輸入&amp;quot;);
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;知識點&#34;&gt;知識點&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;scan.next()收到空白內容(\t、\n、&amp;quot; &amp;ldquo;)它當作啥事都沒發生，比如我想接收&amp;quot;Y&amp;rdquo;，輸入&amp;quot;   Y&amp;quot;竟然也符合&lt;/li&gt;
&lt;li&gt;比對string使用Objects.equals(目標string物件, &amp;ldquo;內容&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;string轉int使用int int_val = Integer.parseInt(str);&lt;/li&gt;
&lt;li&gt;一串含換行的string中若有中文跟數字組合想用\t實現上下行對齊時，數字後面要\t\t&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211120-%E5%B0%9A%E8%AA%B2java-day05/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>尚硅谷JAVA基礎課-DAY04筆記</title>
        <link>https://yoziming.github.io/post/211119-%E5%B0%9A%E8%AA%B2java-day04/</link>
        <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211119-%E5%B0%9A%E8%AA%B2java-day04/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211119-%E5%B0%9A%E8%AA%B2java-day04/ -&lt;h1 id=&#34;day04-流程控制&#34;&gt;DAY04-流程控制&lt;/h1&gt;
&lt;h2 id=&#34;分支控制&#34;&gt;分支控制&lt;/h2&gt;
&lt;h3 id=&#34;if-else&#34;&gt;if-else&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;基礎都一樣不多贅述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特殊情況有人不加{}，這種情境下就近原則且只控制一行(到第一個;為止)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if (1 == 2)
System.out.println(&amp;quot;a&amp;quot;);
System.out.println(&amp;quot;b&amp;quot;);
System.out.println(&amp;quot;c&amp;quot;);
結果為
b
c
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有單行時可以接else且也會就近選擇&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if (1 == 2)
System.out.println(&amp;quot;a&amp;quot;);
else
System.out.println(&amp;quot;d&amp;quot;);
結果為d
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多行時直接報錯&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if (1 == 2)
System.out.println(&amp;quot;a&amp;quot;);
System.out.println(&amp;quot;b&amp;quot;);
System.out.println(&amp;quot;c&amp;quot;);
else
報錯
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小結:不加{}的全部拖出去打&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;switch-case&#34;&gt;switch-case&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;結構:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;switch&lt;/span&gt; (表達式) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; 常量1:
        &lt;span style=&#34;color:#228b22&#34;&gt;// 執行語句
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; 常量2...
        ...
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt;:
        &lt;span style=&#34;color:#228b22&#34;&gt;// 預設執行語句
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如果不加break;就不會跳出，而是會穿透且之下的語句全都執行一遍&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基於上述特性，可以合併使用，舉例:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case 1:
case 2:
case 3:
     // 執行語句123的情況
     break;
case 4:
...
也可以用在需要壘加的情況，舉例
case 9:
a += 10
case 8:
a += 5
case 7:
a += 100
...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表達式只能為6種類型: byte、short、char、int、枚舉、string，&lt;strong&gt;不能是bool&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;case後只能放常量，不能是範圍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;default不一定要有且位置是靈活可變的，但注意若不擺在最尾需要加入break;，否則會多執行下一行，很蠢，不建議這樣用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分支控制小結&#34;&gt;分支控制小結&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;凡是可以用switch-case結構的都能轉成if-else，反之不成立&lt;/li&gt;
&lt;li&gt;兩種都可用的情況(條件不要太多)優先考慮switch-case，執行效率較高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循環控制&#34;&gt;循環控制&lt;/h2&gt;
&lt;h3 id=&#34;for&#34;&gt;for&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;for的結構&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for(初始條件;循環條件;疊代){
    循環體;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;題外話：「疊代」與「迭代」&lt;/p&gt;
&lt;p&gt;「疊代」：累進取代，不斷重複進行後者加上前者、替換掉前者的動作；
「迭代」：替換取代，表示幾個固定的物件彼此輪替取代的動作；&lt;/p&gt;
&lt;p&gt;繁體中文兩種用法都存在，迭代用於只有幾個條件在那邊不停輪換的情況，比如四季迭代。一般軟體上用的應為疊代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;獲取使用者輸入&#34;&gt;獲取使用者輸入&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Scanner scanner = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Scanner(System.&lt;span style=&#34;color:#658b00&#34;&gt;in&lt;/span&gt;)
&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;System.in開啟了一個InputStream來獲取使用者的輸入
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;把使用者的輸入傳給剛剛new建立的scanner物件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;這個scanner物件是來自java.util.Scanner包中定義的Scanner類
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;接著用scanner.next類型()來決定要接收的數據類型，舉例接收i
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; number = scanner.&lt;span style=&#34;color:#658b00&#34;&gt;nextInt&lt;/span&gt;();    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;for練習題-最大公因數與最小公倍數&#34;&gt;for練習題-最大公因數與最小公倍數&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;輸入m、n，求最大公因數與最小公倍數&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        Scanner scanner = new Scanner(System.in);
        System.out.println(&amp;quot;輸入數字m...&amp;quot;);
        int m = scanner.nextInt();
        System.out.println(&amp;quot;輸入數字n...&amp;quot;);
        int n = scanner.nextInt();
        int min = 0, max = 0;
        for (int i = 1; i &amp;gt; 0; i++) {
            if (m % i == 0 &amp;amp;&amp;amp; n % i == 0) {
                min = i;
            }
            if (i % m == 0 &amp;amp;&amp;amp; i % n == 0) {
                max = i;
                break;
            }
        }
        System.out.println(&amp;quot;數字&amp;quot; + m + &amp;quot;與數字&amp;quot; + n + &amp;quot;之最大公因數為&amp;quot; + min + &amp;quot;最小公倍數為&amp;quot; + max);
// 這個效率不夠高，改進: 先找出輸入的2數誰大
// 最大公因數=for循環從大往小減，遇到第一個就break
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;for練習題-水仙花數&#34;&gt;for練習題-水仙花數&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;水仙花數：是指一個n位的正整數(n&amp;gt;=3),它的每個數字的n次冪之和等於它本身。例如：1^3 + 5^3+ 3^3 = 153&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        for (int i = 100; i &amp;lt; 1000; i++) {
            int a = i / 100; // 百位
            int b = i % 100 / 10; // 十位
            int c = i % 10; // 個位
            if (i == (a * a * a + b * b * b + c * c * c)) {
                System.out.println(i);
            }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;循環控制while&#34;&gt;循環控制while&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;其實教學影片中這是第5天的內容，不過while跟for類似所以我筆記寫一起了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;while的結構&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;初始條件;
while(循環條件){
    循環體;
    疊代;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for跟while可以互相轉換，他們實際的差別在變量的作用域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因為while的初始條件寫在外面，循環結束也能使用(全局變量與局部變量的區別)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;do-while&#34;&gt;do-while&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;do-while的結構&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;初始條件;
do{
    循環體;
    疊代;
}while(循環條件);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上來就至少執行一次循環跟疊代，然後才進入判斷&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;少用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;練習題-無限循環&#34;&gt;練習題-無限循環&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;輸入不限制數量的正負整數，直到輸入0為中止，顯示正負整數的數量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        Scanner scan = new Scanner(System.in);
        int pos = 0;
        int neg = 0;
        	for (; ; ) {
            System.out.println(&amp;quot;輸入任意正負整數，0為中止...&amp;quot;);
            int input = scan.nextInt();
            if (input == 0) {
                System.out.println(&amp;quot;中止，正數個數為&amp;quot; + pos + &amp;quot;，負數個數為&amp;quot; + neg);
                break;
            } else if (input &amp;gt; 0) {
                pos++;
            } else {
                neg++;
            }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;for (; ; )跟while(true)相等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JAVA的if與for用起來跟go的差不多，就switch會穿透要記得break&lt;/li&gt;
&lt;li&gt;JAVA中聲明變量必須要賦值否則編譯報錯&lt;/li&gt;
&lt;li&gt;用if多個條件嵌套時正常從涵蓋範圍小往大寫，不要不加{}&lt;/li&gt;
&lt;li&gt;從go的角度看while沒啥必要性，do-while簡直邪道，盡量少用&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211119-%E5%B0%9A%E8%AA%B2java-day04/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>IntelliJ IDEA 常用快捷鍵</title>
        <link>https://yoziming.github.io/post/211117-intellij-idea-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%8D%B5/</link>
        <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211117-intellij-idea-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%8D%B5/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211117-intellij-idea-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%8D%B5/ -&lt;h1 id=&#34;intellij-idea-設定與實用快捷鍵&#34;&gt;IntelliJ IDEA 設定與實用快捷鍵&lt;/h1&gt;
&lt;h3 id=&#34;基礎設定&#34;&gt;基礎設定&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安裝的根目錄，舉例&amp;hellip;\IntelliJ IDEA 2021.2.3\bin\idea64.exe.vmoptions&lt;/p&gt;
&lt;p&gt;編輯這個idea64.exe.vmoptions，改成-Xmx1024m -Xms2048m&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ctrl+alt+s開啟設定 -&amp;gt; plugins插件 -&amp;gt; 搜尋chinese -&amp;gt; 安裝重啟 -&amp;gt; 中文化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;plugins插件 -&amp;gt; 搜尋save actions-&amp;gt; 安裝重啟 -&amp;gt; 存檔時自動格式化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外觀-使用自定義字體打勾-Sarasa mono&amp;hellip;，大小改14&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;強烈建議使用更紗黑體Sarasa-Gothic
&lt;a href=&#34;https://github.com/be5invis/Sarasa-Gothic&#34;&gt;https://github.com/be5invis/Sarasa-Gothic&lt;/a&gt;
特性:融合Iosevka(程式碼常用的等寬字型)跟Source Han Sans(思源黑)，有等距、繁簡中日韓不缺字，簡直完美&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編譯器-字體-一樣改，大小我是設18、行高1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編譯器-代碼樣式-Java-空行-保持最大空白行，前三項我都設1，太多空白可自動刪除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;佈景主題推薦one dark，這也是最多人用的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rainbow Brackets 括弧變色&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;視窗&#34;&gt;視窗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Close All Tabs : alt + w&lt;/li&gt;
&lt;li&gt;Terminal : ctrl + alt + 0&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;live-templates-&#34;&gt;Live Templates :&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;縮寫 + Tab&lt;/li&gt;
&lt;li&gt;psvm /main ➞ main 方法&lt;/li&gt;
&lt;li&gt;sout ➞ print 打印&lt;/li&gt;
&lt;li&gt;iter ➞ for 迴圈格式 1&lt;/li&gt;
&lt;li&gt;itar ➞ for 迴圈格式 2&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;選取&#34;&gt;選取&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;选中下一个相同内容的快捷键(vs code中的Ctrl+D)：&lt;strong&gt;Alt + J&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;依照個人習慣我還是把它改成ctrl + D了，原本ctrl + D(複製當前行)改成alt+ shift + ↓&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;以行為單位&#34;&gt;以「行」為單位&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;複製 : ctrl + D&lt;/li&gt;
&lt;li&gt;移動 : ctrl + shift + ↑/↓&lt;/li&gt;
&lt;li&gt;註解 : ctrl + /&lt;/li&gt;
&lt;li&gt;刪除 : ctrl+x(其實是剪下)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;以區塊為單位&#34;&gt;以「區塊」為單位&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;擴增選取 : ctrl + W&lt;/li&gt;
&lt;li&gt;遞減選取 : ctrl + shift + W&lt;/li&gt;
&lt;li&gt;更改大小寫 : ctrl + shift + U&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;自動功能-&#34;&gt;自動功能 :&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;自動補全 : alt + enter&lt;/li&gt;
&lt;li&gt;自動產生 : alt + Ins&lt;/li&gt;
&lt;li&gt;自動排版 : ctrl + alt + L&lt;/li&gt;
&lt;li&gt;自動移出未使用 import : ctrl + alt + O&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211117-intellij-idea-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%8D%B5/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>尚硅谷JAVA基礎課-DAY03筆記</title>
        <link>https://yoziming.github.io/post/211118-%E5%B0%9A%E8%AA%B2java-day03/</link>
        <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211118-%E5%B0%9A%E8%AA%B2java-day03/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211118-%E5%B0%9A%E8%AA%B2java-day03/ -&lt;h1 id=&#34;day03-運算符&#34;&gt;DAY03-運算符&lt;/h1&gt;
&lt;h3 id=&#34;加減乘除&#34;&gt;加減乘除&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;基本都一樣不再贅述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;-取餘的規則&#34;&gt;% 取餘的規則&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;結果的符號與被取餘的數符號相同，舉例-12%5=-2、12%-5=2、-12%-5=-2&lt;/li&gt;
&lt;li&gt;實際開發中取餘常用來判斷是否能除盡&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自增自減的規則&#34;&gt;自增自減的規則&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;++a，(前++)先運算後取值，舉例a=2;b=++a;結果a=3;b=3&lt;/li&gt;
&lt;li&gt;a++，先取值後運算，舉例a=2;b=a++;結果a=3;b=2&lt;/li&gt;
&lt;li&gt;&amp;ndash;a，先運算後取值，舉例a=2;b=&amp;ndash;a;結果a=1;b=1&lt;/li&gt;
&lt;li&gt;a&amp;ndash;，先取值後運算，舉例a=2;b=a&amp;ndash;;結果a=1;b=2&lt;/li&gt;
&lt;li&gt;自增減不會改變數據類型(但可能會溢位)&lt;/li&gt;
&lt;li&gt;不可連用，舉例a++++會報錯&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外+也能用在字符串聯接，舉例&amp;quot;he&amp;quot;+&amp;ldquo;llo&amp;rdquo;=&amp;ldquo;hello&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;-賦值的規則&#34;&gt;= 賦值的規則&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可以連續賦值，舉例int i1,i2; i1=i2=10; int i3=10,j3=20;&lt;/li&gt;
&lt;li&gt;+=、-=、*=、/=、%= 不會改變數據類型&lt;/li&gt;
&lt;li&gt;面試題n=10; n+=(n++)+(++n); n=?&lt;/li&gt;
&lt;li&gt;解: 拆成 n = n + 10 + 12 =32&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;邏輯運算符&#34;&gt;邏輯運算符&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;image-20211118124823879.png&#34; alt=&#34;image-20211118124823879&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乍看邏輯跟短路結果是一樣，實際使用上差異為&lt;strong&gt;短路後的東西就不執行了&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;舉例: b=false; n=10; b &amp;amp;&amp;amp; (n++&amp;gt;0)=false，但n=10&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;位運算符&#34;&gt;位運算符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;image-20211118131637668.png&#34; alt=&#34;image-20211118131637668&#34;&gt;&lt;/li&gt;
&lt;li&gt;操作的都是整數&lt;/li&gt;
&lt;li&gt;&amp;laquo; 向左移一位相當於*2，&amp;raquo;向右移一位相當於/2，有可能溢位&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;image-20211118131712687.png&#34; alt=&#34;image-20211118131712687&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三元運算符&#34;&gt;三元運算符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;結構: (條件表達式) ? 表達式1 : 表達式2&lt;/li&gt;
&lt;li&gt;說明: 條件表達式=boolean，如果是true則執行表達式1，反之執行2&lt;/li&gt;
&lt;li&gt;表達式1 與 表達式2 要求一致(至少能裝進同一個類型)&lt;/li&gt;
&lt;li&gt;其實就是簡易版的if，可以嵌套使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;優先級&#34;&gt;優先級&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;image-20211118133948019.png&#34; alt=&#34;image-20211118133948019&#34;&gt;&lt;/li&gt;
&lt;li&gt;基本原則是從上到下，從左到右，括號優先&lt;/li&gt;
&lt;li&gt;自增減、賦值運算、三元運算才從右往左看&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211118-%E5%B0%9A%E8%AA%B2java-day03/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>尚硅谷JAVA基礎課-DAY02筆記</title>
        <link>https://yoziming.github.io/post/211117-%E5%B0%9A%E8%AA%B2java-day02/</link>
        <pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211117-%E5%B0%9A%E8%AA%B2java-day02/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211117-%E5%B0%9A%E8%AA%B2java-day02/ -&lt;h1 id=&#34;day02-關鍵字與數據類型&#34;&gt;DAY02-關鍵字與數據類型&lt;/h1&gt;
&lt;h2 id=&#34;關鍵字&#34;&gt;關鍵字&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有特殊含意與用途，所有關鍵字都是小寫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如:if、new&amp;hellip;等等，後面都會一一接觸到&lt;/p&gt;
&lt;h3 id=&#34;保留字&#34;&gt;保留字&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;未來版本可能會用到而保留&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如:goto、const&lt;/p&gt;
&lt;h3 id=&#34;標識符identifier&#34;&gt;標識符(identifier)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可以自己命名的(類、變量、函數&amp;hellip;等)就叫標識符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由字母、數字、_、$組成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;數字不可為開頭&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能包含關鍵字但不能純用關鍵字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;嚴格區分大小寫&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能包含空格&lt;/p&gt;
&lt;h4 id=&#34;命名規範&#34;&gt;命名規範&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;不強制但最好遵守&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包名:多單詞所有字母小寫aaabbbccc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;類名、接口名:大駝峰(首字母大寫)AaaBbbCcc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;變量名、方法名:開頭小寫後面首字母大寫(小駝峰)aaaBbbCcc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常量名:全大寫，用下畫線相連AAA_BBB_CCC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命名要有意義，見名知意&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;變量variable&#34;&gt;變量(variable)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;記憶體中的一個儲存區域，使用的基本單位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;必須先聲明，後使用&lt;/li&gt;
&lt;li&gt;作用域在其定義所在的一對{}內，只在其作用域中有效&lt;/li&gt;
&lt;li&gt;同一作用域中不可重複&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;數據類型&#34;&gt;數據類型&lt;/h2&gt;
&lt;h3 id=&#34;基礎數據類型&#34;&gt;基礎數據類型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;六種數字類型（四個整數型，兩個浮點型），一種字符類型，還有一種布爾型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;byte：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;byte數據類型是8位、有符號的，以二進制補碼表示的整數&lt;/li&gt;
&lt;li&gt;最小值是-128（-2^7）最大值是127（2^7-1）默認值是0&lt;/li&gt;
&lt;li&gt;byte類型用在大型數組中節約空間，主要代替整數，因為byte變量佔用的空間只有int類型的四分之一&lt;/li&gt;
&lt;li&gt;例子：byte a = 100，byte b = -50。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;short：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;short數據類型是16位、有符號的以二進制補碼表示的整數&lt;/li&gt;
&lt;li&gt;最小值是-32768（-2^15）最大值是32767（2^15 - 1）默認值是0&lt;/li&gt;
&lt;li&gt;Short數據類型也可以像byte那樣節省空間。 一個short變量是int型變量所佔空間的二分之一&lt;/li&gt;
&lt;li&gt;例子：short s = 1000，short r = -20000。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;int：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int數據類型是32位、有符號的以二進制補碼表示的整數&lt;/li&gt;
&lt;li&gt;最小值是-2,147,483,648（-2^31）最大值是2,147,483,647（2^31 - 1）默認值是0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般整型變量默認為int類型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;例子：int a = 100000, int b = -200000。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;long：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;long數據類型是64位、有符號的以二進制補碼表示的整數&lt;/li&gt;
&lt;li&gt;最小值是-9,223,372,036,854,775,808（-2^63）&lt;/li&gt;
&lt;li&gt;最大值是9,223,372,036,854,775,807（2^63 -1）&lt;/li&gt;
&lt;li&gt;這種類型主要使用在需要比較大整數的系統上&lt;/li&gt;
&lt;li&gt;必須以L(大小都可)結尾，不加自動被當成int&lt;/li&gt;
&lt;li&gt;默認值是0L&lt;/li&gt;
&lt;li&gt;例子： long a = 100000L，Long b = -200000L。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;float：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;float的儲存結構是1個符號位，8個指數位，23個尾數，符合IEEE 754標準的浮點數&lt;/li&gt;
&lt;li&gt;可以看做float只有24位來表示精度，所以int或long轉float可能會有精度損失。&lt;/li&gt;
&lt;li&gt;必須以F(大小都可)結尾，不加報錯&lt;/li&gt;
&lt;li&gt;默認值是0.0f&lt;/li&gt;
&lt;li&gt;浮點數不能用來表示精確的值，如貨幣&lt;/li&gt;
&lt;li&gt;例子：float f1 = 234.5f。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;double：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;double數據類型是雙精度、64位、符合IEEE 754標準的浮點數&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浮點數的默認類型為double類型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;double類型同樣不能表示精確的值，如貨幣&lt;/li&gt;
&lt;li&gt;默認值是0.0d&lt;/li&gt;
&lt;li&gt;例子：double d1 = 123.4。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;char：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char類型是一個單一的16位Unicode字符(兩個字節)&lt;/li&gt;
&lt;li&gt;最小值是&#39;\u0000&#39;（即為0）最大值是&#39;\uffff&#39;（即為65,535）&lt;/li&gt;
&lt;li&gt;char數據類型可以儲存任何字符，包含轉義字符(如\n、\t等等)&lt;/li&gt;
&lt;li&gt;例子：char letter = &amp;lsquo;A&amp;rsquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;boolean：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;boolean數據類型表示一位的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有兩個取值：true和false默認值是false&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;這種類型只作為一種標誌來記錄true/false情況&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;實際大小不定，取決於虛擬機&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例子：boolean one = true。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;自動類型提升隱式類型轉換&#34;&gt;自動類型提升(隱式類型轉換)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;針對上面7種基礎數據類型混合運算時(不含boolean)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不同類型運算時容量小的提升為大的，注意&lt;strong&gt;容量&lt;/strong&gt;指的是數的&lt;strong&gt;范蓋範圍&lt;/strong&gt;，例如佔64位的long可以提升成32位的float(代價是丟失精度)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;byte、char、short -&amp;gt; int -&amp;gt; long -&amp;gt; float -&amp;gt; double&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;char因為在0~65535有可能在byte與short之間變動，但總之byte、short、char三者做運算時結果必須為int型(例如byte+byte=int)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;強制類型轉換顯式類型轉換&#34;&gt;強制類型轉換(顯式類型轉換)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;容量高轉低，自動類型提升的逆運算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;double d1 = 12.3;
int i1 = (int)d1; // 截斷操作
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用強轉符()&lt;/li&gt;
&lt;li&gt;可能導致精度損失或溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;引用類型&#34;&gt;引用類型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;包含:字符串(string)、類(class)、接口(interface)、數組(array)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在Java中，引用類型的變量非常類似於C/C++的指針。 引用類型指向一個對象，指向對象的變量是引用變量。 這些變量在聲明時被指定為一個特定的類型，比如Employee、Pubby等。 變量一旦聲明後，類型就不能被改變了。&lt;/li&gt;
&lt;li&gt;所有引用類型的默認值都是null。&lt;/li&gt;
&lt;li&gt;一個引用變量可以用來引用與任何與之兼容的類型。&lt;/li&gt;
&lt;li&gt;例子：Site site = new Site(&amp;ldquo;w3big&amp;rdquo;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;字符串string&#34;&gt;字符串(string)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;聲明: String s1 = &amp;ldquo;xxx&amp;rdquo;&lt;/li&gt;
&lt;li&gt;String可以跟8種基礎數據類型做運算，且只能是連接運算(+)，結果仍是String類型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;n進制&#34;&gt;N進制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;N進制轉十進制: 指數加權法&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;image-20211117191625174.png&#34; alt=&#34;image-20211117191625174&#34;&gt;&lt;/li&gt;
&lt;li&gt;十進制轉N進制:除N取餘的逆&lt;/li&gt;
&lt;li&gt;最高位(符號位): 0正1負&lt;/li&gt;
&lt;li&gt;正數: 原碼=反碼=補碼&lt;/li&gt;
&lt;li&gt;負數: 除符號位以外其餘取反&lt;/li&gt;
&lt;li&gt;補碼: 反碼 + 1(可能會進位)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;電子數據底層儲存的是補碼!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211117-%E5%B0%9A%E8%AA%B2java-day02/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>LeetCodeEasy1-3</title>
        <link>https://yoziming.github.io/post/211116-leetcodeeasy1-3/</link>
        <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211116-leetcodeeasy1-3/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/211116-leetcodeeasy1-3/ -&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/two-sum&#34;&gt;1. Two Sum&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;求某數組中哪兩位數的和等於X&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;// nums []int=傳入的數組；target=X
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;twoSum&lt;/span&gt;(nums []&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;, target &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;) []&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; {

    
	m := &lt;span style=&#34;color:#658b00&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#658b00&#34;&gt;len&lt;/span&gt;(nums))

	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; i, num := &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;range&lt;/span&gt; nums {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; idx, ok := m[target-num]; ok {
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; []&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;{idx, i}
		}
		m[num] = i
	}
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; []&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/palindrome-number&#34;&gt;9. Palindrome Number&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;判斷是否為迴文數字，例如121&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/roman-to-integer&#34;&gt;13. Roman to Integer&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;羅馬字母轉成數字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;// s=傳入的羅馬字串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;romanToInt&lt;/span&gt;(s &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; {
    &lt;span style=&#34;color:#228b22&#34;&gt;// 創一個map將所有羅馬字對應數值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; romanMap = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;byte&lt;/span&gt;]&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;I&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;V&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;X&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;L&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;D&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;M&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;1000&lt;/span&gt;}
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; result = romanMap[s[&lt;span style=&#34;color:#658b00&#34;&gt;len&lt;/span&gt;(s)-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]] &lt;span style=&#34;color:#228b22&#34;&gt;// 先取最右邊的那1位羅馬字是多少
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; i := &lt;span style=&#34;color:#658b00&#34;&gt;len&lt;/span&gt;(s) - &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;; i &amp;gt;= &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i-- { &lt;span style=&#34;color:#228b22&#34;&gt;// 從右2羅馬字開始往左數
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; romanMap[s[i]] &amp;lt; romanMap[s[i+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]] { &lt;span style=&#34;color:#228b22&#34;&gt;// 如果羅馬字右邊&amp;gt;左邊，例如IV或IX這種情況，表示要減去左邊位
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			result -= romanMap[s[i]]
		} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
			result += romanMap[s[i]] &lt;span style=&#34;color:#228b22&#34;&gt;// 否則相加
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		}
		&lt;span style=&#34;color:#228b22&#34;&gt;// 循環至i=0，也就是最左邊的羅馬字位也算完即是最終答案
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; result
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://yoziming.github.io/post/211116-leetcodeeasy1-3/ - yoziming</description>
        </item>
    
    
  </channel>
</rss> 