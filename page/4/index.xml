<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>柚子茶室</title>
    <link>https://yoziming.github.io/</link>
    <description>Recent content on 柚子茶室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Yoziming</copyright>
    <lastBuildDate>Sat, 26 Feb 2022 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yoziming.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>修改css或js後瀏覽器快取不更新問題</title>
        <link>https://yoziming.github.io/post/211017-explorer-cache-problems/</link>
        <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211017-explorer-cache-problems/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/211017-explorer-cache-problems/ -&lt;h1 id=&#34;修改css或js後瀏覽器快取不更新問題&#34;&gt;修改css或js後瀏覽器快取不更新問題&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;當初我真的是被這個整到懷疑人生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解決方式一：&lt;/p&gt;
&lt;p&gt;​    使用者按Ctrl + F5強制重新整理頁面或者手動清空了瀏覽器的快取。此時瀏覽器會重新向伺服器獲取CSS和JS檔案,新的檔案便會生效。&lt;/p&gt;
&lt;p&gt;解決方式二：&lt;/p&gt;
&lt;p&gt;​    但是使用者量過大的時候總不能讓每個使用者一一清理快取吧，於是便從程式碼的角度著手解決這個問題。在js後面新增版本號，讓瀏覽器把這個JS檔案當做新的檔案重新向伺服器獲取資源。&lt;/p&gt;
&lt;p&gt;加版本號前：&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text/javascript&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;th:src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;@{/js/test/index.js}&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;加版本號後：&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text/javascript&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;th:src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;@{/js/test/index.js?v=1.0}&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;實際上這種方法在web也被很廣泛的應用，有時候開網頁看到網址後面一串?t=65412378946之類的，原來就是用時間產生的亂數，專門用來防快取&lt;/p&gt;
&lt;h2 id=&#34;參考&#34;&gt;參考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.itread01.com/content/1548610940.html&#34;&gt;https://www.itread01.com/content/1548610940.html&lt;/a&gt;&lt;/p&gt;
- https://yoziming.github.io/post/211017-explorer-cache-problems/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Docker &amp; Hyper-V占用port問題</title>
        <link>https://yoziming.github.io/post/211015-docker-hyper-v-port-problem/</link>
        <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211015-docker-hyper-v-port-problem/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/211015-docker-hyper-v-port-problem/ -&lt;h1 id=&#34;docker--hyper-v占用port問題&#34;&gt;Docker &amp;amp; Hyper-V占用port問題&lt;/h1&gt;
&lt;p&gt;在window下用docker desktop有時候遇上port被莫名佔用
用指令&lt;code&gt;netstat -ano | findstr xxx&lt;/code&gt;查詢xxx埠被誰佔用卻又顯示沒有&lt;/p&gt;
&lt;p&gt;原來是因為在window下用docker需要依賴hyper-v技術，
而這個hyper-v每次都會隨機搶走一部分tcp埠，使用命令可以得知應避開的範圍:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;# powershell / cmd&lt;/span&gt;
netsh interface ipv4 show excludedportrange protocol=tcp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如果避不開就手動叫hyper-v讓路&#34;&gt;如果避不開就手動叫Hyper-V讓路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;關閉hyper-v&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;# powershell / cmd&lt;/span&gt;
dism.exe /Online /&lt;span style=&#34;color:#658b00&#34;&gt;Disable-Feature&lt;/span&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#658b00&#34;&gt;Microsoft-Hyper&lt;/span&gt;-V
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置ipv4動態埠 / 或者配置需要的埠不被佔用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;# powershell / cmd 管理員許可權&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# start 起始埠  num 表示可用埠數     按自己的需求來&lt;/span&gt;
netsh int ipv4 &lt;span style=&#34;color:#658b00&#34;&gt;set &lt;/span&gt;dynamicport tcp start=30000 num=16383
// 叫他去用30000以後的阜

&lt;span style=&#34;color:#228b22&#34;&gt;# 排除ipv4動態埠佔用 startport 起始埠 numberofports 埠數&lt;/span&gt;
netsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1
// 或是指定端口50051為要讓路的
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新啟動hyper-v&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fdocker%2Ffor-win%2Fissues%2F3171%23issuecomment-459205576&#34;&gt;https://github.com/docker/for-win/issues/3171#issuecomment-459205576&lt;/a&gt;&lt;/p&gt;
- https://yoziming.github.io/post/211015-docker-hyper-v-port-problem/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Linux常用操作、wsl2相關</title>
        <link>https://yoziming.github.io/post/211010-linux-common-operations/</link>
        <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211010-linux-common-operations/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/211010-linux-common-operations/ -&lt;h1 id=&#34;linux常用操作&#34;&gt;Linux常用操作&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;ls：顯示檔或目錄資訊&lt;/li&gt;
&lt;li&gt;mkdir：目前的目錄下創建一個空目錄&lt;/li&gt;
&lt;li&gt;rmdir：要求目錄為空&lt;/li&gt;
&lt;li&gt;touch：生成一個空檔或更改檔的時間&lt;/li&gt;
&lt;li&gt;cp：複製檔或目錄&lt;/li&gt;
&lt;li&gt;mv：移動檔或目錄、檔或目錄改名&lt;/li&gt;
&lt;li&gt;rm：刪除檔或目錄&lt;/li&gt;
&lt;li&gt;ln：建立連結檔&lt;/li&gt;
&lt;li&gt;find：查找文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; 移動路徑&lt;/li&gt;
&lt;li&gt;“&lt;code&gt;.&lt;/code&gt;” 表示 目前的目錄&lt;/li&gt;
&lt;li&gt;“&lt;code&gt;..&lt;/code&gt;” 表示 上一級目錄&lt;/li&gt;
&lt;li&gt;“&lt;code&gt;-&lt;/code&gt;” 表示 上一次工作目錄&lt;/li&gt;
&lt;li&gt;“&lt;code&gt;~&lt;/code&gt;” 表示 用戶主目錄&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo su root&lt;/code&gt; 取得su權限&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 解壓縮XX檔案到/usr/local
sudo tar -C /usr/local -xzvf go1.17.1.linux-amd64.tar.gz

// 文字編輯器
sudo gedit /home/yoziming/.config/go/env

// 檔案總管
sudo nautilus 

// 啟用go mod
go env -w GO111MODULE=on
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;wsl2相關&#34;&gt;wsl2相關&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;優文參考: &lt;a href=&#34;https://blog.csdn.net/qq_38856939/article/details/116528514&#34;&gt;https://blog.csdn.net/qq_38856939/article/details/116528514&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用xfce4圖形介面&#34;&gt;使用xfce4圖形介面&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;windows端&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;下載 X Server 例如 https://sourceforge.net/projects/vcxsrv/

安裝後打開XLaunch
第一步 display number 預設可能是-1，改成0
下一步 setart no client 預設不用改
第三步 勾選 no access control
即完成監聽，等待linux來連線

查看IP，使用指令 ipconfig
注意看的是這個:
乙太網路卡 vEthernet (WSL):
 IPv4 位址 . . . . . . . . . . . . : 172.31.144.1
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;linux端&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 更新apt本身
sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade -y

// 安裝xfce4，約1G
sudo apt-get install xfce4

// 指定linux連到windows的端口，IP在windows看
export DISPLAY=172.31.144.1:0

// 啟動連線
startxfce4
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;注意IP可能會變動，並且可能要修改防火牆規則&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211010-linux-common-operations/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Kubernetes基礎認識</title>
        <link>https://yoziming.github.io/post/211006-k8s/</link>
        <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211006-k8s/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/211006-k8s/ -&lt;h1 id=&#34;kubernetes基礎認識&#34;&gt;Kubernetes基礎認識&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;自動化地以容器的形式管理你的應用程式
To host your application in the form of containers in a automated fashion&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;image-20211014130933320.png&#34; alt=&#34;image-20211014130933320&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;名詞解釋&#34;&gt;名詞解釋&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Cluster:集群，計算、儲存資源的集合。一個Cluster通常包含一個Controller Plane和數個Node，視需求而定(也可能有Multi-Controller Plane 的集群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Controller Plane:(以前叫Mater)控制主節點，調度指揮所
&lt;ul&gt;
&lt;li&gt;APIserver:管理整個 K8s 所需 API 的接口(Endpoint)，提供HTTP Rest介面的關鍵服務處理程序，是集群中各個節點的溝通橋樑&lt;/li&gt;
&lt;li&gt;etcd:存資料&lt;/li&gt;
&lt;li&gt;Scheduler:資源調配，例如調度Pod運行在哪個Node&lt;/li&gt;
&lt;li&gt;Controller-manager:總經理，負責管理並運行 &lt;code&gt;controller&lt;/code&gt; ，controller定義各種Pod的部屬特性(如最常用的Deployment)來滿足不同的業務場景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Node:節點，讓物件(resource-objects)運行的實體或虛擬機器
&lt;ul&gt;
&lt;li&gt;kubelet:對應api-server的接口，可以看成每個Node上的&amp;quot;實際執行者&amp;quot;或&amp;quot;操作者&amp;quot;，負責接收來自api-server的訊息，並做出相對應的動作，例如，負責Pod對應的容器的建立、啟動或停止等。&lt;/li&gt;
&lt;li&gt;kube-proxy:維護網路規則(iptables)，這些規則允許從群集內部或外部的與Pod進行通訊。&lt;/li&gt;
&lt;li&gt;Container Runtime:容器的運行引擎，預設是Docker，也支援其他滿足CRI標準的。
&lt;ul&gt;
&lt;li&gt;Pod:可被調度的最小單位，每個Pod包含一或多個容器，Pod內共享生命週期、資源、通信(使用同一個網路namespace，即相同的IP與port)、儲存空間。通常使用是一個Pod中放一個容器；當需要高度共享資源時才會用一個Pod內多個容器的形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;延伸觀念&#34;&gt;延伸觀念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Deployment:部屬，例如把Pod做橫向擴展，適用自動管理，或達成無停機系統升級&lt;/li&gt;
&lt;li&gt;Service:服務，Deployment可以部屬多個Pod，每個Pod都有自己的IP，隨時都在生滅浮動，外界如何訪問? 答案就是透過Service，可以說Controller負責運行Pod，而Service負責訪問Pod。&lt;/li&gt;
&lt;li&gt;Ingress:Service 中是將每個 Service 元件對外的 port number 跟 Node 上的 port number 做 mapping，這樣在我們的 Service 變多時，port number 以及分流規則的管理變得相當困難。而 Ingress 可以透過 HTTP/HTTPS，在我們眾多的 Service 前搭建一個 reverse-proxy。這樣 Ingress 可以幫助我們統一一個對外的 port number，並且根據 hostname 或是 pathname 決定封包要轉發到哪個 Service 上&lt;/li&gt;
&lt;li&gt;Namespace:命名空間，假如有多個用戶使用同一個Cluster，想把他們創建的Controller、Pod等資源分開，就靠Namespace。Namespace將物理的Cluster從邏輯上切成多個虛擬Cluster，每一個虛擬Cluster就是一個Namespace，不同Namespace中的資源完全隔離。K8s預設創建2個Namespace:
&lt;ul&gt;
&lt;li&gt;default:如果不指定，資源就預設放這&lt;/li&gt;
&lt;li&gt;kube-system:K8s自己創建的系統資源會放在這個Namespace中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211006-k8s/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>MySQL常用語句 &amp; Workbench</title>
        <link>https://yoziming.github.io/post/211005-mysql-cmd-workbench/</link>
        <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211005-mysql-cmd-workbench/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/211005-mysql-cmd-workbench/ -&lt;h1 id=&#34;mysql-常用語句&#34;&gt;MySQL 常用語句&lt;/h1&gt;
&lt;p&gt;資料庫database&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;create database XXX;
show databases;
use XXX;
drop database XXX;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;資料表table&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;create table mytable(school char(5),name char(10),id int);
show tables;
describe mytable; // 顯示這表有哪些欄位跟屬性
drop table mytable;
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select * from mytable; // 顯示mytable中所有資料

insert into mytable(school, name, id) values (&#39;NCTU&#39;,&#39;Jerry&#39;,&#39;123&#39;);
insert into mytable values (&#39;NCTU&#39;,&#39;Jerry&#39;,&#39;123&#39;);

update mytable set name = &#39;HaHa&#39; where id = &#39;123&#39;;

delete from mytable where name = &#39;HaHa&#39;;
delete from 表格; // 把表格內資料都刪除(但格式宣告還在)

select * from mytable where id = &#39;123&#39; order by name DESC;  // 資料表查詢+條件+排序 (DESC 代表由大到小排序)

load data local infile &amp;quot;c:\\data.txt&amp;quot; into table mytable; //匯入
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;mysql-workbench-常用操作&#34;&gt;MySQL Workbench 常用操作&lt;/h1&gt;
&lt;h3 id=&#34;欲編輯某張表的某個資料&#34;&gt;欲編輯某張表的某個資料&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在左方導航點開那張表，移到它的右上角可以看資訊、進入編輯模式等等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image-20211016183042070.png&#34; alt=&#34;image-20211016183042070&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;對資料欄位左鍵2下修改，改完之後按Apply，會跳出sql語句的確定視窗，再次Apply後應用&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;導出入資料&#34;&gt;導出/入資料 &lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;上方選到 Server &amp;gt; Data Import，會出現這個畫面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image-20211016183300110.png&#34; alt=&#34;image-20211016183300110&#34;&gt;&lt;/p&gt;
&lt;p&gt;照著按就是了，導出也差不多，不過導出可以選擇是否含格式還是單純資料值&lt;/p&gt;
- https://yoziming.github.io/post/211005-mysql-cmd-workbench/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Docker啟用Redis</title>
        <link>https://yoziming.github.io/post/211002-docker-redis/</link>
        <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211002-docker-redis/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/211002-docker-redis/ -&lt;h1 id=&#34;docker啟用redis&#34;&gt;Docker啟用Redis&lt;/h1&gt;
&lt;h2 id=&#34;抓映象檔&#34;&gt;抓映象檔&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker pull redis:6.0
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;拉一個6.0版本的redis&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;執行-image&#34;&gt;執行 Image&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run --name redis6 -p 6379:6379 -d redis:6.0 redis-server --appendonly yes
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;–name redis6 ：將 Container 取名為 redis6&lt;/li&gt;
&lt;li&gt;-p 6379:6379 ：將 Container 的 6379 Port 映射到主機的 6379 Port (前面代表主機，後面代表容器)&lt;/li&gt;
&lt;li&gt;-d :後台執行 Container ，並返回ID&lt;/li&gt;
&lt;li&gt;redis-server –appendonly yes : 在 Container 執行 redis-server 啟動命令，並打開redis持久化配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;進入-container&#34;&gt;進入 Container&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker exec -it redis6 bash
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;-i ：即使沒有附加也保持STDIN 打開&lt;/li&gt;
&lt;li&gt;-t ：分配一個偽終端&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;資料庫測試&#34;&gt;資料庫測試&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;redis-cli
set hello world
get hello
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/211002-docker-redis/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Docker啟用Mysql</title>
        <link>https://yoziming.github.io/post/211001-docker-mysql/</link>
        <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211001-docker-mysql/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/211001-docker-mysql/ -&lt;h1 id=&#34;docker啟用mysql&#34;&gt;Docker啟用Mysql&lt;/h1&gt;
&lt;h2 id=&#34;抓映象檔&#34;&gt;抓映象檔&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker pull mysql/mysql-server:8.0
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;拉一個8.0版本的mysql&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;執行-image&#34;&gt;執行 Image&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run -d -it --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=mydb mysql:8 --default-authentication-plugin=mysql_native_password
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;：同&lt;code&gt;--detach&lt;/code&gt;，以背景模式執行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v ~/mysql-docker-data:/var/lib/mysql&lt;/code&gt;：同&lt;code&gt;--volume&lt;/code&gt;，掛載host目錄到container目錄，也就是host的&lt;code&gt;~/mysql-docker-data&lt;/code&gt;會保存container &lt;code&gt;/var/lib/mysql&lt;/code&gt;的資料；windos docker app這樣做的話，資料是暫時的重開機後會不見。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-it&lt;/code&gt;：同&lt;code&gt;--interactive&lt;/code&gt;加&lt;code&gt;--tty&lt;/code&gt;，作用為運行container時可登入其bash操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name mysql8&lt;/code&gt;，命名container名稱為&lt;code&gt;mysql8&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;：同&lt;code&gt;--publish&lt;/code&gt;。作用為將container的3306 port對映到&amp;quot;主機(host)&amp;ldquo;的3306 port&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;：同&lt;code&gt;--env&lt;/code&gt;，設定環境變數。&lt;code&gt;MYSQL_ROOT_PASSWORD&lt;/code&gt;設定MySQL root帳號的登入密碼為&lt;code&gt;1234&lt;/code&gt;，&lt;code&gt;MYSQL_DATABASE&lt;/code&gt;設定資料庫名稱為&lt;code&gt;mydb&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mysql:8&lt;/code&gt;：&lt;code&gt;mysql&lt;/code&gt;為image名稱，&lt;code&gt;8&lt;/code&gt;為image tag。所以運行的是&lt;code&gt;mysql:8&lt;/code&gt;的image。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--default-authentication-plugin=mysql_native_password&lt;/code&gt;：把儲存密碼的方式改為MySQL 5的&lt;code&gt;mysql_native_password&lt;/code&gt;，因為MySQL 8的儲存方式預設為&lt;code&gt;caching_sha2_password&lt;/code&gt;，但一些免費的MySQL client圖形工具如Sequel Pro，Navicat等會無法連線，所以設定此參數。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;檢視運行中的容器&#34;&gt;檢視運行中的容器&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;進入-container&#34;&gt;進入 Container&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker exec mysql8 mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker exec&lt;/code&gt;指令的作用為在運行的container執行指令，所以意思就是在&lt;code&gt;mysql8&lt;/code&gt;這個container執行&lt;code&gt;mysql -u root -p&lt;/code&gt;的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker container exec -it mysql8 /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;遇到權限問題用這個&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;進入mysql&#34;&gt;進入Mysql&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql -uroot -p
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;新增-1-個開放外部連線的帳號&#34;&gt;新增 1 個開放外部連線的帳號&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE USER &#39;user01&#39;@&#39;%&#39; IDENTIFIED BY &#39;1234&#39;;
GRANT ALL ON your_database.* TO &#39;user01&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;IDENTIFIED BY &amp;lsquo;1234&amp;rsquo;=密碼&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;允許-mysql-被遠程訪問&#34;&gt;允許 MySQL 被遠程訪問&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;grant all privileges on *.* to &#39;root&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;這是一個強力手段(有權限風險)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;flush privileges;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/211001-docker-mysql/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Docker常用指令與操作</title>
        <link>https://yoziming.github.io/post/210930-docker-common-operations/</link>
        <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210930-docker-common-operations/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210930-docker-common-operations/ -&lt;h1 id=&#34;docker常用操作&#34;&gt;Docker常用操作&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官方 &lt;a href=&#34;https://docs.docker.com/engine/reference/run/&#34;&gt;https://docs.docker.com/engine/reference/run/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;容器運行前&#34;&gt;容器運行前&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;抓映像&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker pull xxx
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;容器運行中&#34;&gt;容器運行中&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;檢視運行中的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;停止容器
&lt;ul&gt;
&lt;li&gt;啟動換成 &lt;code&gt;start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重啟換成 &lt;code&gt;restart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;強殺換成 &lt;code&gt;kill&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker stop 容器名或ID
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;批次全部重啟
&lt;ul&gt;
&lt;li&gt;這個在windows docker也有效，特別適合自己練習專案用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;awk &#39;{ print $1}&#39;&lt;/code&gt;那種在windows就不行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker restart $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;刪除容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker rm -f 容器名或ID
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;檢視運行狀態(CPU、記憶體、I/O占用等等)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker stats -a
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;顯示運行日誌&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker logs 容器名或ID
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;查看詳情&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker inspect 容器名或ID
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;更新運行參數&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker update --restart=always 容器名或ID
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;進入 Container
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; ：即使沒有附加也保持STDIN 打開&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; ：分配一個偽終端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker exec -it  &amp;lt;container_id&amp;gt;  /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;容器內&#34;&gt;容器內&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;就是進到&lt;code&gt;/bin/sh&lt;/code&gt;之下，有個&lt;code&gt;$&lt;/code&gt;符號的狀態&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;locale&lt;/code&gt; 顯示container內的編碼&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;locale -a&lt;/code&gt; 顯示container可用的編碼&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常會選用&lt;code&gt;C.UTF-8&lt;/code&gt;，但是沒特別設定過的就會是Linux預設&lt;code&gt;POSIX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改方法: &lt;a href=&#34;https://ubuntuqa.com/zh-tw/article/9876.html&#34;&gt;https://ubuntuqa.com/zh-tw/article/9876.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 秀出當前目錄內檔案與資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cd&lt;/code&gt; 前往某資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;複製檔案&#34;&gt;複製檔案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;從Host丟進容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker cp /path1宿主路徑 容器名或ID:/path2容器路徑
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;從容器中搬檔案出來&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker cp 容器名或ID:/path/to/folder /path2宿主路徑/
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;注意操作就如同Linux 系統的 &lt;code&gt;cp -a&lt;/code&gt;，路徑可以是檔案也可以是資料夾，結尾加不加&lt;code&gt;/&lt;/code&gt;會決定是要放到&lt;code&gt;XX&lt;/code&gt;還是&lt;code&gt;XX之下&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;docker-desktop&#34;&gt;docker-desktop&lt;/h1&gt;
&lt;p&gt;UI中的Volumes實際路徑，可以用瀏覽器訪問&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;\\wsl$\docker-desktop-data\version-pack-data\community\docker\volumes\
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在WSL2中的/mnt/wsl只是暫時的，如果要連接&lt;/p&gt;
&lt;p&gt;在windows的cmd中執行&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;net use h: \\wsl$\docker-desktop-data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在WSL2 Ubuntu中執行&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir /mnt/wsl2

sudo mount -t drvfs h: /mnt/wsl2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;掛載相關&#34;&gt;掛載相關&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;範例: 掛載到window下的某個路徑&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run -d -p 8082:80 --name nginx -v G:/docker/nginx:/usr/share/nginx -v
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;但是這樣效率低，有時候還會因為windows跟linux編碼問題(例如檔頭、換行、空白權限之類的)出錯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參考: &lt;a href=&#34;https://lufor129.medium.com/docker-%E4%B8%89-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cvolume-net-5f323965486&#34;&gt;https://lufor129.medium.com/docker-%E4%B8%89-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cvolume-net-5f323965486&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;建議作法&#34;&gt;建議作法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用WSL2 Ubuntu當橋樑，開個terminal進到WSL虛擬機，再用linux下指令，這樣操作就都跟最常見的範例一樣&lt;/li&gt;
&lt;li&gt;要存取對應的檔案也很簡單，現在WSL2都支援直接GUI操作了(但要用win11)&lt;/li&gt;
&lt;li&gt;退一步可以用圖形化操作介面(X server)之類，也是非常快速便捷&lt;/li&gt;
&lt;li&gt;還有一招是VS code的remote插件，也很好用&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/210930-docker-common-operations/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Docker啟用MinIO</title>
        <link>https://yoziming.github.io/post/210929-docker-minio/</link>
        <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210929-docker-minio/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210929-docker-minio/ -&lt;h1 id=&#34;docker啟用minio儲存&#34;&gt;Docker啟用MinIO儲存&lt;/h1&gt;
&lt;h2 id=&#34;執行-image&#34;&gt;執行 Image&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run -d --name minio -e &amp;quot;MINIO_ROOT_USER=root&amp;quot; -e &amp;quot;MINIO_ROOT_PASSWORD=root1234&amp;quot; -p 9000:9000 -p 9001:9001 minio/minio server /data --console-address &amp;quot;:9001&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--name minio&lt;/code&gt;，命名container名稱為&lt;code&gt;minio&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /data/minio:/data/minio&lt;/code&gt;該命令將主機 &lt;code&gt;/data/minio&lt;/code&gt; 目錄對映到容器中的 &lt;code&gt;/data/minio&lt;/code&gt; 目錄中&lt;/li&gt;
&lt;li&gt;MinIO 還提供了圖形管理介面，在瀏覽器輸入 &lt;code&gt;ip:9001&lt;/code&gt;即可檢視&lt;/li&gt;
&lt;li&gt;不管是圖形介面操作，還是客戶端操作，預設賬號密碼都為 &lt;code&gt;minioadmin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;環境變數，這裡用了自定義賬號密碼，賬號不能小於 3 字元，密碼不能小於 8 字元&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;go初始化&#34;&gt;Go初始化&lt;/h2&gt;
&lt;p&gt;導入&lt;code&gt;github.com/minio/minio-go/v7&lt;/code&gt;，注意這個後面的&lt;code&gt;v7&lt;/code&gt;，在自動引包時可能會漏掉，導致使用到舊版的同名函數而報錯&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;InitMinio&lt;/span&gt;() {
	ctx := context.&lt;span style=&#34;color:#008b45&#34;&gt;Background&lt;/span&gt;()
	endpoint := &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;localhost:9000&amp;#34;&lt;/span&gt;
	accessKeyID := &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;
	secretAccessKey := &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;root1234&amp;#34;&lt;/span&gt;
	useSSL := &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;

	&lt;span style=&#34;color:#228b22&#34;&gt;// Initialize minio client object.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	minioClient, err := minio.&lt;span style=&#34;color:#008b45&#34;&gt;New&lt;/span&gt;(endpoint, &amp;amp;minio.Options{
		Creds:  credentials.&lt;span style=&#34;color:#008b45&#34;&gt;NewStaticV4&lt;/span&gt;(accessKeyID, secretAccessKey, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;),
		Secure: useSSL,
	})
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
		log.&lt;span style=&#34;color:#008b45&#34;&gt;Fatalln&lt;/span&gt;(err)
	}

	&lt;span style=&#34;color:#228b22&#34;&gt;// 創建預設的bucket
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;// Make a new bucket called mymusic.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	bucketName := &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;mymusic&amp;#34;&lt;/span&gt;
	location := &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;us-east-1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#228b22&#34;&gt;// 這個是AWS用的，詳細查他官方
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;

	err = minioClient.&lt;span style=&#34;color:#008b45&#34;&gt;MakeBucket&lt;/span&gt;(ctx, bucketName, minio.MakeBucketOptions{Region: location})
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
		&lt;span style=&#34;color:#228b22&#34;&gt;// Check to see if we already own this bucket (which happens if you run this twice)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		exists, errBucketExists := minioClient.&lt;span style=&#34;color:#008b45&#34;&gt;BucketExists&lt;/span&gt;(ctx, bucketName)
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; errBucketExists == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; exists {
			log.&lt;span style=&#34;color:#008b45&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;We already own %s\n&amp;#34;&lt;/span&gt;, bucketName)
		} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
			log.&lt;span style=&#34;color:#008b45&#34;&gt;Fatalln&lt;/span&gt;(err)
		}
	} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
		log.&lt;span style=&#34;color:#008b45&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Successfully created %s\n&amp;#34;&lt;/span&gt;, bucketName)
	}
	    &lt;span style=&#34;color:#228b22&#34;&gt;// 試著上傳一個.zip
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    objectName := &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;golden-oldies.zip&amp;#34;&lt;/span&gt;
    filePath := &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/tmp/golden-oldies.zip&amp;#34;&lt;/span&gt;
    contentType := &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;application/zip&amp;#34;&lt;/span&gt;

    &lt;span style=&#34;color:#228b22&#34;&gt;// Upload the zip file with FPutObject
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    info, err := minioClient.&lt;span style=&#34;color:#008b45&#34;&gt;FPutObject&lt;/span&gt;(ctx, bucketName, objectName, filePath, minio.PutObjectOptions{ContentType: contentType})
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
        log.&lt;span style=&#34;color:#008b45&#34;&gt;Fatalln&lt;/span&gt;(err)
    }

    log.&lt;span style=&#34;color:#008b45&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Successfully uploaded %s of size %d\n&amp;#34;&lt;/span&gt;, objectName, info.Size)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;配合gin框架範例&#34;&gt;配合Gin框架範例&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 假定要上傳頭像，先獲取圖片文件資訊
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	file, _ := ctx.&lt;span style=&#34;color:#008b45&#34;&gt;FormFile&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;avatar&amp;#34;&lt;/span&gt;)
	&lt;span style=&#34;color:#228b22&#34;&gt;// 這裡使用minioClient.PutObject（）方法上傳，入參是file.Open()。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	f, _ := file.&lt;span style=&#34;color:#008b45&#34;&gt;Open&lt;/span&gt;()
	&lt;span style=&#34;color:#228b22&#34;&gt;// 新增一個哈希命名規則防止圖片覆蓋
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	m5 := md5.&lt;span style=&#34;color:#008b45&#34;&gt;New&lt;/span&gt;()
	m5.&lt;span style=&#34;color:#008b45&#34;&gt;Write&lt;/span&gt;([]&lt;span style=&#34;color:#658b00&#34;&gt;byte&lt;/span&gt;(file.Filename+時間或uuid等等)
	fileName_hash := hex.&lt;span style=&#34;color:#008b45&#34;&gt;EncodeToString&lt;/span&gt;(m5.&lt;span style=&#34;color:#008b45&#34;&gt;Sum&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt;))
	&lt;span style=&#34;color:#228b22&#34;&gt;// 上傳到minio
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	info, err := model.MinioClient.&lt;span style=&#34;color:#008b45&#34;&gt;PutObject&lt;/span&gt;(ctx, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;avatar&amp;#34;&lt;/span&gt;, fileName_hash, f, -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, minio.PutObjectOptions{ContentType: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;avatar&amp;#34;&lt;/span&gt;})
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
		log.&lt;span style=&#34;color:#008b45&#34;&gt;Fatalln&lt;/span&gt;(err)
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;
	}
	log.&lt;span style=&#34;color:#008b45&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Successfully uploaded %s of size %d\n&amp;#34;&lt;/span&gt;, file.Filename, info.Size)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;細節補充&#34;&gt;細節補充&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;minio儲存的單位是 BUCKETS(桶)，創建完之後預設的Access Policy為Private，外部無法訪問，要改成public才行&lt;/li&gt;
&lt;li&gt;預設上傳的檔案網址就是http://{endpoint}/{buckets}/{Filename}，只要BUCKETS是public就能直接訪問&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/210929-docker-minio/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>consul基礎使用練習</title>
        <link>https://yoziming.github.io/post/210928-consul-practice/</link>
        <pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210928-consul-practice/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210928-consul-practice/ -&lt;h1 id=&#34;consul基礎使用練習&#34;&gt;consul基礎使用練習&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;想像去郵局辦事，consul類似於發號碼牌的那個機器&lt;/p&gt;
&lt;p&gt;伺服端(櫃台人員)去找consul註冊服務，比如說櫃台1~3提供儲蓄，櫃台4~6提供郵寄服務&lt;/p&gt;
&lt;p&gt;客戶進來透過服務發現，把要辦的事丟給consul，它查看哪個櫃台健康，幫你匹配對應的服務或叫號&lt;/p&gt;
&lt;p&gt;(感覺這例子不太完善，就&amp;hellip;類似的理解啦，實際用了才會懂)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下載&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 官網:
https://www.consul.io/downloads
# ubuntu shell: (下載&amp;gt;解壓縮&amp;gt;把二進位執行檔丟進去)
wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zip
unzip consul_1.10.3_linux_amd64.zip
sudo mv consul /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;consul -h
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;啟動server&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=192.168.234.128 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個IP=192.168.234.128=ubuntu的ip&lt;/p&gt;
&lt;p&gt;*若/etc/consul.d/不存在要先自己創&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看服務&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://192.168.234.128:8500/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;註冊自訂的健康檢查服務，範例:&lt;/p&gt;
&lt;p&gt;剛剛自訂的配置檔路徑/etc/consul.d/下新增一個web.json&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{&amp;quot;service&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;web&amp;quot;,
    &amp;quot;tags&amp;quot;: [&amp;quot;extract&amp;quot;, &amp;quot;verify&amp;quot;, &amp;quot;compare&amp;quot;, &amp;quot;idcard&amp;quot;],
    &amp;quot;address&amp;quot;: &amp;quot;192.168.234.128&amp;quot;,
    &amp;quot;port&amp;quot;: 9000,
    &amp;quot;check&amp;quot;: {
        &amp;quot;id&amp;quot;: &amp;quot;api&amp;quot;,
        &amp;quot;name&amp;quot;: &amp;quot;HTTP API on port 9000&amp;quot;,
        &amp;quot;http&amp;quot;: &amp;quot;http://localhost:9000&amp;quot;,
        &amp;quot;interval&amp;quot;: &amp;quot;10s&amp;quot;,
        &amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;
        }
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重啟server並查看服務&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-20210929143815247.png&#34; alt=&#34;image-20210929143815247&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;結果是不健康，因為沒有東西回應它&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;透過consul來傳遞一個簡單服務案例&#34;&gt;透過consul來傳遞一個簡單服務案例:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;person.proto&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;syntax=&amp;quot;proto3&amp;quot;;
package pb;
option go_package=&amp;quot;/.;pb&amp;quot;;
message Person{
    string name=1;
    int32 age=2;
}

service hello{
    rpc sayHello(Person) returns(Person);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;server&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/hashicorp/consul/api&amp;quot;
	&amp;quot;github.com/my/repo/consul/pb&amp;quot;
)

type Children struct {
}

// 綁定方法實現接口
func (c *Children) SayHello(ctx context.Context, p *pb.Person) (*pb.Person, error) {
	p.Name = &amp;quot;hello&amp;quot; + p.Name
	return p, nil
}

func main() {
	// 1. 把grpc註冊到consul，初始化
	consulConfig := api.DefaultConfig()

	// 2. 創建consul對象
	consulClient, err := api.NewClient(consulConfig)
	if err != nil {
		fmt.Println(&amp;quot;api.NewClient err&amp;quot;, err)
		return
	}

	// 3. 告訴consul將要註冊的服務消息
	reg := api.AgentServiceRegistration{
		ID:      &amp;quot;bj38&amp;quot;,
		Tags:    []string{&amp;quot;grpc&amp;quot;, &amp;quot;consul&amp;quot;},
		Name:    &amp;quot;grpc And Consul&amp;quot;,
		Address: &amp;quot;127.0.0.1&amp;quot;,
		Port:    8800,
		Check: &amp;amp;api.AgentServiceCheck{
			CheckID:  &amp;quot;consul grpc test&amp;quot;,
			TCP:      &amp;quot;127.0.0.1:8800&amp;quot;,
			Timeout:  &amp;quot;1s&amp;quot;,
			Interval: &amp;quot;5s&amp;quot;,
		},
	}
	// 4. 註冊到consul上
	consulClient.Agent().ServiceRegister(&amp;amp;reg)
	fmt.Println(&amp;quot;服務啟動...&amp;quot;)

}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;client&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;

	&amp;quot;github.com/hashicorp/consul/api&amp;quot;
	&amp;quot;github.com/my/repo/consul/pb&amp;quot;
	&amp;quot;google.golang.org/grpc&amp;quot;
)

func main() {
	// 初始化consul
	consulConfig := api.DefaultConfig()
	consulClient, err := api.NewClient(consulConfig)
	if err != nil {
		fmt.Println(&amp;quot;api.NewClient err&amp;quot;, err)
	}

	// 服務發現，從consul上獲取健康的服務
	services, _, err := consulClient.Health().Service(&amp;quot;grpc And Consul&amp;quot;, &amp;quot;grpc&amp;quot;, true, nil)
	if err != nil {
		fmt.Println(&amp;quot;consulClient.Health().Service err&amp;quot;, err)
		return
	}
	// 拼接出服務的IP跟端口
	fmt.Println(services[0].Service.Address)
	fmt.Println(services[0].Service.Port)
	addr := services[0].Service.Address + &amp;quot;:&amp;quot; + strconv.Itoa(services[0].Service.Port)

	grpcConn, _ := grpc.Dial(addr, grpc.WithInsecure())

	grpcClient := pb.NewHelloClient(grpcConn)
	var person pb.Person
	person.Name = &amp;quot;Tom~&amp;quot;
	person.Age = 18

	p, err := grpcClient.SayHello(context.TODO(), &amp;amp;person)
	fmt.Println(p, err)

}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;記得隨便用個cmd 開啟consul當橋梁&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ consul agent -dev
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210928-consul-practice/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Golang下透過grpc調用服務案例</title>
        <link>https://yoziming.github.io/post/210927-grpc/</link>
        <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210927-grpc/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210927-grpc/ -&lt;h2 id=&#34;golang下透過grpc調用服務案例&#34;&gt;Golang下透過grpc調用服務案例&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;grpc簡單說就是跨平台(跨語言)調用各種服務的通用轉接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;對.proto文件使用轉譯指令:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc --go_out=plugins=grpc:. *.proto
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;案例:透過grpc遠程傳遞一個調用teacher資料類型的服務&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;.proto:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;syntax=&amp;quot;proto3&amp;quot;;

option go_package=&amp;quot;/.;pb&amp;quot;;

message Teacher{
    int32 age=1;
    string name=2;
}

service SayName{
    rpc SayHello(Teacher) returns(Teacher);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;server:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Children struct{}

// 綁定類方法
func (c *Children) SayHello(ctx context.Context, t *pb.Teacher) (*pb.Teacher, error) {
	t.Name += &amp;quot;is sleeping&amp;quot;
	return t, nil
}

func main() {
	// 初始一個grpc對象
	grpcServer := grpc.NewServer()

	// 註冊服務
	pb.RegisterSayNameServer(grpcServer, new(Children))

	// 監聽
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8899&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;listen err&amp;quot;, err)
		return
	}
	fmt.Println(&amp;quot;server監聽中...&amp;quot;)
	defer listener.Close()

	// 啟動服務
	grpcServer.Serve(listener)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;client:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	// 連接grpc服務
	grpcConn, err := grpc.Dial(&amp;quot;127.0.0.1:8899&amp;quot;, grpc.WithInsecure())
	if err != nil {
		fmt.Println(&amp;quot;conn err&amp;quot;, err)
		return
	}
	defer grpcConn.Close()

	// 初起化客戶端
	gprcClient := pb.NewSayNameClient(grpcConn)

	// 創建並初始化接收對象
	var teacher pb.Teacher
	teacher.Age = 18
	teacher.Name = &amp;quot;Mary&amp;quot;

	// 調用遠程服務
	t, err := gprcClient.SayHello(context.TODO(), &amp;amp;teacher)
	fmt.Println(t, err)
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210927-grpc/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Golang中使用ProtoBuf</title>
        <link>https://yoziming.github.io/post/210926-golang-protobuf/</link>
        <pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210926-golang-protobuf/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210926-golang-protobuf/ -&lt;h2 id=&#34;golang中使用protobuf&#34;&gt;Golang中使用ProtoBuf&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;protobuf類似json，它體積更小效率更高，規範統一(沒有大小寫等困擾)。&lt;/p&gt;
&lt;p&gt;缺點是改動協議就要重新生成、數據本身是二進位沒有可讀性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下載，window系統選.exe，解壓縮放到$GOPATH/bin&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://github.com/protocolbuffers/protobuf/releases
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝golang對應的庫跟插件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go get github.com/golang/protobuf/proto
go get github.com/golang/protobuf/protoc-gen-go
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc -h 或 protoc --version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;沒報錯就是成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息體舉例，xxx.proto&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 指定版本，不打3就會是2
syntax=&amp;quot;proto3&amp;quot;;

// 指定輸出位置&amp;amp;go包名，沒寫轉換不了
// option go_package =&amp;quot;path;name&amp;quot;;
option go_package =&amp;quot;/.&amp;quot;;  // 放在同一目錄下包名為__(空)

// 定義消息體，分配唯一編號 (不能用19000~19999)
message Student{
     int32 age = 1; // 可以不從1開始，但不可重複
     string name = 2;
     People p=3;
     repeated int32 score=4; // 數組
     Week w=5;
     // 聯合體
     oneof data{
         string teacher=6;
         string class=7;
     }
 }

// 消息體可以嵌套
message People{
    int32 weight=1;
}

// 定義枚舉類型
enum Week{
    Monday=0; // 必須從0開始
    Turesday=1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成go文件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc --go_out=. *.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成功轉換出來的就會是一個xxx.pb.go的文件，可以點開看一下，它就是轉換成go語言的版本，記住不要修改這個檔案(他第一行就叫你不要修改)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;添加rpc服務&#34;&gt;添加rpc服務&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;語法:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;service 服務名{
	rpc 函數名(參數:消息體) returns (返回值:消息)
}
舉例:
service bj{
    rpc Say(People) returns (Student);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是rpc用的很廣，他不知道你要轉成給誰用的，於是要調用另一個生成的指令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc --go_out=plugins=grpc:. *.proto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這就是grpc了，到下章繼續&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/210926-golang-protobuf/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>MVC &amp; Microservices</title>
        <link>https://yoziming.github.io/post/210920-mvc-microservices/</link>
        <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210920-mvc-microservices/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210920-mvc-microservices/ -&lt;h2 id=&#34;mvc架構&#34;&gt;MVC架構&lt;/h2&gt;
&lt;p&gt;Model:模型，管理資料庫(增刪改查)、業務邏輯、物件結構定義&lt;/p&gt;
&lt;p&gt;View:視圖，使用者實際在看、操作的介面(UI)，前端&lt;/p&gt;
&lt;p&gt;Controller:控制，接收請求、回覆結果，決定工作流程，算是Model跟View的中間人&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-20211012085838544.png&#34; alt=&#34;image-20211012085838544&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;微服務架構microservices&#34;&gt;微服務架構（Microservices）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;單一職責:把業務邏輯拆分成無數個小區塊(Blocks)，負責單一任務，服務之間透過管道來通訊。&lt;/li&gt;
&lt;li&gt;輕量級通訊:使用不依賴語言或平台的格式，例如XML、JSON、protobuf。通常基於HTTP協議、符合REST風格來達成標準化、無狀態化。&lt;/li&gt;
&lt;li&gt;獨立開發、測試、部屬:顧名思義，都拆開了就可以分開做，不像傳統架構牽一髮而動全身。&lt;/li&gt;
&lt;li&gt;容器化:微服務既然能獨立作業了，就可以放到容器(Container)中，互相隔離互不干擾，達成快速部署、節省資源。Docker是目前最普遍的容器技術，Kubernetes(K8s)是常用來管理容器、協調整合的平台。&lt;/li&gt;
&lt;/ol&gt;
- https://yoziming.github.io/post/210920-mvc-microservices/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>GoogleSearchConsole</title>
        <link>https://yoziming.github.io/post/211020-blog-ga/</link>
        <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/211020-blog-ga/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/211020-blog-ga/ -&lt;h3 id=&#34;如何讓自己的blog被google搜尋到&#34;&gt;如何讓自己的blog被google搜尋到&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先你要跟google證明這個網站是你的，並且允許google的爬蟲機器人獲取你的網站資料，這樣別人才能在google上搜尋到你的網站&lt;/li&gt;
&lt;li&gt;同時也能夠使用google自訂搜尋方便自己查找資料&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;關於網站驗證&#34;&gt;關於網站驗證&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;你同意後它才能把觸手深入你的網站，你可以自訂搜尋這個網站的資料權限&lt;/li&gt;
&lt;li&gt;google提供多種方法，我是選html標記，放在套用的主題的之下，舉例:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image-20211128111531398.png&#34; alt=&#34;image-20211128111531398&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你換了主題記得也要重改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image-20211204160157780.png&#34; alt=&#34;image-20211204160157780&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;hugo建立sitemap索引&#34;&gt;Hugo建立sitemap索引&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提供sitemap索引讓google機器人更好抓你的網站&lt;/li&gt;
&lt;li&gt;Hugo內鍵就有這個功能，修改config.toml，插入:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[sitemap]
  changefreq = &#39;weekly&#39;
  filename = &#39;sitemap.xml&#39;
  priority = 0.5
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;自訂搜尋&#34;&gt;自訂搜尋&lt;/h3&gt;
&lt;p&gt;大部分主題都有此功能，一樣修改config.toml即可:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;googleSearchCode = &amp;quot;你的SearchCode&amp;quot;
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/211020-blog-ga/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>HugoBlog的圖片插入方式</title>
        <link>https://yoziming.github.io/post/210930-blog-insert-image/</link>
        <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210930-blog-insert-image/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210930-blog-insert-image/ -&lt;h1 id=&#34;插入圖片的方式&#34;&gt;插入圖片的方式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;常見有2種做法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;方法1&#34;&gt;方法1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在.\static\images\下放入的圖片會被打包上傳，然後從相對路徑引用那個圖片&lt;/li&gt;
&lt;li&gt;適和用在全站通用的資源，比如&lt;strong&gt;背景圖、縮圖&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法2&#34;&gt;方法2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在.\content\post\下，每當有用到圖片一篇文章的就新增一個資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料夾可以命名可自訂，然後進去把.md檔改名為&amp;quot;index.md&amp;quot;，圖片放同層&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;範例:&lt;img src=&#34;image-20211128105331357.png&#34; alt=&#34;image-20211128105331357&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;這個方法比較好整理，每篇用到的圖片放在自己的資料夾中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/210930-blog-insert-image/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>用Hugo建立靜態Blog</title>
        <link>https://yoziming.github.io/post/210909-blog-hugo/</link>
        <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210909-blog-hugo/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210909-blog-hugo/ -&lt;h1 id=&#34;用githubhugo建立靜態blog&#34;&gt;用Github&amp;amp;Hugo建立靜態Blog&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;程式設計師寫blog再常見不過，好處多多不再贅述，但如何從0開始架出一個blog?&lt;/p&gt;
&lt;p&gt;我看了很多教學有各種高級的自動部署、netlify後台等等，照做時卻老是在一些關鍵點卡住。我這個土路雖然蠢笨但確實能做出東西，同樣新手可以試試。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝Chocolatey //程式安裝器，讓你從終端裝各種東西很方便&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://chocolatey.org/install
到這個網址，官方提供很多方法安裝，非常簡單快速一行搞定
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安裝hugo，有些佈景主題要用到加強版(extended)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;choco install hugo -confirm
choco install hugo-extended -confirm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hugo new site &amp;lt;資料夾名稱&amp;gt; //建立一個root，相當於你個人網站的原始資料母巢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挑主題，到https://themes.gohugo.io/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套用主題，範例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; cd &amp;lt;資料夾名稱&amp;gt;
 git init
 git submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依照主題的說明文件修改根目錄下的config.toml
注意，config.toml中的第一項baseURL網址不要有&amp;quot;https://www.ooxx&amp;quot;，否則會造成一些未知的BUG。正確網址應為&amp;quot;https://你的username.github.io/&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到content/post/下開始寫一篇blog&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;開啟本地預覽，指令hugo server -F   //防止時差問題用-F&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隨意一個地方開啟網址http://localhost:1313/ 看看網站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;網站沒問題就打包，指令hugo，會在root資料夾下多出一個public資料夾，裡面就是一個完整的網站準備丟去網路上發布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去gitHub建一個Repository(倉庫)，名稱強制為 你的username.github.io&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下載GitHub Desktop客戶端，可以把他理解成一個雲端，我要把本地public資料夾的內容透過它丟去gitHub上剛剛建的那個Repository(倉庫)裡，之後就能透過網站提供的gitPage功能實現個人網站的搭建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在gitHub網頁點進創建的username.github.io專案，右上角綠色&amp;quot;Code&amp;quot;點開，用桌面程式開啟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式開啟後他會要你選擇一個本地的位置去連結該倉庫，直接連結到root/public下看似方便但會導致一些麻煩&amp;amp;錯誤，菜雞如我是放在根目錄同級的位置，姑且稱這個資料夾叫雲端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把根目錄下public/裡面的內容copy一份到剛剛建立的雲端資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此時回到GitHub Desktop客戶端它會說檢測到本地有新東西準備要上傳，左下角Summary填一個描述(隨意填但必要，他就是讓你描述一下這批上傳的動作，以後冤有頭債有主)，然後點Commit to main，至此一切準備就緒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到右邊點第一次叫publish之類，後面那個按鍵會變成push origin，即是把資料正式上傳到網路上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等個幾秒後到&amp;quot;https://username.github.io/&amp;ldquo;看看成果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之後要更新就是content/post/下建立新的.md，寫完內容然後hugo打包之後push&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
- https://yoziming.github.io/post/210909-blog-hugo/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>一次性隊列</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-queue/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-queue/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-queue/ -&lt;h1 id=&#34;一次性隊列&#34;&gt;一次性隊列&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//用結構體管理隊列
type Queue struct {
	maxSize int
	array   [3]int
	front   int //隊列首(不包含)
	rear    int //隊尾(含)
}

//添加數據val到隊列
func (q *Queue) AddQueue(val int) (err error) {
	//先判斷是否已滿
	if q.rear == q.maxSize-1 {
		return errors.New(&amp;quot;queue full&amp;quot;)
	}
	q.rear++
	q.array[q.rear] = val
	return
}

//取出數據
func (q *Queue) GetQueue() (val int, err error) {
	//先判斷是否為空
	if q.rear == q.front {
		return -1, errors.New(&amp;quot;queue empty&amp;quot;)
	}
	q.front++
	val = q.array[q.front]
	return val, err

}

//顯示隊列
func (q *Queue) ShowQueue() {
	fmt.Println(&amp;quot;當前隊列=&amp;quot;)
	for i := q.front + 1; i &amp;lt;= q.rear; i++ {
		fmt.Printf(&amp;quot;array[%d]=%d\t&amp;quot;, i, q.array[i])
	}
	fmt.Println(&amp;quot;隊列顯示完畢&amp;quot;)
}

func main() {
	//創建一個隊列
	queue1 := Queue{
		maxSize: 3,
		front:   -1,
		rear:    -1,
	}
	var key string
	var val int
	for {
		fmt.Println(&amp;quot;\n等待操作中...&amp;quot;)
		fmt.Println(&amp;quot;輸入add 添加&amp;quot;)
		fmt.Println(&amp;quot;輸入get 取出&amp;quot;)
		fmt.Println(&amp;quot;輸入show 顯示&amp;quot;)
		fmt.Println(&amp;quot;輸入exit 離開&amp;quot;)

		fmt.Scanln(&amp;amp;key)
		switch key {
		case &amp;quot;add&amp;quot;:
			fmt.Println(&amp;quot;輸入要加入的數值...&amp;quot;)
			fmt.Scanln(&amp;amp;val)
			err := queue1.AddQueue(val)
			if err != nil {
				fmt.Println(err.Error())
			} else {
				fmt.Println(&amp;quot;加入成功&amp;quot;)
			}
		case &amp;quot;get&amp;quot;:
			val, err := queue1.GetQueue()
			if err != nil {
				fmt.Println(err.Error())
			} else {
				fmt.Println(&amp;quot;取出成功&amp;quot;, val)
			}

		case &amp;quot;show&amp;quot;:
			queue1.ShowQueue()
		case &amp;quot;exit&amp;quot;:
			os.Exit(0)
		}

	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-queue/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>二分樹的3種遍歷</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-bi-tree/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-bi-tree/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-bi-tree/ -&lt;h1 id=&#34;二分樹的3種遍歷&#34;&gt;二分樹的3種遍歷&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Hero struct {
	No    int
	Name  string
	Left  *Hero
	Right *Hero
}

//前序遍歷 先輸出root 再輸出左子樹 再輸出右子樹，會中左右一層層往下
func PreOrder(node *Hero) {
	if node != nil {
		fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)
		PreOrder(node.Left)
		PreOrder(node.Right)
	}
}

//中序遍歷 左子樹 root 右子樹
func InfixOrder(node *Hero) {
	if node != nil {
		InfixOrder(node.Left)
		fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)
		InfixOrder(node.Right)
	}
}

//後序遍歷 左子樹  右子樹 root，會一路到最左最下開始打
func PostOrder(node *Hero) {
	if node != nil {
		PostOrder(node.Left)
		PostOrder(node.Right)
		fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)

	}
}

func main() {
	//建一個二分樹
	root := &amp;amp;Hero{
		No:   1,
		Name: &amp;quot;宋江&amp;quot;,
	}

	left1 := &amp;amp;Hero{
		No:   2,
		Name: &amp;quot;無用&amp;quot;,
	}

	right1 := &amp;amp;Hero{
		No:   3,
		Name: &amp;quot;你軌&amp;quot;,
	}
	root.Left = left1
	root.Right = right1
	right2 := &amp;amp;Hero{
		No:   4,
		Name: &amp;quot;林沖&amp;quot;,
	}
	right1.Right = right2
	node21 := &amp;amp;Hero{
		No:   21,
		Name: &amp;quot;無用-下左&amp;quot;,
	}
	node22 := &amp;amp;Hero{
		No:   22,
		Name: &amp;quot;無用-下右&amp;quot;,
	}
	left1.Left = node21
	left1.Right = node22

	PreOrder(root)
	fmt.Println(&amp;quot;==========&amp;quot;)
	InfixOrder(root)
	fmt.Println(&amp;quot;==========&amp;quot;)
	PostOrder(root)

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-bi-tree/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>哈希表數據結構</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-hash/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-hash/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-hash/ -&lt;h1 id=&#34;哈希表數據結構&#34;&gt;哈希表數據結構&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

type Emp struct {
	Id   int
	Name string
	Next *Emp
}

func (e *Emp) ShowMe() {
	fmt.Printf(&amp;quot;链表%d 找到该雇员 %d\n&amp;quot;, e.Id%7, e.Id)
}

//不帶表頭，即第一個節點就放雇員資料
type EmpLink struct {
	Head *Emp
}

func (e *EmpLink) FindByIdEmpLink(id int) *Emp {
	cur := e.Head
	for {
		if cur != nil &amp;amp;&amp;amp; cur.Id == id {
			return cur
		} else if cur == nil {
			break
		}
		cur = cur.Next
	}
	return nil
}

//給EmpLink寫增加雇員方法，編號從小到大
func (e *EmpLink) AddEmpLink(emp *Emp) {
	cur := e.Head      //輔助指針
	var pre *Emp = nil //輔助指針pre在cur前面
	//如果當前EmpLink是空的
	if cur == nil {
		e.Head = emp
		return
	}
	//給emp找位置並插入
	for {
		if cur != nil {
			if cur.Id &amp;gt; emp.Id { //找到
				break
			}
			pre = cur
			cur = cur.Next
		} else {
			break
		}
	}
	pre.Next = emp
	emp.Next = cur
}

func (e *EmpLink) ShowLink() {
	//如果當前EmpLink是空的
	if e.Head == nil {
		fmt.Println(&amp;quot;當前鏈表為空&amp;quot;)
		return
	}
	cur := e.Head
	for {
		if cur != nil {
			fmt.Printf(&amp;quot;雇員ID=%d 名字=%s ~&amp;gt;&amp;quot;, cur.Id, cur.Name)
			cur = cur.Next
		} else {
			break
		}
	}
	fmt.Println()
}

//鏈表數組
type HashTable struct {
	LinkArr [7]EmpLink
}

//給HashTable寫增加雇員方法
func (h *HashTable) Add(emp *Emp) {
	//使用散列函數，確定雇員添到哪個鏈表
	linkNo := h.HashFun(emp.Id)
	//添加
	h.LinkArr[linkNo].AddEmpLink(emp)
}

//顯示所有HashTable雇員方法
func (h *HashTable) ShowAll() {
	for i := 0; i &amp;lt; len(h.LinkArr); i++ {
		h.LinkArr[i].ShowLink()
	}
}

//查找
func (h *HashTable) FindById(id int) *Emp {
	linkNo := h.HashFun(id)
	return h.LinkArr[linkNo].FindByIdEmpLink(id)
}

//散列函數
func (h *HashTable) HashFun(id int) int {
	return id % 7 //得到一個值，就是鏈表的下標
}

func main() {
	key := 0
	id := 0
	name := &amp;quot;&amp;quot;
	var hashTable HashTable
	for {
		fmt.Println(&amp;quot;===雇員系統===&amp;quot;)
		fmt.Println(&amp;quot;\t1.添加&amp;quot;)
		fmt.Println(&amp;quot;\t2.顯示&amp;quot;)
		fmt.Println(&amp;quot;\t3.查找&amp;quot;)
		fmt.Println(&amp;quot;\t4.退出&amp;quot;)
		fmt.Scanln(&amp;amp;key)
		switch key {
		case 1:
			fmt.Println(&amp;quot;輸入雇員ID&amp;quot;)
			fmt.Scanln(&amp;amp;id)
			fmt.Println(&amp;quot;輸入雇員 name&amp;quot;)
			fmt.Scanln(&amp;amp;name)
			emp := &amp;amp;Emp{
				Id:   id,
				Name: name,
			}
			hashTable.Add(emp)
		case 2:
			hashTable.ShowAll()
		case 3:
			fmt.Println(&amp;quot;輸入欲查雇員ID&amp;quot;)
			fmt.Scanln(&amp;amp;id)
			emp := hashTable.FindById(id)
			if emp == nil {
				fmt.Println(&amp;quot;不存在&amp;quot;)
			} else {
				emp.ShowMe()
			}
		case 4:
			os.Exit(0)
		default:
			fmt.Println(&amp;quot;輸入錯誤&amp;quot;)
		}
	}

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-hash/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>單向鏈表</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-list/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-list/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-list/ -&lt;h1 id=&#34;單向鏈表&#34;&gt;單向鏈表&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type HeroNode struct {
	no   int
	name string
	next *HeroNode //表示指向下一個節點
}

//給鏈表插入節點
func Insert(head *HeroNode, newHeroNode *HeroNode) {
	//先找到最後的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		}
		temp = temp.next //不斷往下找
	}
	//把newHeroNode加到屁股
	temp.next = newHeroNode
}

//根據No從小到大插入
func InsertNo(head *HeroNode, newHeroNode *HeroNode) {
	//想找到適當的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		} else if temp.next.no &amp;gt; newHeroNode.no {
			//表示new要插到temp後
			break
		} else if temp.next.no == newHeroNode.no {
			//表示new這個編號已存在
			fmt.Println(newHeroNode.no, &amp;quot;該編號已存在&amp;quot;)
			return
		}
		temp = temp.next //不斷往下找

	}
	//把newHeroNode加到找到的地方
	newHeroNode.next = temp.next
	temp.next = newHeroNode
}

//根據no刪除一個節點
func DelHeroNode(head *HeroNode, id int) {
	//想找到適當的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		} else if temp.next.no == id {
			//表示找到了
			fmt.Println(id, &amp;quot;該編號已刪除&amp;quot;)
			temp.next = temp.next.next
			return
		}
		temp = temp.next //不斷往下找
	}

}

//顯示
func List(head *HeroNode) {
	//創建一個輔助
	temp := head
	if temp.next == nil { //空鏈表?
		fmt.Println(&amp;quot;空&amp;quot;)
		return
	}
	for {
		fmt.Printf(&amp;quot;[%d,%s]==&amp;gt;&amp;quot;, temp.next.no, temp.next.name)
		temp = temp.next      //不斷往下找
		if temp.next == nil { //到尾了
			fmt.Println(&amp;quot;完畢&amp;quot;)
			break
		}
	}
}

func main() {
	//創建一個頭節點(空的)
	head := &amp;amp;HeroNode{}
	hero1 := &amp;amp;HeroNode{
		no:   1,
		name: &amp;quot;宋江&amp;quot;,
	}
	hero2 := &amp;amp;HeroNode{
		no:   2,
		name: &amp;quot;李奎&amp;quot;,
	}
	hero3 := &amp;amp;HeroNode{
		no:   3,
		name: &amp;quot;李軌&amp;quot;,
	}
	hero4 := &amp;amp;HeroNode{
		no:   3,
		name: &amp;quot;321&amp;quot;,
	}
	InsertNo(head, hero3)
	InsertNo(head, hero1)
	InsertNo(head, hero2)
	InsertNo(head, hero4)
	List(head)
	DelHeroNode(head, 2)
	List(head)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-list/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>插入&amp;選擇&amp;快速排序</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-quick-sort/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-quick-sort/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-quick-sort/ -&lt;h1 id=&#34;插入選擇快速排序&#34;&gt;插入&amp;amp;選擇&amp;amp;快速排序&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//選擇排序
func SelectSort(array *[6]int) {
	for j := 0; j &amp;lt; len(array)-1; j++ {
		min := array[j]
		minIndex := j
		//尋找最小的下標
		for i := j + 1; i &amp;lt; len(array); i++ {
			if min &amp;gt; array[i] {
				min = array[i]
				minIndex = i
			}
		}
		if minIndex != j {
			array[j], array[minIndex] = array[minIndex], array[j]
		}
		fmt.Printf(&amp;quot;第%d次交換後 %v\n&amp;quot;, j+1, *array)
	}

}

//插入排序
func InsertSort(arr *[6]int) {
	for j := 1; j &amp;lt; len(arr); j++ {
		//給第二個元素找位置
		insertVal := arr[j]
		insertIndex := j - 1 //下標
		//由大到小
		for insertIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[insertIndex] &amp;lt; insertVal {
			arr[insertIndex+1] = arr[insertIndex] //數據後移
			insertIndex--
		}
		//插入
		if insertIndex+1 != j {
			arr[insertIndex+1] = insertVal
		}
		fmt.Printf(&amp;quot;第%d次插入後 %v\n&amp;quot;, j, *arr)
	}

}

//快速排序
func QuickSort(left int, right int, array *[6]int) {
	l := left
	r := right
	pivot := array[(left+right)/2] //中軸

	//比pivot小就放到左邊，反之亦然
	for l &amp;lt; r {
		for array[l] &amp;lt; pivot {
			l++
		}
		for array[r] &amp;gt; pivot {
			r--
		}
		if l &amp;gt;= r { //表示分割完成
			break
		}
		//如果沒完成就交換
		array[l], array[r] = array[r], array[l]
		//改善
		if array[l] == pivot {
			r--
		}
		if array[r] == pivot {
			l++
		}
	}
	//防卡住
	if l == r {
		l++
		r--
	}
	if left &amp;lt; r {
		QuickSort(left, r, array)
	}
	if right &amp;gt; l {
		QuickSort(l, right, array)
	}

}

func main() {
	// var array = [6]int{10, 34, 19, 100, 80, -5}
	// // SelectSort(&amp;amp;array)
	// // InsertSort(&amp;amp;array)
	// // fmt.Println(array)
	// QuickSort(0, len(array)-1, &amp;amp;array)
	// fmt.Println(array)

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-quick-sort/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>模擬棧&amp;四則運算</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-stack/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-stack/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-stack/ -&lt;h1 id=&#34;模擬棧四則運算&#34;&gt;模擬棧&amp;amp;四則運算&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//模擬棧的使用
type Stack struct {
	MaxTop int //最大可存個數
	Top    int //頂
	arr    [20]int
}

func (s *Stack) Push(val int) (err error) {
	//先判斷是否滿
	if s.Top == s.MaxTop-1 {
		fmt.Println(&amp;quot;stack full&amp;quot;)
		return errors.New(&amp;quot;stack full&amp;quot;)
	}
	//放入數據
	s.Top++
	s.arr[s.Top] = val
	return
}

func (s *Stack) Pop() (val int, err error) {
	//先判斷是否空
	if s.Top == -1 {
		fmt.Println(&amp;quot;stack empty&amp;quot;)
		return 0, errors.New(&amp;quot;stack empty&amp;quot;)
	}
	//彈出數據
	val = s.arr[s.Top]
	s.Top--
	return val, nil
}

//遍歷
func (s *Stack) List() {
	//先判斷是否空
	if s.Top == -1 {
		fmt.Println(&amp;quot;stack empty&amp;quot;)
		return
	}
	fmt.Println(&amp;quot;stack now=&amp;quot;)
	for i := s.Top; i &amp;gt;= 0; i-- {
		fmt.Printf(&amp;quot;arr[%d]=%d\n&amp;quot;, i, s.arr[i])
	}
}

//判斷字符是數字還運算符號
func (s *Stack) IsOper(val int) bool {
	if val == 42 || val == 43 || val == 45 || val == 47 {
		//ASC碼的+-*/
		return true
	} else {
		return false
	}
}

//運算
func (s *Stack) Cal(n1, n2, oper int) int {
	res := 0
	switch oper {
	case 42:
		res = n2 * n1
	case 43:
		res = n2 + n1
	case 45:
		res = n2 - n1
	case 47:
		res = n2 / n1
	default:
		fmt.Println(&amp;quot;運算符號錯誤&amp;quot;)
	}
	return res
}

//優先級
func (s *Stack) Priority(oper int) int {
	res := 0
	if oper == 42 || oper == 47 {
		res = 1
	} else if oper == 43 || oper == 45 {
		res = 0
	}
	return res
}

func main() {
	// stack := &amp;amp;Stack{
	// 	MaxTop: 5,  //最多存5個
	// 	Top:    -1, //表示棧為空
	// }
	// stack.Push(1)
	// stack.Push(2)
	// stack.Push(3)
	// stack.Push(4)
	// stack.Push(5)
	// stack.Push(6)
	// p1, _ := stack.Pop()
	// fmt.Println(&amp;quot;彈出&amp;quot;, p1)
	// p1, _ = stack.Pop()
	// fmt.Println(&amp;quot;彈出&amp;quot;, p1)
	// p1, _ = stack.Pop()
	// fmt.Println(&amp;quot;彈出&amp;quot;, p1)
	// p1, _ = stack.Pop()
	// fmt.Println(&amp;quot;彈出&amp;quot;, p1)
	// p1, _ = stack.Pop()
	// fmt.Println(&amp;quot;彈出&amp;quot;, p1)

	//四則運算練習

	//數字棧
	numStack := &amp;amp;Stack{
		MaxTop: 20,
		Top:    -1,
	}

	//運算符號
	operStack := &amp;amp;Stack{
		MaxTop: 20,
		Top:    -1,
	}

	exp := &amp;quot;30+20*6+1&amp;quot;
	n1 := 0
	n2 := 0
	oper := 0
	res := 0
	keepNum := &amp;quot;&amp;quot;

	//定義一個index來掃描
	index := 0
	for {
		ch := exp[index : index+1]  //字符串
		temp := int([]byte(ch)[0])  //對應的ASC碼
		if operStack.IsOper(temp) { //說明是符號
			if operStack.Top == -1 { //說明是空棧
				operStack.Push(temp) //就入
			} else {
				if operStack.Priority(operStack.arr[operStack.Top]) &amp;gt;= operStack.Priority(temp) {
					//比較一下棧頂的運算符號優先級，如果有先乘除的
					n1, _ = numStack.Pop()
					n2, _ = numStack.Pop()
					oper, _ = operStack.Pop()
					res = operStack.Cal(n1, n2, oper)
					//算完塞回去
					numStack.Push(res)
					operStack.Push(temp)
				} else {
					operStack.Push(temp)
				}
			}
		} else {
			//處理多位數，看index後面是不是運算符號
			//拼接
			keepNum += ch

			if index == len(exp)-1 { //如果已經到最後
				val, _ := strconv.ParseInt(keepNum, 10, 64)
				numStack.Push(int(val))
			} else {
				if operStack.IsOper(int([]byte(exp[index+1 : index+2])[0])) {
					val, _ := strconv.ParseInt(keepNum, 10, 64)
					numStack.Push(int(val))
					keepNum = &amp;quot;&amp;quot;
				}
			}
			//從ASC轉回數字
			// val, _ := strconv.ParseInt(ch, 10, 64)
			// numStack.Push(int(val))
		}
		//判斷是否繼續掃描
		if index+1 == len(exp) {
			break
		}
		index++
	}

	for {
		if operStack.Top == -1 {
			break
		}
		n1, _ = numStack.Pop()
		n2, _ = numStack.Pop()
		oper, _ = operStack.Pop()
		res = operStack.Cal(n1, n2, oper)
		//算完塞回去
		numStack.Push(res)
	}
	final, _ := numStack.Pop()
	fmt.Printf(&amp;quot;算式%s=%v&amp;quot;, exp, final)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-stack/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>環形單向鏈表</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-circle-list/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-circle-list/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-circle-list/ -&lt;h1 id=&#34;環形單向鏈表&#34;&gt;環形單向鏈表&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type CatNode struct {
	no   int
	name string
	next *CatNode
}

func Insert(head *CatNode, newCatNode *CatNode) {
	//判斷是否第一隻貓
	if head.next == nil {
		head.no = newCatNode.no
		head.name = newCatNode.name
		head.next = head //構成環形
		fmt.Println(*newCatNode, &amp;quot;已初始化並加入環形鏈表&amp;quot;)
		return
	}

	//定義一個變量找到環形最後一個
	temp := head
	for {
		if temp.next == head {
			break
		}
		temp = temp.next

	}
	temp.next = newCatNode
	fmt.Println(*newCatNode, &amp;quot;已加入環形鏈表&amp;quot;)
	newCatNode.next = head

}

func Del(head *CatNode, id int) *CatNode {
	temp := head
	helper := head
	if temp.next == nil {
		fmt.Println(&amp;quot;這是一個空鏈表&amp;quot;)
		return head
	}
	if temp.next == head { //只有一點
		temp.next = nil
		fmt.Println(id, &amp;quot;已刪除&amp;quot;)
		return head
	}

	//helper放到尾
	for {
		if helper.next == head {
			break
		}
		helper = helper.next
	}

	flag := true
	for {
		if temp.next == head { //說明比到最後一個了
			break
		}
		if temp.no == id {
			if temp == head { //說明刪除的是頭
				head = head.next
			}
			helper.next = temp.next
			fmt.Println(id, &amp;quot;已刪除&amp;quot;)
			flag = false
			break
		}
		temp = temp.next     //移動比較用
		helper = helper.next //一旦找到要刪除的點
	}
	if flag {
		if temp.no == id {
			helper.next = temp.next
			fmt.Println(id, &amp;quot;已刪除&amp;quot;)
		} else {
			fmt.Println(id, &amp;quot;找不到&amp;quot;)
		}
	}
	return head
}

func List(head *CatNode) {
	temp := head
	if temp.next == nil {
		fmt.Println(&amp;quot;空的環形鏈表&amp;quot;)
		return
	}
	for {
		fmt.Printf(&amp;quot;貓id=%d name=%s ~&amp;gt;&amp;quot;, temp.no, temp.name)
		if temp.next == head {
			break
		}
		temp = temp.next
	}
	fmt.Println()
}

func main() {
	head := &amp;amp;CatNode{}
	cat1 := &amp;amp;CatNode{
		no:   1,
		name: &amp;quot;tom&amp;quot;,
	}
	cat2 := &amp;amp;CatNode{
		no:   2,
		name: &amp;quot;bbb&amp;quot;,
	}
	cat3 := &amp;amp;CatNode{
		no:   3,
		name: &amp;quot;ccc&amp;quot;,
	}

	Insert(head, cat1)
	Insert(head, cat2)
	Insert(head, cat3)
	List(head)
	// Del(head, 2)
	// List(head)
	head = Del(head, 4)
	List(head)

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-circle-list/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>稀疏數組</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-array3/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-array3/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-array3/ -&lt;h1 id=&#34;稀疏數組&#34;&gt;稀疏數組&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type ValNode struct {
	row int //橫的
	col int //直的
	val int
}

func main() {
	//創建數組範例
	var chessMap [11][11]int
	chessMap[1][2] = 1
	chessMap[2][3] = 2

	//輸出看樣子
	for _, v := range chessMap {
		for _, v2 := range v {
			fmt.Printf(&amp;quot;%d\t&amp;quot;, v2)
		}
		fmt.Println()
	}

	//轉成稀疏數組，思路:遍歷他，創造一個結構體，發現有值就放進對應的切片
	var sparseArr []ValNode
	//紀錄規模跟預設值
	valNode0 := ValNode{
		row: 11,
		col: 11,
		val: 0,
	}
	sparseArr = append(sparseArr, valNode0)

	for i, v := range chessMap {
		for j, k := range v {
			if k != 0 {
				valNodeFind := ValNode{
					row: i,
					col: j,
					val: k,
				}
				sparseArr = append(sparseArr, valNodeFind)
			}
		}
	}
	//輸出這個數組看看
	for i, valNode := range sparseArr {
		fmt.Printf(&amp;quot;%d: %d %d %d\n&amp;quot;, i, valNode.row, valNode.col, valNode.val)
	}

	//恢復
	var chessMapRe [11][11]int
	for i, v := range sparseArr {
		if i != 0 { //跳過第一row
			chessMapRe[v.row][v.col] = v.val

		}
	}

	//輸出看樣子
	for _, v := range chessMapRe {
		for _, v2 := range v {
			fmt.Printf(&amp;quot;%d\t&amp;quot;, v2)
		}
		fmt.Println()
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-array3/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>約瑟夫問題</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-josephus/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-josephus/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-josephus/ -&lt;h1 id=&#34;約瑟夫問題&#34;&gt;約瑟夫問題&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Boy struct {
	No   int
	Next *Boy //指向下一個小孩的指針
}

func addBoy(num int) *Boy {
	//num表示小孩的個數，*Boy返回第一個小孩的指針
	first := &amp;amp;Boy{}
	temp := &amp;amp;Boy{}
	if num &amp;lt; 1 {
		fmt.Println(&amp;quot;num值錯誤&amp;quot;)
		return first
	}

	for i := 1; i &amp;lt;= num; i++ {
		boy := &amp;amp;Boy{
			No: i,
		}
		if i == 1 {
			first = boy //不變
			temp = boy
			temp.Next = first
		} else {
			temp.Next = boy
			temp = boy
			temp.Next = first //構成環形
		}
	}
	return first
}

func show(first *Boy) {
	if first.Next == nil {
		fmt.Println(&amp;quot;列表為空&amp;quot;)
		return
	}
	temp := first
	for {
		fmt.Printf(&amp;quot;編號%d~&amp;gt;&amp;quot;, temp.No)
		if temp.Next == first {
			break
		}
		temp = temp.Next
	}
}

func play(first *Boy, k int, m int) {
	//從第k人開始報數m出列
	if first.Next == nil {
		fmt.Println(&amp;quot;列表為空&amp;quot;)
		return
	}
	tail := first
	for {
		if tail.Next == first {
			break
		}
		tail = tail.Next
	}
	//讓first移動到k
	for i := 0; i &amp;lt; k-1; i++ {
		first = first.Next
		tail = tail.Next
	}

	//開始數m
	for {
		for i := 1; i &amp;lt;= m-1; i++ {
			first = first.Next
			tail = tail.Next
		}
		fmt.Println(first.No, &amp;quot;出列&amp;quot;)
		first = first.Next
		tail.Next = first

		//退出
		if tail == first {
			break
		}
	}
	fmt.Println(first.No, &amp;quot;為最後一個&amp;quot;)
}
func main() {
	first := addBoy(41)
	show(first)
	fmt.Println()
	play(first, 1, 3)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-josephus/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>迷宮遞迴</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-recursive/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-recursive/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-recursive/ -&lt;h1 id=&#34;迷宮遞迴&#34;&gt;迷宮遞迴&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func SetWay(myMap *[8][7]int, a int, b int) bool {
	//a,b 表示對地圖的那個點測試

	//找到出口
	if myMap[6][5] == 2 {
		return true
	} else {
		//繼續找
		if myMap[a][b] == 0 { //可探測的點
			myMap[a][b] = 2            //踩上去了，再探上下左右，但是我知道要往下往右探
			if SetWay(myMap, a+1, b) { //下
				return true
			} else if SetWay(myMap, a, b+1) { //右
				return true
			} else if SetWay(myMap, a-1, b) { //上
				return true
			} else if SetWay(myMap, a, b-1) { //左
				return true
			} else { //死路
				myMap[a][b] = 3
				return false
			}
		} else { //不可探測的點
			return false
		}
	}
}
func main() {
	//定義地圖 1=牆壁 0=沒走過的點 2=通路 3=走過的死路
	var myMap [8][7]int

	//四周設置圍牆
	for i := 0; i &amp;lt; 7; i++ {
		myMap[0][i] = 1
		myMap[7][i] = 1
	}
	for i := 0; i &amp;lt; 8; i++ {
		myMap[i][0] = 1
		myMap[i][6] = 1
	}
	myMap[3][1] = 1
	myMap[3][2] = 1

	//看樣子
	for i := 0; i &amp;lt; 8; i++ {
		for j := 0; j &amp;lt; 7; j++ {
			fmt.Print(myMap[i][j], &amp;quot; &amp;quot;)
		}
		fmt.Println()
	}

	SetWay(&amp;amp;myMap, 1, 1)
	fmt.Println(&amp;quot;已探完&amp;quot;)

	for i := 0; i &amp;lt; 8; i++ {
		for j := 0; j &amp;lt; 7; j++ {
			fmt.Print(myMap[i][j], &amp;quot; &amp;quot;)
		}
		fmt.Println()
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-recursive/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>雙向鏈表</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-double-chain-list/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-double-chain-list/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-double-chain-list/ -&lt;h1 id=&#34;雙向鏈表&#34;&gt;雙向鏈表&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type HeroNode struct {
	no   int
	name string
	pre  *HeroNode //表示指向前一個節點
	next *HeroNode //表示指向下一個節點
}

//給鏈表插入節點
func Insert(head *HeroNode, newHeroNode *HeroNode) {
	//先找到最後的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		}
		temp = temp.next //不斷往下找
	}
	//把newHeroNode加到屁股
	temp.next = newHeroNode
	newHeroNode.pre = temp
}

//根據No從小到大插入
func InsertNo(head *HeroNode, newHeroNode *HeroNode) {
	//想找到適當的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		} else if temp.next.no &amp;gt; newHeroNode.no {
			//表示new要插到temp後
			break
		} else if temp.next.no == newHeroNode.no {
			//表示new這個編號已存在
			fmt.Println(newHeroNode.no, &amp;quot;該編號已存在&amp;quot;)
			return
		}
		temp = temp.next //不斷往下找

	}
	//把newHeroNode加到找到的地方
	newHeroNode.next = temp.next
	newHeroNode.pre = temp
	if temp.next != nil {
		temp.next.pre = newHeroNode //temp的下一個的前一個=新
	}
	temp.next = newHeroNode
}

//根據no刪除一個節點
func DelHeroNode(head *HeroNode, id int) {
	//想找到適當的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		} else if temp.next.no == id {
			//表示找到了
			fmt.Println(id, &amp;quot;該編號已刪除&amp;quot;)
			temp.next = temp.next.next
			if temp.next != nil {
				temp.next.pre = temp
			}
			return
		}
		temp = temp.next //不斷往下找
	}

}

//顯示
func List(head *HeroNode) {
	//創建一個輔助
	temp := head
	if temp.next == nil { //空鏈表?
		fmt.Println(&amp;quot;空&amp;quot;)
		return
	}
	for {
		fmt.Printf(&amp;quot;[%d,%s]==&amp;gt;&amp;quot;, temp.next.no, temp.next.name)
		temp = temp.next      //不斷往下找
		if temp.next == nil { //到尾了
			fmt.Println(&amp;quot;完畢&amp;quot;)
			break
		}
	}
}

func main() {
	//創建一個頭節點(空的)
	head := &amp;amp;HeroNode{}
	hero1 := &amp;amp;HeroNode{
		no:   1,
		name: &amp;quot;宋江&amp;quot;,
	}
	hero2 := &amp;amp;HeroNode{
		no:   2,
		name: &amp;quot;李奎&amp;quot;,
	}
	hero3 := &amp;amp;HeroNode{
		no:   3,
		name: &amp;quot;李軌&amp;quot;,
	}
	InsertNo(head, hero3)
	InsertNo(head, hero1)
	InsertNo(head, hero2)

	List(head)
	DelHeroNode(head, 3)
	List(head)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-double-chain-list/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>channel通道</title>
        <link>https://yoziming.github.io/post/210810-agg-go-channel/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-channel/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-channel/ -&lt;h1 id=&#34;channel通道&#34;&gt;channel通道&lt;/h1&gt;
&lt;h2 id=&#34;lock-sync與chan基本認識&#34;&gt;lock sync與chan基本認識&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//階乘1-n 把各個數放到map中 用goroutine完成
var (
	myMap = make(map[int]int, 10)
	//聲明一個全局的互斥鎖
	lock sync.Mutex
	//來點管道 記得要make初始化才能用
	intChan chan int = make(chan int, 3)

	//聲明類型為空接口可以接收任意類型
	allChan chan interface{} = make(chan interface{}, 5)
	//注意後面沒聲明容量則不給用
)

type Cat struct {
	Name string
	Age  int
}

func test(n int) {
	res := 1
	for i := 1; i &amp;lt;= n; i++ {
		res = res * i
	}
	//把res放進mayMap
	//加鎖
	lock.Lock()
	myMap[n] = res
	//解鎖
	lock.Unlock()
}

func main() {
	//啟用多個協程
	for i := 1; i &amp;lt;= 1; i++ {
		go test(i)
	}
	//如果不加鎖concurrent map iteration and map write
	lock.Lock()
	for i, v := range myMap {
		fmt.Printf(&amp;quot;map[%d]=%v\n&amp;quot;, i, v)
	}
	lock.Unlock()

	//看看管道
	fmt.Println(intChan)
	//出來是一個地址，表示誰要經過這 (當然本身也有一個地址但不重要)
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))

	//向管道寫入數據
	intChan &amp;lt;- 10
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))
	num1 := 5
	intChan &amp;lt;- num1
	intChan &amp;lt;- 1
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))
	//intChan &amp;lt;- 12 //超過3個太長報錯

	//從管道取數據
	var num2 int = &amp;lt;-intChan
	fmt.Println(num2)
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))
	//先進先出，取完超過一樣報錯
	num3 := &amp;lt;-intChan
	fmt.Println(num3)
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))

	//關於allChan
	allChan &amp;lt;- 10
	allChan &amp;lt;- &amp;quot;ABC&amp;quot;
	cat1 := Cat{&amp;quot;小花&amp;quot;, 3}
	allChan &amp;lt;- cat1
	//可以亂塞一通

	//想拿到第三個元素 先把兩個推出來
	&amp;lt;-allChan
	&amp;lt;-allChan

	newCat := &amp;lt;-allChan //從管道中取出來的cat1
	fmt.Printf(&amp;quot;類型=%T 值=%v\n&amp;quot;, newCat, newCat)
	// fmt.Printf(&amp;quot;%v\n&amp;quot;, newCat.Name) //雖然類型一樣但這樣用不通過
	//必須類型斷言
	a := newCat.(Cat)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, a.Name)

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;只讀或寫&#34;&gt;只讀或寫&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	//chan可以只讀或只寫
	// chan1 chan int //可讀可寫
	var chan2 chan&amp;lt;- int = make(chan int, 3) //只寫
	chan2 &amp;lt;- 20
	// num:=&amp;lt;-chan2//報錯
	fmt.Println(chan2)

	var chan3 &amp;lt;-chan int = make(chan int, 3)
	num2 := &amp;lt;-chan3
	fmt.Println(num2)
	chan3 &amp;lt;- 10 //報錯
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;遍歷chan&#34;&gt;遍歷chan&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	//用close關掉channel就不能往內加(但是可以拿出)
	var intChan chan int = make(chan int, 3)
	intChan &amp;lt;- 100
	intChan &amp;lt;- 200
	close(intChan)
	// intChan &amp;lt;- 300 //錯誤
	n1 := &amp;lt;-intChan
	fmt.Println(n1)

	//遍歷
	intChan2 := make(chan int, 100)
	for i := 0; i &amp;lt; 100; i++ {
		intChan2 &amp;lt;- i * 2 //放100個數據(2,4,6...進去)
	}
	//得用for:=range用一般for遍歷會報錯
	//如果已經close遍歷完就會自動停止，如果沒有先關掉會deadlock
	close(intChan2)
	for v := range intChan2 {
		fmt.Println(v)
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;阻塞&#34;&gt;阻塞&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func writeData(intChan chan int) {
	for i := 1; i &amp;lt;= 50; i++ {
		intChan &amp;lt;- i
		fmt.Printf(&amp;quot;writeData=%v\n&amp;quot;, i)
		// time.Sleep(time.Second / 1000)
	}
	close(intChan) //寫完就關
}
func readData(intChan chan int, exitChan chan bool) {
	for {
		v, ok := &amp;lt;-intChan
		// time.Sleep(time.Second / 1000)
		if !ok {
			break
		}
		fmt.Printf(&amp;quot;readData讀取到數據=%v\n&amp;quot;, v)
	}
	//讀取完=任務完成 其實這裡不管對exitChan做啥都無所謂，重點是有調用他就能阻塞main
	exitChan &amp;lt;- true
	close(exitChan)
}

func main() {

	intChan := make(chan int, 5)
	//即使管道小 寫的慢讀得快或相反，他會排隊，重點不要阻塞死鎖就能繼續
	exitChan := make(chan bool, 1)

	go writeData(intChan)
	go readData(intChan, exitChan)
	if &amp;lt;-exitChan { //重點就是這個判斷調用到一個管道有跨到子函數的就能阻塞住main
		fmt.Println(&amp;quot;任務完成&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;用select解決阻塞&#34;&gt;用select解決阻塞&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func sayH() {
	for i := 0; i &amp;lt; 10; i++ {
		time.Sleep(time.Second / 10)
		fmt.Println(&amp;quot;hello&amp;quot;)
	}
}

func test() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(&amp;quot;test錯誤&amp;quot;, err)
		}
	}()
	myMap := make(map[int]string)
	myMap[0] = &amp;quot;我家&amp;quot;
	fmt.Println(myMap)
}

func main() {

	go sayH()
	go test()
	fmt.Println(&amp;quot;hellom&amp;quot;)

	intChan := make(chan int, 10)
	for i := 0; i &amp;lt; 10; i++ {
		intChan &amp;lt;- i
	}

	stringChan := make(chan string, 5)
	for i := 0; i &amp;lt; 5; i++ {
		stringChan &amp;lt;- &amp;quot;hello&amp;quot; + fmt.Sprintf(&amp;quot;%d&amp;quot;, i)
	}
	//傳統方法遍歷，如果不關閉會阻塞 就導致deadlock
	//實際開發不好確定哪時候關閉，就用select解決
	for {
		select {
		//就算沒關閉，只要阻塞他就往其他case移動
		case v := &amp;lt;-intChan:
			fmt.Printf(&amp;quot;intChan取出%d\n&amp;quot;, v)
		case v := &amp;lt;-stringChan:
			fmt.Printf(&amp;quot;stringChan取出%s\n&amp;quot;, v)
		default:
			fmt.Println(&amp;quot;取完了&amp;quot;)
			return
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-channel/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>const常量</title>
        <link>https://yoziming.github.io/post/210810-agg-go-const/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-const/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-const/ -&lt;h1 id=&#34;const常量&#34;&gt;const常量&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;常量 聲明時必須賦值、不能修改、只能是bool、數值、string，賦值需是一個確定的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	const tax int = 10
	const x = 9 / 3
	// const c = 9 / a //因為a可能是一個變量所以這樣不行
	// var a int = 3
	fmt.Println(tax, x)

	const (
		a = iota //表示a=0
		b        //b=a+1
		c        //c=b+1
	)
	fmt.Println(a, b, c)

	const (
		d = iota
		e
		f, g = iota, iota
	)
	fmt.Println(d, e, f, g)

	//其他程式語言常量會用全大寫，go中沒限制，且一樣用首字母大小來控制使用範圍
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-const/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>defer臨走前啟用</title>
        <link>https://yoziming.github.io/post/210810-agg-go-defer/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-defer/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-defer/ -&lt;h1 id=&#34;defer臨走前啟用&#34;&gt;defer臨走前啟用&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;退出函數前才執行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func sum(n1, n2 int) int {
	defer fmt.Println(&amp;quot;ok1&amp;quot;, n1)
	defer fmt.Println(&amp;quot;ok2&amp;quot;, n2)
	//defer棧先入後出
	n1++
	n2++
	res := n1 + n2
	fmt.Println(&amp;quot;ok3 res=&amp;quot;, res)
	return res

}
func main() {
	res := sum(10, 20)
	fmt.Println(&amp;quot;res=&amp;quot;, res)

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-defer/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>goroutine</title>
        <link>https://yoziming.github.io/post/210810-agg-go-goroutine/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-goroutine/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-goroutine/ -&lt;h1 id=&#34;goroutine&#34;&gt;goroutine&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;進程=程序在操作系統中的一次進行過程&lt;/p&gt;
&lt;p&gt;線程=執行實例的最小單位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一個進程可以創建多個線程且併發執行&lt;/li&gt;
&lt;li&gt;一個程序至少包含一個進程，一個進程至少包含一個線程&lt;/li&gt;
&lt;li&gt;併發=多線程程序在單核上運行&lt;/li&gt;
&lt;li&gt;併行=多線程程序在多核上運行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GO的主線程(可以理解為進程)，一個GO進程上可以起很多協程，協程可以理解為輕量級的線程，協程特點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有獨立的棧空間&lt;/li&gt;
&lt;li&gt;共享程序堆空間&lt;/li&gt;
&lt;li&gt;調度由用戶控制&lt;/li&gt;
&lt;li&gt;為輕量級的線程&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func test() {
	for i := 0; i &amp;lt; 10; i++ {
		fmt.Println(&amp;quot;test()Hello,world&amp;quot; + strconv.Itoa(i))
		time.Sleep(time.Second / 10)
	}
}

func main() {
	go test() //開啟一個協程
	//如果主線程退出了，即使協程還沒執行完，也會退出
	//協程可以自己先結束
	for i := 0; i &amp;lt; 10; i++ {
		fmt.Println(&amp;quot;main()Hello,go&amp;quot; + strconv.Itoa(i))
		time.Sleep(time.Second / 10)
	}
	go test() //開啟一個協程，主線程退出了，即使協程還沒執行完，也會退出

	//查邏輯CPU數量
	cpuNum := runtime.NumCPU()
	fmt.Println(cpuNum)
	//設置最大線程數量
	runtime.GOMAXPROCS(cpuNum)

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-goroutine/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Go使用mysql與事務操作</title>
        <link>https://yoziming.github.io/post/210810-agg-go-mysql/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-mysql/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-mysql/ -&lt;h1 id=&#34;go使用mysql與事務操作&#34;&gt;Go使用mysql與事務操作&lt;/h1&gt;
&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;fmt&amp;quot;

	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

var db *sql.DB // 是一個連接池對象

// user 接收數據
type user struct {
	id   int
	name string
	age  int
}

func initDB() (err error) {
	dsn := &amp;quot;root:root@tcp(127.0.0.1:3306)/sql_test&amp;quot;
	db, err = sql.Open(&amp;quot;mysql&amp;quot;, dsn) // 這個db要用全局的，重要!
	if err != nil {
		return
	}
	err = db.Ping()
	if err != nil {
		return
	} else {
		fmt.Println(&amp;quot;連接成功&amp;quot;)
	}
	return
}

// 查詢一個
func find1() {
	var u1 user
	sqlStr := `select id, name, age from user where id=?;`
	rowObj := db.QueryRow(sqlStr, 1)
	err := rowObj.Scan(&amp;amp;u1.id, &amp;amp;u1.name, &amp;amp;u1.age)
	if err != nil {
		fmt.Println(&amp;quot;Scan failed!&amp;quot;, err)
		return
	}
	fmt.Println(u1)
}

// findMore 查詢多個
func findMore() {
	sqlStr := `select id, name, age from user where id &amp;gt; ?;`
	rows, _ := db.Query(sqlStr, 0)
	defer rows.Close()

	for rows.Next() {
		var u user
		err := rows.Scan(&amp;amp;u.id, &amp;amp;u.name, &amp;amp;u.age)
		if err != nil {
			return
		}
		fmt.Println(u)
	}
}

func update(newAge int, id int) {
	sqlStr := &amp;quot;update user set age=? where id = ?&amp;quot;
	ret, err := db.Exec(sqlStr, newAge, id)
	if err != nil {
		fmt.Println(err)
		return
	}
	n, err := ret.RowsAffected()
	if err != nil {
		return
	}
	fmt.Println(&amp;quot;更新了&amp;quot;, n, &amp;quot;行數據&amp;quot;)
}

func delete(id int) {
	sqlStr := &amp;quot;delete from user where id = ?&amp;quot;
	ret, err := db.Exec(sqlStr, id)
	if err != nil {
		fmt.Println(err)
		return
	}
	n, err := ret.RowsAffected()
	if err != nil {
		return
	}
	fmt.Println(&amp;quot;更新了&amp;quot;, n, &amp;quot;行數據&amp;quot;)
}

func main() {
	err := initDB()
	if err != nil {
		fmt.Println(&amp;quot;init DB failed&amp;quot;, err)
	}

	preInsert()
	// findMore()
	// update(90, 2)
	// delete(2)
	findMore()
}

func insert() {
	sqlStr := `insert into user(name, age) values(&amp;quot;AAC&amp;quot;, 18)`
	ret, err := db.Exec(sqlStr)
	if err != nil {
		fmt.Println(&amp;quot;insert failed!&amp;quot;, err)
		return
	}
	// 插入後能拿到對應的ID
	id, _ := ret.LastInsertId()
	fmt.Println(&amp;quot;id=&amp;quot;, id)
}

func preInsert() {
	sqlStr := &amp;quot;insert into user(name, age) values(?,?)&amp;quot;
	stmt, err := db.Prepare(sqlStr)
	if err != nil {
		return
	}
	defer stmt.Close()
	for i := 1; i &amp;lt; 10; i++ {
		_, _ = stmt.Exec(&amp;quot;人物&amp;quot;, i)

	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;mysql事務操作&#34;&gt;mysql事務操作&lt;/h3&gt;
&lt;p&gt;事務：一個最小的不可再分的工作單元；通常一個事務對應一個完整的業務(例如銀行帳戶轉帳業務，該業務就是一個最小的工作單元)，同時這個完整的業務需要執行多次的DML(insert、update、delete)語句共同聯合完成。A轉帳給B，這裡面就需要執行兩次update操作。在MySQL中只有使用了Innodb資料庫引擎的資料庫或表才支援事務。交易處理可以用來維護資料庫的完整性，保證成批的SQL語句要麼全部執行，要麼全部不執行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事務的ACID&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常事務必須滿足4個條件（ACID）：原子性（Atomicity，或稱不可分割性）、一致性（Consistency）、隔離性（Isolation，又稱獨立性）、持久性（Durability）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原子性 一個事務（transaction）中的所有操作，要麼全部完成，要麼全部不完成，不會結束在中間某個環節。事務在執行過程中發生錯誤，會被回滾（Rollback）到事務開始前的狀態，就像這個事務從來沒有執行過一樣。&lt;/li&gt;
&lt;li&gt;一致性 在事務開始之前和事務結束以後，資料庫的完整性沒有被破壞。這表示寫入的資料必須完全符合所有的預設規則，這包含資料的精確度、串聯性以及後續資料庫可以自發性地完成預定的工作。&lt;/li&gt;
&lt;li&gt;隔離性 資料庫允許多個併發事務同時對其資料進行讀寫和修改的能力，隔離性可以防止多個事務併發執行時由於交叉執行而導致資料的不一致。事務隔離分為不同級別，包括讀未提交（Read uncommitted）、讀提交（read committed）、可重複讀（repeatable read）和序列化（Serializable）。&lt;/li&gt;
&lt;li&gt;持久性 交易處理結束後，對資料的修改就是永久的，即便系統故障也不會丟失。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;fmt&amp;quot;

	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

var db *sql.DB // 是一個連接池對象

// user 接收數據
type user struct {
	id   int
	name string
	age  int
}

func initDB() (err error) {
	dsn := &amp;quot;root:root@tcp(127.0.0.1:3306)/sql_test&amp;quot;
	db, err = sql.Open(&amp;quot;mysql&amp;quot;, dsn) // 這個db要用全局的，重要!
	if err != nil {
		return
	}
	err = db.Ping()
	if err != nil {
		return
	} else {
		fmt.Println(&amp;quot;連接成功&amp;quot;)
	}
	return
}

func transaction() {
	tx, err := db.Begin()
	if err != nil {
		fmt.Println(&amp;quot;begin failed!&amp;quot;, err)
		return
	}

	sqlStr1 := &amp;quot;update user set age=age-2 where id=1&amp;quot;
	sqlStr2 := &amp;quot;update user set age=age+2 where id=3&amp;quot;
	ret1, err := tx.Exec(sqlStr1)
	if err != nil {
		tx.Rollback()
		return
	}
	affRow1, err := ret1.RowsAffected()
	if err != nil {
		tx.Rollback()
		return
	}
	ret2, err := tx.Exec(sqlStr2)
	if err != nil {
		tx.Rollback()
		return
	}
	affRow2, err := ret2.RowsAffected()
	if err != nil {
		tx.Rollback()
		return
	}
	fmt.Println(affRow1, affRow2)
	if affRow1 == 1 &amp;amp;&amp;amp; affRow2 == 1 {
		tx.Commit()
		fmt.Println(&amp;quot;已提交&amp;quot;)
	} else {
		tx.Rollback()
	}

}

func findMore() {
	sqlStr := `select id, name, age from user where id &amp;gt; ?;`
	rows, _ := db.Query(sqlStr, 0)
	defer rows.Close()

	for rows.Next() {
		var u user
		err := rows.Scan(&amp;amp;u.id, &amp;amp;u.name, &amp;amp;u.age)
		if err != nil {
			return
		}
		fmt.Println(u)
	}
}

func main() {

	initDB()
	findMore()
	transaction()
	findMore()
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-mysql/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>JSON序列化</title>
        <link>https://yoziming.github.io/post/210810-agg-go-json/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-json/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-json/ -&lt;h1 id=&#34;json序列化&#34;&gt;JSON序列化&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;JSON 格式 {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;}  {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:&amp;ldquo;值2&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:[&amp;ldquo;值2數組&amp;rdquo;,值2數組]}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Monster struct {
	Name string  `json:&amp;quot;name&amp;quot;` //反射機制
	Age  int     `json:&amp;quot;age&amp;quot;`
	Sal  float64 `json:&amp;quot;sal&amp;quot;`
}

func test1() {
	monster1 := Monster{
		Name: &amp;quot;牛魔王&amp;quot;,
		Age:  50,
		Sal:  8000.0,
	}
	data, err := json.Marshal(&amp;amp;monster1)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(data))
}

//把map序列化
func testMap() {
	var mapA map[string]interface{} = make(map[string]interface{})
	mapA[&amp;quot;name&amp;quot;] = &amp;quot;紅孩兒&amp;quot;
	mapA[&amp;quot;age&amp;quot;] = 18
	data, err := json.Marshal(&amp;amp;mapA)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(data))

}

//切片序列化
func testSlice() {
	var slice1 []map[string]interface{}
	var m1 map[string]interface{} = make(map[string]interface{})
	m1[&amp;quot;name&amp;quot;] = &amp;quot;珍娜&amp;quot;
	m1[&amp;quot;age&amp;quot;] = 40
	slice1 = append(slice1, m1)
	var m2 map[string]interface{} = make(map[string]interface{})
	m2[&amp;quot;name&amp;quot;] = &amp;quot;索爾&amp;quot;
	m2[&amp;quot;age&amp;quot;] = 25
	slice1 = append(slice1, m2)
	data, err := json.Marshal(slice1)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(data))

}

//基本數據類型序列化，沒啥意義 因為他沒有key 就只會轉出一個string
func testFloat64() {
	var num1 float64 = 123.45
	data, err := json.Marshal(num1)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(data))

}

//反序列化
func unmarshal() {
	str := `{&amp;quot;name&amp;quot;:&amp;quot;牛魔王&amp;quot;,&amp;quot;age&amp;quot;:50,&amp;quot;sal&amp;quot;:8000}`
	//用`...`包起來保留原格式

	//定義一個實例來接收 這個接收的格式一定要能符合對應
	var heroes Monster
	err := json.Unmarshal([]byte(str), &amp;amp;heroes)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(heroes)
}
func unmarshalMap() {
	str := `{&amp;quot;age&amp;quot;:18,&amp;quot;name&amp;quot;:&amp;quot;紅孩兒&amp;quot;}`
	var a map[string]interface{}
	//不用make因為unmarshal函數內封裝了
	err := json.Unmarshal([]byte(str), &amp;amp;a)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(a)
}

func main() {
	test1()
	testMap()
	testSlice()
	testFloat64()
	unmarshal()
	unmarshalMap()
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-json/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Map集合</title>
        <link>https://yoziming.github.io/post/210810-agg-go-map/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-map/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-map/ -&lt;h1 id=&#34;map集合&#34;&gt;Map集合&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	// map[key類型] value類型
	var m1 map[int]int = make(map[int]int)

	//key類型通常是int or string
	//value 通常是數字 or string or map or struct
	//只聲明不會給內存，要make才初始化才能用(跟切片一樣)
	m1[1] = 100
	m1[2] = 200
	m1[3] = 300
	m1[1] = 1000
	//key不能重複，後賦予的頂掉前面
	fmt.Println(m1)

	var m2 = make(map[string]string)
	m2[&amp;quot;AV&amp;quot;] = &amp;quot;sss&amp;quot;
	fmt.Println(m2)

	//推薦寫法
	m3 := make(map[string]string)
	m3[&amp;quot;一號&amp;quot;] = &amp;quot;台北&amp;quot;
	m3[&amp;quot;二奧&amp;quot;] = &amp;quot;桃園&amp;quot;
	fmt.Println(m3)

	m4 := map[int]int{1: 10, 2: 20, 3: 30}
	fmt.Println(m4)

	//學生姓名+性別
	m5 := make(map[string](map[string]string))
	m5[&amp;quot;stu01&amp;quot;] = make(map[string]string) //不能少
	m5[&amp;quot;stu01&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;tom&amp;quot;
	m5[&amp;quot;stu01&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;男&amp;quot;
	m5[&amp;quot;stu02&amp;quot;] = make(map[string]string) //不能少
	m5[&amp;quot;stu02&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;mary&amp;quot;
	m5[&amp;quot;stu02&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;女&amp;quot;
	fmt.Println(m5)
	fmt.Println(m5[&amp;quot;stu01&amp;quot;])
	fmt.Println(m5[&amp;quot;stu01&amp;quot;][&amp;quot;sex&amp;quot;])

	var m6 = make(map[int]int)
	m6[1] = 10
	m6[2] = 20
	delete(m6, 1) //delete=刪除key
	delete(m6, 3) //delete空的東西也不會報錯
	//沒有辦法把key全刪除，要就用遍歷
	fmt.Println(m6)
	//重新分配一次=清空，但是格式要跟本來一樣
	m6 = make(map[int]int)
	fmt.Println(m6)

	//查找
	var m7 = make(map[int]int)
	m7[1] = 111
	m7[2] = 222
	val, ok := m7[2] //把一個map中的一個key賦給a,b 其中a=value b=bool(是否存在)
	fmt.Println(val, ok)
	if ok {
		fmt.Printf(&amp;quot;m7存在key&#39;1&#39;且值為%v\n&amp;quot;, val)
	} else {
		fmt.Printf(&amp;quot;m7不存在key&#39;n&#39;\n&amp;quot;)
	}

	//遍歷
	//因為map裡面的key-value不一定是連續的數字，所以不能用for而要用for:=range
	//m5 := make(map[string](map[string]string))

	for k, v := range m5 {
		fmt.Printf(&amp;quot;k=%v \n&amp;quot;, k)
		for k2, v2 := range v {
			fmt.Printf(&amp;quot;	k2=%v v=%v \n&amp;quot;, k2, v2)
		}

	}

	//長度=有幾對
	m8 := map[int]int{1: 10, 2: 20, 3: 30}
	fmt.Println(len(m8))

	//map切片
	//使用一個map來記錄monster的name跟age，且monster數量可以動態變化

	var mon []map[string]string = make([]map[string]string, 2)
	if mon[0] == nil {
		mon[0] = make(map[string]string, 2)
		mon[0][&amp;quot;name&amp;quot;] = &amp;quot;牛魔王&amp;quot;
		mon[0][&amp;quot;age&amp;quot;] = &amp;quot;500&amp;quot;
	}
	if mon[1] == nil {
		mon[1] = make(map[string]string, 2)
		mon[1][&amp;quot;name&amp;quot;] = &amp;quot;玉兔&amp;quot;
		mon[1][&amp;quot;age&amp;quot;] = &amp;quot;300&amp;quot;
	}

	// if mon[2] == nil {
	// 	mon[2] = make(map[string]string, 2)
	// 	mon[2][&amp;quot;name&amp;quot;] = &amp;quot;111&amp;quot;
	// 	mon[2][&amp;quot;age&amp;quot;] = &amp;quot;3440&amp;quot;
	// } //這樣寫越界
	//用append 先定義monster信息
	newMon := map[string]string{
		&amp;quot;name&amp;quot;: &amp;quot;新妖怪&amp;quot;,
		&amp;quot;age&amp;quot;:  &amp;quot;200&amp;quot;,
	}
	mon = append(mon, newMon)

	fmt.Println(mon)

	//用結構體更好，例如學號是唯一
	type Stu struct {
		Name    string
		Age     int
		Address string
	}
	stumaps := make(map[string]Stu)
	//創建學生
	stu1 := Stu{&amp;quot;tom&amp;quot;, 18, &amp;quot;經&amp;quot;}
	stu2 := Stu{&amp;quot;mary&amp;quot;, 50, &amp;quot;KJH&amp;quot;}
	stumaps[&amp;quot;no1&amp;quot;] = stu1
	stumaps[&amp;quot;no2&amp;quot;] = stu2
	fmt.Println(stumaps)
	//遍歷
	for k, v := range stumaps {
		fmt.Printf(&amp;quot;學號=%v\n&amp;quot;, k)
		fmt.Printf(&amp;quot;	姓名=%v\n&amp;quot;, v.Name)
		fmt.Printf(&amp;quot;	年紀=%v\n&amp;quot;, v.Age)
		fmt.Printf(&amp;quot;	住址=%v\n&amp;quot;, v.Address)
	}

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-map/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>new與make的區別</title>
        <link>https://yoziming.github.io/post/210810-agg-go-new-make/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-new-make/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-new-make/ -&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	num1 := 100
	fmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num1, num1, &amp;amp;num1)
	num2 := new(int) //*int
	fmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num2, num2, &amp;amp;num2)

	//new用來分配類型
	//make用來分配內存
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-new-make/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Redis基本操作</title>
        <link>https://yoziming.github.io/post/210810-agg-go-redis/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-redis/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-redis/ -&lt;h1 id=&#34;redis基本操作&#34;&gt;Redis基本操作&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地在cmd輸入&lt;code&gt;redis-cli&lt;/code&gt;啟動操作用戶端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遠端連接:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ redis-cli -h host -p port -a password

// 範例
$ redis-cli -h 127.0.0.1 -p 6379 -a &amp;quot;mypass&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PING&lt;/code&gt;測試連接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;數據&#34;&gt;數據&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;數據結構類似JSON都是Key-Value&lt;/li&gt;
&lt;li&gt;五大數據類型String、Hash、List、Set、Zset&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最基本的字串，value最大值=512M&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;set(如果存在就相當於修改)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;del (很多指令可以用tab協助完成)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setex(幾秒後自毀)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hash&#34;&gt;Hash&lt;/h3&gt;
&lt;p&gt;指令:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HSET key field value
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hget、hdel&lt;/p&gt;
&lt;p&gt;一次設多項(空格隔開)hmset、hmget&lt;/p&gt;
&lt;p&gt;hlen:統計有幾個元素&lt;/p&gt;
&lt;p&gt;hexists:看field是否存在&lt;/p&gt;
&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;
&lt;p&gt;是個有序的鏈表，元素的值可以重複，可以把東西加在頭或尾&lt;/p&gt;
&lt;p&gt;指令:lpush 從左往管子裡塞東西，一直推擠過去&lt;/p&gt;
&lt;p&gt;lrange 0 end (最左是0 1 2 3&amp;hellip;，也可以用負數 -1表示最後一個 -2表示倒數第2&lt;/p&gt;
&lt;p&gt;比如說lrange 0 -1 =從左開始全顯示&lt;/p&gt;
&lt;p&gt;rpush 從右邊加東西 (就順序上來說比較習慣)&lt;/p&gt;
&lt;p&gt;lpop / rpop 從左或右取出數據(彈走了)&lt;/p&gt;
&lt;p&gt;del key 刪掉就沒了&lt;/p&gt;
&lt;p&gt;lindex 按照索引下標獲得元素(從左到右0開始)&lt;/p&gt;
&lt;p&gt;llen 長度&lt;/p&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;p&gt;String類型的無序集合(元素的值不能重複)&lt;/p&gt;
&lt;p&gt;舉例 存放email不該重複 (重複加了無效)&lt;/p&gt;
&lt;p&gt;指令saad&lt;/p&gt;
&lt;p&gt;smembers 印出所有值&lt;/p&gt;
&lt;p&gt;sismember 判斷值是否成員&lt;/p&gt;
&lt;p&gt;srem 刪除指定值&lt;/p&gt;
- https://yoziming.github.io/post/210810-agg-go-redis/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Reflect反射</title>
        <link>https://yoziming.github.io/post/210810-agg-go-reflect/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-reflect/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-reflect/ -&lt;h1 id=&#34;reflect反射&#34;&gt;reflect反射&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func reflectTest01(b interface{}) {
	//通過反射獲取傳入的各種訊息
	//先拿reflect.Type
	rType := reflect.TypeOf(b)
	fmt.Println(&amp;quot;rType=&amp;quot;, rType)

	rVal := reflect.ValueOf(b)
	fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)
	// n1:=10+rVal //rVal他看起來是int但其實是type reflect.Value
	n1 := 10 + rVal.Int() //用.Int()轉換後就可以了
	// n3 := rVal.Float()//像這樣也不行的，一定要確認類型
	fmt.Println(&amp;quot;n1=&amp;quot;, n1)
	// fmt.Println(&amp;quot;n3=&amp;quot;, n3)

	//把rVal轉回interface{}
	iV := rVal.Interface()
	n2 := iV.(int)
	fmt.Println(&amp;quot;n2=&amp;quot;, n2)
}

func reflectTest02(b interface{}) {
	//通過反射獲取傳入的各種訊息
	//先拿reflect.Type
	rType := reflect.TypeOf(b)
	fmt.Println(&amp;quot;rType=&amp;quot;, rType)

	rVal := reflect.ValueOf(b)
	fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)

	//把rVal轉回interface{}
	iV := rVal.Interface()
	//斷言回來
	n2, ok := iV.(Student)
	if !ok {
		fmt.Println(&amp;quot;從interface{}轉換回Student失敗&amp;quot;)
	}
	fmt.Println(&amp;quot;n2=&amp;quot;, n2)
	fmt.Println(&amp;quot;n2.Name=&amp;quot;, n2.Name)

	//獲取變量對應的kind，可以從Type也能從val拿。
	//比如這個type是包名.Student，kind是stuct，可以說定義上kind包含type
	fmt.Println(&amp;quot;kind=&amp;quot;, rType.Kind())
	fmt.Println(&amp;quot;kind=&amp;quot;, rVal.Kind())

}

type Student struct {
	Name string
	Age  int
}

func main() {
	var num int = 100
	reflectTest01(num)
	fmt.Println(&amp;quot;===============================&amp;quot;)
	stu := Student{
		Name: &amp;quot;tom&amp;quot;,
		Age:  20,
	}
	reflectTest02(stu)

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;修改變量&#34;&gt;修改變量&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func reflect01(b interface{}) {
	rVal := reflect.ValueOf(b)
	fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)
	rType := reflect.TypeOf(b)
	fmt.Println(&amp;quot;rType=&amp;quot;, rType)

	iV := rVal.Interface()
	vNew, ok := iV.(float64)
	if ok {
		fmt.Println(&amp;quot;轉換成功 vNew=&amp;quot;, vNew)
	} else {
		fmt.Println(&amp;quot;err&amp;quot;)
	}
}
func main() {
	var v float64 = 1.2
	reflect01(v)

	// var str string = &amp;quot;tom&amp;quot;  //錯誤示範
	// fs := reflect.ValueOf(str)
	// fs.SetString(&amp;quot;jack&amp;quot;)
	// fmt.Println(str)

	var str string = &amp;quot;tom&amp;quot;
	fs := reflect.ValueOf(&amp;amp;str)
	fs.Elem().SetString(&amp;quot;jack&amp;quot;)
	fmt.Println(str)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;實踐&#34;&gt;實踐&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Monster struct {
	Name  string `json:&amp;quot;name&amp;quot;`
	Age   int    `json:&amp;quot;age&amp;quot;`
	Score float64
}

//方法打印m值
func (m Monster) Print() {
	fmt.Println(m)
}

//方法 求2和
func (m Monster) GetSum(n1, n2 int) int {
	return n1 + n2
}

//方法 接收4值給Monster
func (m Monster) Set(n string, a int, s float64) {
	m.Name = n
	m.Age = a
	m.Score = s
}

//反射實例
func TestStruct(a interface{}) {
	typ := reflect.TypeOf(a)
	val := reflect.ValueOf(a)
	kd := val.Kind()
	if kd != reflect.Struct {
		fmt.Println(&amp;quot;傳入的不是結構體&amp;quot;)
		return
	}
	//獲取該結構有幾字段
	num := val.NumField()
	fmt.Println(&amp;quot;struct有幾個字段=&amp;quot;, num)

	//遍歷所有字段
	for i := 0; i &amp;lt; num; i++ {
		fmt.Printf(&amp;quot;Field%d 值為%v\n&amp;quot;, i, val.Field(i))
		//獲取struct標籤
		tagVal := typ.Field(i).Tag.Get(&amp;quot;json&amp;quot;)
		if tagVal != &amp;quot;&amp;quot; {
			fmt.Printf(&amp;quot;Field%d tag為%v\n&amp;quot;, i, tagVal)
		}
	}
	//獲取結構體有幾個方法
	numOfMethod := val.NumMethod()
	fmt.Println(&amp;quot;方法有&amp;quot;, numOfMethod)
	//調用第[]個方法且call調用他(傳入參數值)
	//但他這個是方法的首字(asc碼)當排序的 我們的方法是G P S開頭 (1)=第2個
	val.Method(1).Call(nil)
	//試著調用getsum 他call傳入的是要[]reflect.Value
	var params []reflect.Value
	params = append(params, reflect.ValueOf(10))
	params = append(params, reflect.ValueOf(20))
	res := val.MethodByName(&amp;quot;GetSum&amp;quot;).Call(params)
	fmt.Println(&amp;quot;res=&amp;quot;, res[0].Int())
}

func main() {

	var a Monster = Monster{
		Name:  &amp;quot;牛梅王&amp;quot;,
		Age:   500,
		Score: 87,
	}
	TestStruct(a)

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-reflect/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>RPC</title>
        <link>https://yoziming.github.io/post/210927-rpc/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210927-rpc/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210927-rpc/ -&lt;h3 id=&#34;server&#34;&gt;server&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/ 用接口，讓服務端註冊RPC的時候，就能確保他合法

type World struct{}

func (w *World) HelloWorld(name string, resp *string) error {
	*resp = name + &amp;quot;你好&amp;quot;
	return nil
	// 如果這個return的返回值不為空，
	// 那無論傳出的參數是否有值，服務端都不會給東西
	// (就你給你error)
}

// 用接口，讓服務端註冊RPC的時候，就能確保他合法
type MyInerface interface {
	HelloWorld(string *string) error
}

// 調用方法時，給i傳參，參數是實現HelloWorld方法的對象
func RegsiterService(i MyInerface) {
	rpc.RegisterName(&amp;quot;hello&amp;quot;, i)
}
func main() {
	// 1.註冊RPC服務 綁定對象方法
	err := rpc.RegisterName(&amp;quot;hello&amp;quot;, new(World))
	if err != nil {
		fmt.Println(&amp;quot;註冊RPC服務失敗&amp;quot;, err)
	}

	// 2.開始監聽
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8899&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;listener failed&amp;quot;, err)
		return
	}
	fmt.Println(&amp;quot;server開始監聽...&amp;quot;)
	defer listener.Close()
	// 3.建立連接
	conn, err := listener.Accept()
	if err != nil {
		fmt.Println(&amp;quot;Accept failed&amp;quot;, err)
		return
	}
	fmt.Println(&amp;quot;連接成功&amp;quot;)
	defer conn.Close()
	// 4.綁訂服務
	jsonrpc.ServeConn(conn)
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;client&#34;&gt;client&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/rpc&amp;quot;
	&amp;quot;net/rpc/jsonrpc&amp;quot;
)

func main01() {
	// 1.用RPC連接伺服器
	// conn, err := rpc.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8899&amp;quot;)
	conn, err := jsonrpc.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8899&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;Accept failed&amp;quot;, err)
		return
	}
	defer conn.Close()
	// 2.遠程調用函數
	var reply = &amp;quot;&amp;quot;
	err = conn.Call(&amp;quot;hello.HelloWorld&amp;quot;, &amp;quot;張三&amp;quot;, &amp;amp;reply)
	if err != nil {
		fmt.Println(&amp;quot;Call failed&amp;quot;, err)
		return
	}
	fmt.Println(reply)
}

func main() {
	// myClient := InitClient(&amp;quot;127.0.0.1:8899&amp;quot;)
	// var resp string
	// err := myClient.HelloWorld(&amp;quot;李四&amp;quot;, &amp;amp;resp)
	// if err != nil {
	// 	fmt.Println(&amp;quot;HelloWorld failed&amp;quot;, err)
	// 	return
	// }
	// fmt.Println(resp, err)
}

type MyClient struct {
	c *rpc.Client
}

// 把c初始化下面才能調用
// func InitClient(addr string) {
// 	conn, _ := jsonrpc.Dial(&amp;quot;tcp&amp;quot;, addr)
// 	return MyClient{c: conn}
// }

func (m *MyClient) HelloWorld(a string, b *string) error {
	return m.c.Call(&amp;quot;hello.HelloWorld&amp;quot;, a, b)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210927-rpc/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Split切分字串</title>
        <link>https://yoziming.github.io/post/210810-agg-go-split/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-split/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-split/ -&lt;h1 id=&#34;split切分字串&#34;&gt;Split切分字串&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// abc,b=&amp;gt;[a c]
func Split(str, sep string) []string {
	// str=&amp;quot;bsfcvjkhbafs&amp;quot; sep=&amp;quot;b&amp;quot;
	var ret = make([]string, 0, strings.Count(str, sep)+1)
	index := strings.Index(str, sep)
	for index &amp;gt;= 0 {
		ret = append(ret, str[:index])
		str = str[index+len(sep):]
		index = strings.Index(str, sep)
	}
	ret = append(ret, str)
	return ret
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-split/ - Yoziming</description>
        </item>
    
    
    
        <item>
        <title>Test單元測試</title>
        <link>https://yoziming.github.io/post/210810-agg-go-test/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-test/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-test/ -&lt;h1 id=&#34;test單元測試&#34;&gt;Test單元測試&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;單元測試目的是驗證程式碼(例如一個方法)本身的邏輯是否正確&lt;/li&gt;
&lt;li&gt;單元測試應排除外部依賴（Database、File System IO）&lt;/li&gt;
&lt;li&gt;單元測試應該是隨時隨地都要能正確執行&lt;/li&gt;
&lt;li&gt;單元測試的標題需要具備好的可讀性、明確、標題與測試的內容精確吻合
例：「public void GetTest_帶入會員ID＿應回該ID搜尋到的會員資料DTO」，盡量符合：受測方法＿傳入參數意義＿期望得到的結果&lt;/li&gt;
&lt;li&gt;一個測試只應該關注一件事情，如果受測目標有多種狀況，應該分成好幾個測試去涵蓋所有邏輯&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;3A原則&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Arrange = 準備受測物件、參數、預期結果&lt;/li&gt;
&lt;li&gt;Act = 執行受測方法&lt;/li&gt;
&lt;li&gt;Assert = 驗證執行結果與預測結果是否一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;calgo&#34;&gt;cal.go&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func addUpper(n int) int {
	res := 0
	for i := 0; i &amp;lt;= n; i++ {
		res = +i
	}
	return res
}

func getSub(n1, n2 int) int {
	return n1 - n2
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;cal_testgo&#34;&gt;cal_test.go&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestAddUpper(t *testing.T) {
	//調用
	res := addUpper(10)
	if res != 55 {
		t.Fatalf(&amp;quot;AddUpper(10)執行錯誤 期望=%v 實際=%v&amp;quot;, 55, res)
	}
	t.Logf(&amp;quot;執行正確&amp;quot;)
}

func TestHello(t *testing.T) {
	fmt.Println(&amp;quot;hello&amp;quot;)
}

func TestGetSub(t *testing.T) {
	res2 := getSub(5, 10)
	if res2 != 10 {
		t.Fatalf(&amp;quot;getSub(5, 10)執行錯誤 期望=%v 實際=%v&amp;quot;, 10, res2)
	}
	t.Logf(&amp;quot;執行正確&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;測性能&#34;&gt;測性能&lt;/h2&gt;
&lt;h4 id=&#34;splitgo&#34;&gt;Split.go&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// abc,b=&amp;gt;[a c]
func Split(str, sep string) []string {
	// str=&amp;quot;bsfcvjkhbafs&amp;quot; sep=&amp;quot;b&amp;quot;
	var ret = make([]string, 0, strings.Count(str, sep)+1)
	index := strings.Index(str, sep)
	for index &amp;gt;= 0 {
		ret = append(ret, str[:index])
		str = str[index+len(sep):]
		index = strings.Index(str, sep)
	}
	ret = append(ret, str)
	return ret
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;split_testgo&#34;&gt;Split_test.go&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func BenchmarkSplit(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		Split(&amp;quot;a:b:c&amp;quot;, &amp;quot;:&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-test/ - Yoziming</description>
        </item>
    
    
  </channel>
</rss> 