<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>柚子茶室</title>
    <link>https://yoziming.github.io/</link>
    <description>Recent content on 柚子茶室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>yoziming</copyright>
    <lastBuildDate>Sun, 12 Dec 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yoziming.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>函數綁定方法</title>
        <link>https://yoziming.github.io/post/210810-agg-go-method/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-method/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-method/ -&lt;h1 id=&#34;函數綁定方法&#34;&gt;函數綁定方法&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;方法:結構體的行為，自訂義的結構都可以有方法，方法是作用在指定類型上(綁定的)&lt;/p&gt;
&lt;p&gt;方法就是跟一種類型綁定的函數，因為綁定數據類型了就可以偷雞，具體表現在省指針&lt;/p&gt;
&lt;p&gt;定義方法時候寫的是func(a ABC) //後面怎樣調用都是值拷貝&lt;/p&gt;
&lt;p&gt;定義方法時候寫的是func(a *ABC)//後面怎樣調用都是真實地址&lt;/p&gt;
&lt;p&gt;要調用方法，只能透過那種類型的的數據變量 例如a1.ABC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Person struct {
	Name string
}

//給Person類型綁定一個方法
func (p Person) test() {
	p.Name = &amp;quot;jack&amp;quot;
	fmt.Println(&amp;quot;test()=&amp;quot;, p.Name)
}

//給Person類型添加一個speak方法，輸出xxx是好人
func (p Person) speak() {
	fmt.Println(p.Name, &amp;quot;是一個好人&amp;quot;)
}

//添加一個計算方法算+1...+100
func (p Person) count() {
	res := 0
	for i := 1; i &amp;lt;= 100; i++ {
		res += i
	}
	fmt.Println(p.Name, &amp;quot;計算的結果是&amp;quot;, res)
}

//添加一個計算方法算+1...+n
func (p Person) count2(n int) {
	res := 0
	for i := 1; i &amp;lt;= n; i++ {
		res += i
	}
	fmt.Println(p.Name, &amp;quot;計算的結果是&amp;quot;, res)
}

//添加一個方法計算2個值的和並返回
func (p Person) getSum(n1, n2 int) int {
	return n1 + n2
}

//為了提高效率，通常把方法跟結構的指針綁定
type Circle struct {
	radius float64
}

func (c *Circle) area() float64 {
	c.radius = 10.0                   //因為傳來的是指針，如果在函數裡改他就等於改真實地址了
	return 3.14 * c.radius * c.radius //語法糖 本來應該是要寫(*c)來計算的
}

//給某方法實現方法String()
type Student struct {
	Name string
	Age  int
}

func (stu *Student) String() string {
	str := fmt.Sprintf(&amp;quot;Name=%v Age=%v&amp;quot;, stu.Name, stu.Age)
	return str
}

//練習題
type MeUtils struct {
	//123
}

func (mu MeUtils) Print(m int, n int) {
	for i := 1; i &amp;lt;= m; i++ {
		for j := 1; j &amp;lt;= n; j++ {
			fmt.Print(&amp;quot;*&amp;quot;)
		}
		fmt.Println()
	}

}

func main() {
	var p Person
	p.Name = &amp;quot;tom&amp;quot;
	p.test() //調用方法
	fmt.Println(&amp;quot;main=&amp;quot;, p.Name)
	//test()//報錯的
	//總的來說就是把test方法跟Person類型綁定，而這個test只能用Person類型調用
	//傳的是形參 (函數裡的是一個副本)
	//---------------------------------------------以下開始應用練習
	p.speak()
	p.count()
	p.count2(1000)
	res := p.getSum(10, 20)
	fmt.Println(res)

	//創建變量嘗試調用area
	var c Circle
	c.radius = 5.0
	res2 := c.area() //語法糖 本來應該是要寫(&amp;amp;c).area()的
	fmt.Println(res2)

	//調用Student
	stu1 := Student{
		Name: &amp;quot;tom&amp;quot;,
		Age:  18,
	}
	//如果實現了*Student類型的String方法就會自動調用
	fmt.Println(&amp;amp;stu1)

	//練習題
	var mu MeUtils
	mu.Print(5, 10)

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-method/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>切片</title>
        <link>https://yoziming.github.io/post/210810-agg-go-slice/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-slice/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-slice/ -&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	//切片的類型是引用(傳遞的時候也是引用地址)
	//切片長度可變(不像數組)
	var arr1 = [5]int{1, 2, 3, 4, 5}
	s1 := arr1[1:3] //表示切arr的[1 2] 左開右閉(含左不含右)
	//var slice=arr[0:end]簡寫[:end]
	//[start:len(arr)]=[start:]
	//[0:len(arr)]=[:]
	fmt.Println(&amp;quot;s1內容是&amp;quot;, s1)
	fmt.Println(&amp;quot;s1長度是&amp;quot;, len(s1))
	fmt.Println(&amp;quot;s1容量是&amp;quot;, cap(s1))
	fmt.Printf(&amp;quot;s1第一個地址是%p\n&amp;quot;, &amp;amp;s1[0])
	fmt.Printf(&amp;quot;arr1[1]地址是%p\n&amp;quot;, &amp;amp;arr1[1])
	s1[0] = 33
	fmt.Println(&amp;quot;arr1內容是&amp;quot;, arr1)

	//var 切片名[]type=make([]type,len,cap)
	var s2 []float64 = make([]float64, 5, 10)
	fmt.Println(s2)
	//var 變量=make(類型)
	var s22 = make([]float64, 5, 10)
	fmt.Println(s22)
	var s3 []int = []int{1, 2, 3, 4, 5}
	fmt.Println(s3)
	//用append動態追加
	s3 = append(s3, 6, 7, 8, 9)
	fmt.Println(s3)
	s3 = append(s3, s3...) //...表示擴展
	//用append的時候 其實是創建一個新的arr，值拷貝過去，然後重新指向
	s3[10] = 600
	fmt.Println(s3)

	//用copy 要求2者都是切片類型
	//短的賦給長的 後面沒東西就保持原樣(0)
	//長的賦給短的 不會自動擴容 依照短的
	var s4 = make([]int, 20)
	fmt.Println(s4)
	copy(s4, s3)
	fmt.Println(s4)

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;切string&#34;&gt;切string&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	str := &amp;quot;hello@yozimingfight!&amp;quot;
	//string是一個byte數組，所以可以切片擷取
	s1 := str[6:]
	fmt.Println(s1)
	//但是string是不可變的，不能用s1[0]=&#39;z&#39;這樣想改變一個字
	//看做一個read only的切片

	//可以轉[]byte或[]rune 修改 後轉回去
	arr1 := []byte(str)
	arr1[0] = &#39;z&#39;
	str = string(arr1)
	fmt.Println(str)
	//byte不能處理中文字(3字節)
	arr2 := []rune(str)
	arr2[0] = &#39;我&#39;
	str = string(arr2)
	fmt.Println(str)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;切片練習-費波納數列&#34;&gt;切片練習-費波納數列&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func fbn(n int) []uint64 {
	var s1 []uint64 = make([]uint64, n)
	if n &amp;lt; 2 {
		s1[0] = 1
		return s1
	} else {
		s1[0] = 1
		s1[1] = 1
		for i := 2; i &amp;lt; n; i++ {
			s1[i] = s1[i-1] + s1[i-2]
		}
		return s1
	}
}

func main() {
	a := fbn(1)
	fmt.Println(a)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-slice/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>匿名函數與閉包</title>
        <link>https://yoziming.github.io/post/210810-agg-go-closure/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-closure/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-closure/ -&lt;h1 id=&#34;匿名函數&#34;&gt;匿名函數&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	res := func(n1, n2 int) int {
		return n1 + n2
	}(10, 20)
	fmt.Println(res)
	a := func(n1, n2 int) int {
		return n1 - n2
	}
	res = a(10, 5)
	fmt.Println(res)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;閉包&#34;&gt;閉包&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//累加器
func Add() func(int) int { //Add是一個函數，返回的數據類型是func(int) int

	var n int = 10 //返回的是一個匿名函數，那這個函數用到函數外的n，因此形成一個整體稱為閉包
	return func(x int) int {
		n = n + x
		return n
		//閉包是類，函數是操作，n是字段，函數+使用n構成閉包
		//n只初始化一次
	}
}
func main() {
	a := Add()
	fmt.Println(a(1))
	fmt.Println(a(2))
	fmt.Println(a(3))

}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;案例2&#34;&gt;案例2&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func makeSuffix(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}
func main() {
	f := makeSuffix(&amp;quot;.jpg&amp;quot;)
	fmt.Println(f(&amp;quot;654&amp;quot;))
	fmt.Println(f(&amp;quot;123.jpg&amp;quot;))

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-closure/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>命令行參數Args&amp;Flag</title>
        <link>https://yoziming.github.io/post/210810-agg-go-argsflag/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-argsflag/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-argsflag/ -&lt;h1 id=&#34;命令行參數argsflag&#34;&gt;命令行參數Args&amp;amp;Flag&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	fmt.Println(&amp;quot;命令行參數有&amp;quot;, len(os.Args))
	//遍歷os.Args切片 得到所有輸入的參數值
	for i, v := range os.Args {
		fmt.Printf(&amp;quot;args[%v]=%v\n&amp;quot;, i, v)
	}
	fmt.Println(&amp;quot;=====================&amp;quot;)

	//flag方法 先定義幾個變量用於接收參數值
	var user string
	var pwd string
	var host string
	var port int

	flag.StringVar(&amp;amp;user, &amp;quot;u&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;帳號 預設為空&amp;quot;)
	flag.StringVar(&amp;amp;pwd, &amp;quot;pwd&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;密碼 預設為空&amp;quot;)
	flag.StringVar(&amp;amp;host, &amp;quot;h&amp;quot;, &amp;quot;localhost&amp;quot;, &amp;quot;主機 預設為localhost&amp;quot;)
	flag.IntVar(&amp;amp;port, &amp;quot;port&amp;quot;, 3306, &amp;quot;端口 預設為3306&amp;quot;)
	//前面有亂打的字就不行 比如...exe 12354 -u tom會調用預設

	flag.Parse() //這個一定要調用

	//輸出結果
	fmt.Printf(&amp;quot;user=%v pwd=%v host=%v port=%v&amp;quot;,
		user, pwd, host, port)
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-argsflag/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>字串轉換常用函數</title>
        <link>https://yoziming.github.io/post/210810-agg-go-string-conver/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-string-conver/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-string-conver/ -&lt;h1 id=&#34;字串轉換常用函數&#34;&gt;字串轉換常用函數&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
var str string = &amp;quot;abc123中文&amp;quot;

func main() {
	fmt.Println(&amp;quot;長度=&amp;quot;, len(str))
	r := []rune(str)
	for i := 0; i &amp;lt; len(r); i++ {
		fmt.Printf(&amp;quot;遍歷=%q\n&amp;quot;, r[i])
	}
	//轉成整數 Atoi
	n, err := strconv.Atoi(&amp;quot;5421&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;錯誤,err&amp;quot;)
	} else {
		fmt.Println(&amp;quot;轉換成&amp;quot;, n)
		//整數轉字串
		str2 := strconv.Itoa(654231)
		fmt.Printf(&amp;quot;類型是%T\n&amp;quot;, str2)
		//轉byte
		var bytes = []byte(&amp;quot;hello&amp;quot;)
		fmt.Printf(&amp;quot;bytes=%v \n&amp;quot;, bytes)
		//byte轉回字串
		str3 := string([]byte{97, 98, 99})
		fmt.Printf(&amp;quot;str3=%v \n&amp;quot;, str3)
		//10進制轉2,8,16返回字串
		str4 := strconv.FormatInt(123, 2)
		fmt.Printf(&amp;quot;str4類型是%T,值=%v \n&amp;quot;, str4, str4)
		//查找子串
		b := strings.Contains(&amp;quot;seafood&amp;quot;, &amp;quot;foo&amp;quot;)
		fmt.Printf(&amp;quot;b類型是%T,值=%v \n&amp;quot;, b, b)
		//統計符合數量
		c := strings.Count(&amp;quot;sgfjklewshfrrrrrr&amp;quot;, &amp;quot;r&amp;quot;)
		fmt.Printf(&amp;quot;c類型是%T,值=%v \n&amp;quot;, c, c)
		//不分大小寫 (因為==是分的)
		d := strings.EqualFold(&amp;quot;ABCd&amp;quot;, &amp;quot;aBcD&amp;quot;)
		fmt.Printf(&amp;quot;d類型是%T,值=%v \n&amp;quot;, d, d)
		//查找第一次出現的子串位置
		i := strings.Index(&amp;quot;sdaf654abc&amp;quot;, &amp;quot;a&amp;quot;)
		fmt.Printf(&amp;quot;i類型是%T,值=%v \n&amp;quot;, i, i)
		//查找最後出現的子串位置
		l := strings.LastIndex(&amp;quot;sdaf654abc&amp;quot;, &amp;quot;a&amp;quot;)
		fmt.Printf(&amp;quot;l類型是%T,值=%v \n&amp;quot;, l, l)
		//替換文字
		str5 := &amp;quot;瘟疫之地有瘟疫,瘟疫病人身上有瘟疫&amp;quot;
		r := strings.Replace(str5, &amp;quot;瘟疫&amp;quot;, &amp;quot;痔瘡&amp;quot;, 2)
		fmt.Println(&amp;quot;原句&amp;quot;, str5)
		fmt.Printf(&amp;quot;r類型是%T,值=%v \n&amp;quot;, r, r)
		//依照指定的字串分割成切片
		s := strings.Split(&amp;quot;hello,world,ok&amp;quot;, &amp;quot;,&amp;quot;)
		fmt.Printf(&amp;quot;s類型是%T,值=%v \n&amp;quot;, s, s)
		//大小寫轉換
		cap := &amp;quot;DDDDssss&amp;quot;
		cap = strings.ToLower(cap)
		fmt.Println(cap)
		cap = strings.ToUpper(cap)
		fmt.Println(cap)
		//去掉左右兩邊空格
		sp := strings.TrimSpace(&amp;quot;  KJHF JKLH LKJ  ..   &amp;quot;)
		fmt.Println(sp)
		//去掉左右指定 //TrimLeft // TrimRight
		lr := strings.Trim(&amp;quot;!!KJHFJHG!!!&amp;quot;, &amp;quot;!&amp;quot;)
		fmt.Println(lr)
		//判斷開頭或結束  //HasSuffix
		s6 := strings.HasPrefix(&amp;quot;ftp://192.164.2.1&amp;quot;, &amp;quot;ftp&amp;quot;)
		fmt.Printf(&amp;quot;s6類型是%T,值=%v \n&amp;quot;, s6, s6)
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-string-conver/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>實作練習-ini解析器</title>
        <link>https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/ -&lt;h1 id=&#34;heading&#34;&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;用來解析.ini文檔格式是否有問題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;reflect&amp;quot;
	&amp;quot;strings&amp;quot;
)

type RedisConfig struct {
	Host     string `ini:&amp;quot;host&amp;quot;`
	Port     int    `ini:&amp;quot;port&amp;quot;`
	Password string `ini:&amp;quot;password&amp;quot;`
	Database int    `ini:&amp;quot;database&amp;quot;`
}
type MysqlConfig struct {
	Address  string `ini:&amp;quot;address&amp;quot;`
	Port     int    `ini:&amp;quot;port&amp;quot;`
	Password string `ini:&amp;quot;password&amp;quot;`
	Username string `ini:&amp;quot;username&amp;quot;`
}

type Config struct {
	MysqlConfig `ini:&amp;quot;mysql&amp;quot;`
	RedisConfig `ini:&amp;quot;redis&amp;quot;`
}

func loadIni(fileName string, data interface{}) (err error) {
	// 0. 參數校驗
	// 0.1 傳來的data必須是結構體類型指針
	t := reflect.TypeOf(data)
	// fmt.Println(t.Kind())
	if t.Kind() != reflect.Ptr {
		err = fmt.Errorf(&amp;quot;傳來的data必須是指針&amp;quot;)
		return
	}
	if t.Elem().Kind() != reflect.Struct {
		err = fmt.Errorf(&amp;quot;傳來的data必須是結構體類型指針&amp;quot;)
		return
	}
	// 1. 讀取文件~&amp;gt;Byte類型
	b, err := ioutil.ReadFile(fileName)
	if err != nil {
		return
	}
	//轉成字符串
	lineSlice := strings.Split(string(b), &amp;quot;\r\n&amp;quot;)
	// fmt.Println(lineSlice)
	// 2. 一行一行讀取數據
	var structName string
	for idx, line := range lineSlice {
		line = strings.TrimSpace(line) //去除多餘空格
		// 2.1 如果是註釋就跳過
		if strings.HasPrefix(line, &amp;quot;;&amp;quot;) || strings.HasPrefix(line, &amp;quot;#&amp;quot;) {
			continue
		}
		//純空行就跳過
		if len(line) == 0 {
			continue
		}
		// 2.2 如果是[]開頭表示是節
		if strings.HasPrefix(line, &amp;quot;[&amp;quot;) {
			if line[0] != &#39;[&#39; || line[len(line)-1] != &#39;]&#39; {
				err = fmt.Errorf(&amp;quot;line:%d syntax error&amp;quot;, idx+1)
				return
			}
			//去掉這行的首尾跟空格拿到內容
			section := strings.TrimSpace(line[1 : len(line)-1])
			if len(section) == 0 {
				err = fmt.Errorf(&amp;quot;line:%d syntax error&amp;quot;, idx+1)
				return
			}
			//根據section去data反射對應的結構體
			for i := 0; i &amp;lt; t.Elem().NumField(); i++ {
				field := t.Elem().Field(i)
				if section == field.Tag.Get(&amp;quot;ini&amp;quot;) {
					//說明找到了，把字段名記下
					structName = field.Name
					fmt.Println(section, structName)
				}

			}

		} else {
			// 2.3 剩下的就是分割的鍵值對
			//先排除異常的行
			if strings.Index(line, &amp;quot;=&amp;quot;) == -1 || strings.HasPrefix(line, &amp;quot;=&amp;quot;) {
				err = fmt.Errorf(&amp;quot;line:%d syntax error&amp;quot;, idx+1)
				return
			}
			index := strings.Index(line, &amp;quot;=&amp;quot;)
			key := strings.TrimSpace(line[:index])
			// value := strings.TrimSpace(line[:index+1])
			v := reflect.ValueOf(data)
			sValue := v.Elem().FieldByName(structName) //拿到嵌套結構體的值信息
			sType := sValue.Type()                     //拿到嵌套結構體的類型信息
			if sType.Kind() != reflect.Struct {
				err = fmt.Errorf(&amp;quot;%s應該為一個結構體&amp;quot;, structName)
				return
			}
			var fieldName string
			//遍歷嵌套結構體每一個字段 判斷tag是否=key
			for i := 0; i &amp;lt; sValue.NumField(); i++ {
				field := sType.Field(i)
				if field.Tag.Get(&amp;quot;ini&amp;quot;) == key {
					fieldName = field.Name
					break
				}
			}
			//根據fieldName取出字段賦值
			fileObj := sValue.FieldByName(fieldName)
			fmt.Println(fieldName, fileObj)
		}

	}
	return
}

func main() {
	var cfg Config
	err := loadIni(&amp;quot;C:/config.ini&amp;quot;, &amp;amp;cfg)
	if err != nil {
		panic(err)
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>實作練習-txt文本批次取代器</title>
        <link>https://yoziming.github.io/post/210820-agg-go-proj-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210820-agg-go-proj-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210820-agg-go-proj-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/ -&lt;h1 id=&#34;實作練習-txt文本批次取代器&#34;&gt;實作練習-txt文本批次取代器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;自己寫用來一次取代多個名詞，去除多餘空格或符號等等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strings&amp;quot;
)

var data []string = make([]string, 128)

func main() {
	readByBufio()
	for _, v := range data {
		if v == &amp;quot;&amp;quot; {
			break
		}
		fmt.Print(v)
	}

}
func readByBufio() {
	file, err := os.Open(&amp;quot;C:/test.txt&amp;quot;)
	if err != nil {
		fmt.Printf(&amp;quot;os.Open err %s\n&amp;quot;, err)
		return
	}
	defer file.Close()
	reader := bufio.NewReader(file)
	for i := 0; ; i++ {
		line, err := reader.ReadString(&#39;\n&#39;)
		if err == io.EOF {
			return
		}
		if err != nil {
			fmt.Printf(&amp;quot;reader.ReadString err %s\n&amp;quot;, err)
			return
		}
		line = strings.ReplaceAll(line, &amp;quot;++&amp;quot;, &amp;quot;+&amp;quot;) //去除多餘++
		line = strings.ReplaceAll(line, &amp;quot;  &amp;quot;, &amp;quot; &amp;quot;) //去除多餘空格
		line = strings.ReplaceAll(line, &amp;quot;*&amp;quot;, &amp;quot;&amp;quot;)   //去除多餘*
		line = strings.ReplaceAll(line, &amp;quot;AAAA&amp;quot;, &amp;quot;BBBB&amp;quot;)
		line = strings.ReplaceAll(line, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;)
		data[i] = line
	}

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210820-agg-go-proj-txt%E6%96%87%E6%9C%AC%E6%89%B9%E6%AC%A1%E5%8F%96%E4%BB%A3%E5%99%A8/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>實作練習-多人聊天室</title>
        <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210820-agg-go-proj-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/ -&lt;h1 id=&#34;實作練習-多人聊天室&#34;&gt;實作練習-多人聊天室&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本來很傻的檔案代碼一個一個貼，後來學了github的專案管理就放到那了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/yoziming/go-practice-chatroom&#34;&gt;https://github.com/yoziming/go-practice-chatroom&lt;/a&gt;&lt;/p&gt;
- https://yoziming.github.io/post/210820-agg-go-proj-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>實作練習-客戶名單管理系統</title>
        <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/ -&lt;h1 id=&#34;實作練習-客戶名單管理系統&#34;&gt;實作練習-客戶名單管理系統&lt;/h1&gt;
&lt;h3 id=&#34;model&#34;&gt;model&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Customer struct {
	Id     int
	Name   string
	Gender string
	Age    int
	Phone  string
	Email  string
}

//使用工廠模式返回一個實例
func NewCustomer(id int, name string, gender string,
	age int, phone string, email string) Customer {
	return Customer{
		Id:     id,
		Name:   name,
		Gender: gender,
		Age:    age,
		Phone:  phone,
		Email:  email,
	}
}

//返回用戶訊息
func (c Customer) GetInfo() string {
	info := fmt.Sprintf(&amp;quot;%v	%v	%v	%v	%v	%v&amp;quot;,
		c.Id, c.Name, c.Gender, c.Age, c.Phone, c.Email)
	return info

}

//用戶創建
func NewCustomer2(name string, gender string,
	age int, phone string, email string) Customer {
	return Customer{
		Name:   name,
		Gender: gender,
		Age:    age,
		Phone:  phone,
		Email:  email,
	}
}

//修改
func (c *Customer) Reset(name string, gender string, age int, phone string, email string) {
	if name != &amp;quot;&amp;quot; {
		c.Name = name
	}
	if gender != &amp;quot;&amp;quot; {
		c.Gender = gender
	}
	if age != 0 {
		c.Age = age
	}
	if phone != &amp;quot;&amp;quot; {
		c.Phone = phone
	}
	if email != &amp;quot;&amp;quot; {
		c.Email = email
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;view&#34;&gt;view&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
type customerView struct {
	key             string //接收用戶輸入
	loop            bool   //是否循環回到主頁面
	customerService *service.CustomerService
}

//顯示主菜單
func (cv *customerView) mainMenu() {
	for {
		fmt.Println(&amp;quot;\n---客戶訊息管理系統---&amp;quot;)
		fmt.Println(&amp;quot;   1 添加新客戶&amp;quot;)
		fmt.Println(&amp;quot;   2 修改客戶&amp;quot;)
		fmt.Println(&amp;quot;   3 刪除客戶&amp;quot;)
		fmt.Println(&amp;quot;   4 客戶列表&amp;quot;)
		fmt.Println(&amp;quot;   5 退出&amp;quot;)
		fmt.Print(&amp;quot;請選擇(1-5)...&amp;quot;)
		fmt.Scanln(&amp;amp;cv.key)
		switch cv.key {
		case &amp;quot;1&amp;quot;:
			fmt.Println(&amp;quot;你選擇的是...1 添加新客戶&amp;quot;)
			cv.add()
		case &amp;quot;2&amp;quot;:
			fmt.Println(&amp;quot;你選擇的是...2 修改客戶&amp;quot;)
		case &amp;quot;3&amp;quot;:
			fmt.Println(&amp;quot;你選擇的是...3 刪除客戶&amp;quot;)
			cv.delete()
		case &amp;quot;4&amp;quot;:
			fmt.Println(&amp;quot;你選擇的是...4 客戶列表&amp;quot;)
			cv.list()
		case &amp;quot;5&amp;quot;:
			fmt.Println(&amp;quot;你選擇的是...5 退出&amp;quot;)
			cv.loop = false
		default:
			fmt.Println(&amp;quot;輸入有誤，請重新輸入...&amp;quot;)
		}
		if !cv.loop {
			break
		}
	}
	fmt.Println(&amp;quot;你已成功退出客戶訊息管理系統!&amp;quot;)
}

//得到用戶輸入並添加
func (cv *customerView) add() {
	fmt.Println(&amp;quot;---添加新客戶---&amp;quot;)
	fmt.Println(&amp;quot;輸入姓名...&amp;quot;)
	name := &amp;quot;&amp;quot;
	fmt.Scanln(&amp;amp;name)
	fmt.Println(&amp;quot;輸入性別...&amp;quot;)
	gender := &amp;quot;&amp;quot;
	fmt.Scanln(&amp;amp;gender)
	fmt.Println(&amp;quot;輸入年齡...&amp;quot;)
	age := 0
	fmt.Scanln(&amp;amp;age)
	fmt.Println(&amp;quot;輸入電話...&amp;quot;)
	phone := &amp;quot;&amp;quot;
	fmt.Scanln(&amp;amp;phone)
	fmt.Println(&amp;quot;輸入信箱...&amp;quot;)
	email := &amp;quot;&amp;quot;
	fmt.Scanln(&amp;amp;email)
	//構建一個Customer實例
	//id要系統分配
	customer := model.NewCustomer2(name, gender, age, phone, email)
	//調用
	if cv.customerService.Add(customer) {
		fmt.Println(&amp;quot;添加完成!&amp;quot;)
	} else {
		fmt.Println(&amp;quot;添加失敗!&amp;quot;)
	}

}

//修改
// func (cs *customerView) Reset() {
// 	var id int
// 	fmt.Println(&amp;quot;请输入需要修改的用户ID(无需请输入-1)&amp;quot;)
// 	fmt.Scanln(&amp;amp;id)
// 	if id == -1 {
// 		return
// 	}
// 	resetIndex := cs.customerService.FindById(id)
// 	if resetIndex == -1 {
// 		fmt.Println(&amp;quot;改用户不存在&amp;quot;)
// 	} else {
// 		_, name, gender, age, phone, email := cs.customerService[resetIndex].GetInfo()
// 		fmt.Printf(&amp;quot;姓名(%v):&amp;quot;, name)
// 		fmt.Scanln(&amp;amp;name)
// 		fmt.Printf(&amp;quot;性别(%v):&amp;quot;, gender)
// 		fmt.Scanln(&amp;amp;gender)
// 		fmt.Printf(&amp;quot;年龄(%v):&amp;quot;, age)
// 		fmt.Scanln(&amp;amp;age)
// 		fmt.Printf(&amp;quot;电话(%v):&amp;quot;, phone)
// 		fmt.Scanln(&amp;amp;phone)
// 		fmt.Printf(&amp;quot;邮箱(%v):&amp;quot;, email)
// 		fmt.Scanln(&amp;amp;email)
// 		cs.customerService.List()[resetIndex].Reset(name, gender, age, phone, email)

// 	// }

// }

//刪除用戶
func (cv *customerView) delete() {
	fmt.Println(&amp;quot;---刪除客戶---&amp;quot;)
	fmt.Println(&amp;quot;輸入ID(-1=退出)...&amp;quot;)
	id := -1
	fmt.Scanln(&amp;amp;id)
	if id == -1 {
		return //放棄刪除
	}
	fmt.Println(&amp;quot;確認是否刪除?(Y/N)&amp;quot;)
	var choice string = &amp;quot;&amp;quot;
	fmt.Scanln(&amp;amp;choice)
	if choice == &amp;quot;y&amp;quot; || choice == &amp;quot;Y&amp;quot; {
		if cv.customerService.Delete(id) {
			fmt.Println(&amp;quot;刪除完成!&amp;quot;)
		} else {
			fmt.Println(&amp;quot;刪除失敗，該ID不存在&amp;quot;)
		}
	}

}

//顯示所有客戶信息
func (cv *customerView) list() {
	customers := cv.customerService.List()
	fmt.Println(&amp;quot;---客戶列表---&amp;quot;)
	fmt.Println(&amp;quot;編號\t姓名\t性別\t年齡\t電話\t信箱&amp;quot;)
	for i := range customers {
		fmt.Println(customers[i].GetInfo())

	}

	fmt.Println(&amp;quot;---客戶列表末尾---&amp;quot;)
}

func main() {
	//創建一個customerView的實例並運行顯示
	customerView := customerView{
		key:  &amp;quot;&amp;quot;,
		loop: true,
	}
	//對customerService字段初始化
	customerView.customerService = service.NewCustomerService()

	customerView.mainMenu()
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;controler&#34;&gt;controler&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//完成對Customer的操作
type CustomerService struct {
	customers []model.Customer
	//聲明一個字段，表示當前切片有幾個客戶
	customerNum int //還能作為新客戶的id+1
}

//寫一個方法返回*CustomerService，就是Customer的切片
func NewCustomerService() *CustomerService {
	customerService := &amp;amp;CustomerService{}
	//初始化一個客戶
	customerService.customerNum = 1
	customer := model.NewCustomer(1, &amp;quot;摺紙&amp;quot;, &amp;quot;女&amp;quot;, 15, &amp;quot;110&amp;quot;, &amp;quot;001@x.mail&amp;quot;)
	customerService.customers = append(customerService.customers, customer)
	return customerService

}

//返回客戶切片
func (cs *CustomerService) List() []model.Customer {
	return cs.customers
}

//添加客戶到customer切片
func (cs *CustomerService) Add(customer model.Customer) bool {
	//添加一個分配ID的規則
	cs.customerNum++
	customer.Id = cs.customerNum
	cs.customers = append(cs.customers, customer)
	return true
}

//根據id尋找對應切片的下標
func (cs *CustomerService) FindById(id int) int {
	index := -1 //找不到則返回-1
	for i := 0; i &amp;lt; len(cs.customers); i++ {
		if cs.customers[i].Id == id {
			//找到了
			index = i
		}
	}
	return index
}

//刪除
func (cs *CustomerService) Delete(id int) bool {
	index := cs.FindById(id)
	if index == -1 {
		return false
	}
	//從切片中刪除一個元素
	cs.customers = append(cs.customers[:index], cs.customers[index+1:]...)
	return true
}

//修改

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%A2%E6%88%B6%E5%90%8D%E5%96%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>實作練習-家庭收支小app</title>
        <link>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/ -&lt;h1 id=&#34;實作練習-家庭收支小app&#34;&gt;實作練習-家庭收支小app&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyMoney struct {
	key     string  //鍵入值
	note    string  //收支說明
	balance float64 //餘額
	money   float64 //收支
	flag    bool    //判斷是否有明細
	details string  //詳細
	loop    bool    //循環
}

//綁定方法
func (mm *MyMoney) MainMenu() {
	for {
		if !mm.loop {
			break
		}
		fmt.Println(&amp;quot;\n-----------------家庭收支记账软件-----------------&amp;quot;)
		fmt.Println(&amp;quot;                  1 收支明细&amp;quot;)
		fmt.Println(&amp;quot;                  2 登记收入&amp;quot;)
		fmt.Println(&amp;quot;                  3 登记支出&amp;quot;)
		fmt.Println(&amp;quot;                  4 退出软件&amp;quot;)
		fmt.Print(&amp;quot;請選擇(1-4)...&amp;quot;)
		fmt.Scanln(&amp;amp;mm.key)

		switch mm.key {
		case &amp;quot;1&amp;quot;:
			mm.showDetails()
		case &amp;quot;2&amp;quot;:
			mm.income()
		case &amp;quot;3&amp;quot;:
			mm.outcome()
		case &amp;quot;4&amp;quot;:
			mm.exit()
		default:
			fmt.Println(&amp;quot;輸入錯誤，返回主選單&amp;quot;)
		}
	}
}

func (mm *MyMoney) showDetails() {
	fmt.Println(&amp;quot;\n-----------------收支明细-----------------&amp;quot;)
	if mm.flag {
		fmt.Println(mm.details)
	} else {
		fmt.Println(&amp;quot;當前沒有明細&amp;quot;)
	}
}

func (mm *MyMoney) income() {
	fmt.Println(&amp;quot;\n-----------------登记收入-----------------&amp;quot;)
	fmt.Println(&amp;quot;輸入收入金額...&amp;quot;)
	fmt.Scanln(&amp;amp;mm.money)
	mm.balance += mm.money
	fmt.Println(&amp;quot;輸入收入說明...&amp;quot;)
	fmt.Scanln(&amp;amp;mm.note)
	mm.details += fmt.Sprintf(&amp;quot;\n收入\t%v\t	%v\t	%v&amp;quot;, mm.balance, mm.money, mm.note)
	mm.flag = true
}

func (mm *MyMoney) outcome() {
	fmt.Println(&amp;quot;本次支出金额:&amp;quot;)
	fmt.Scanln(&amp;amp;mm.money)
	//这里需要做一个必要的判断
	mm.balance -= mm.money
	fmt.Println(&amp;quot;本次支出说明:&amp;quot;)
	fmt.Scanln(&amp;amp;mm.note)
	mm.details += fmt.Sprintf(&amp;quot;\n支出\t%v\t	%v\t	%v&amp;quot;, mm.balance, mm.money, mm.note)
	mm.flag = true
}

func (mm *MyMoney) exit() {
	fmt.Println(&amp;quot;確定使否退出?(Y/N)&amp;quot;)
	choice := &amp;quot;&amp;quot;
	for {
		fmt.Scanln(&amp;amp;choice)
		if choice == &amp;quot;Y&amp;quot; || choice == &amp;quot;N&amp;quot; {
			break
		}
		fmt.Println(&amp;quot;錯誤，確定使否退出?(Y/N)&amp;quot;)
	}
	if choice == &amp;quot;Y&amp;quot; {
		fmt.Println(&amp;quot;\n-----------------結束-----------------&amp;quot;)
		mm.loop = false
	} else {
		mm.loop = true
	}
}

//工廠模式
func NewMyMoney() *MyMoney {
	return &amp;amp;MyMoney{
		key:     &amp;quot;&amp;quot;,
		loop:    true,
		balance: 10000.0,
		money:   0.0,
		note:    &amp;quot;&amp;quot;,
		flag:    false,
		details: &amp;quot;收支\t账户金额\t收支金额\t说 明&amp;quot;,
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210820-agg-go-proj-%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E5%B0%8Fapp/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>實作練習-點對點聊天</title>
        <link>https://yoziming.github.io/post/210820-agg-go-proj-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210820-agg-go-proj-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210820-agg-go-proj-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/ -&lt;h1 id=&#34;實作練習-點對點聊天&#34;&gt;實作練習-點對點聊天&lt;/h1&gt;
&lt;h3 id=&#34;servergo&#34;&gt;server.go&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	fmt.Println(&amp;quot;服務器開始監聽&amp;quot;)
	listen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;0.0.0.0:8888&amp;quot;) //0.0.0.0 寫4位ip v4 v6都能用
	if err != nil {
		fmt.Println(&amp;quot;監聽失敗&amp;quot;, err)
		return
	}
	defer listen.Close() //主程式退出後就關閉監聽
	// fmt.Printf(&amp;quot;listen succes=%v\n&amp;quot;, listen)
	for {
		//開啟監聽端口8888
		time.Sleep(time.Microsecond)
		fmt.Println(&amp;quot;等待連接中...&amp;quot;)
		conn, err := listen.Accept()
		if err != nil {
			fmt.Println(&amp;quot;Accept()err=&amp;quot;, err)
		} else {
			fmt.Printf(&amp;quot;conn suc con=%v 客戶端ip=%v\n&amp;quot;, conn, conn.RemoteAddr().String())
		}
		//準備啟動一個協程
		go process(conn)
	}
}

func process(conn net.Conn) {
	//循環接收客戶端送來的數據
	defer conn.Close()
	fmt.Printf(&amp;quot;服務器等待%s客戶端輸入...\n&amp;quot;, conn.RemoteAddr().String())
	for {
		//創建一個新的切片
		buf := make([]byte, 1024)
		n, err := conn.Read(buf) //從conn讀取
		//等待客戶端通過conn發送信息
		//如果客戶端沒有write,那協程就阻塞在這

		if err != nil {
			fmt.Println(&amp;quot;客戶端Read err&amp;quot;, err)
			return
		}
		fmt.Print(string(buf[:n])) //不用換行因為接收來的就包含\n
		//來的是一個byte切片 讀到[:n]剛好，後面還有玩意不是要的
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;clientgo&#34;&gt;client.go&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8888&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;client dial err=&amp;quot;, err)
		return
	}
	fmt.Printf(&amp;quot;conn suc con=%v 主機端ip=%v\n&amp;quot;, conn, conn.RemoteAddr().String())
	//客戶端讀取輸入行

	for {

		reader := bufio.NewReader(os.Stdin) //代表標準輸入(終端)
		fmt.Println(&amp;quot;等待輸入... (exit=離開)&amp;quot;)
		data, err := reader.ReadString(&#39;\n&#39;) //代表接受到\n為止
		if err != nil {
			fmt.Println(&amp;quot;ReadString&amp;quot;, err)
		}
		//如果輸入exit就退出
		line := strings.Trim(data, &amp;quot;\n\r&amp;quot;)
		if line == &amp;quot;exit&amp;quot; {
			fmt.Println(&amp;quot;客戶端已退出&amp;quot;)
			break
		}
		//從客戶端發送數據
		n, err := conn.Write([]byte(data))
		if err != nil {
			fmt.Println(&amp;quot;conn.Write&amp;quot;, err)
		}
		fmt.Printf(&amp;quot;客戶端發送了%d字節的數據\n&amp;quot;, n)

	}

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210820-agg-go-proj-%E9%BB%9E%E5%B0%8D%E9%BB%9E%E8%81%8A%E5%A4%A9/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>對有序數列進行二分查找</title>
        <link>https://yoziming.github.io/post/210810-agg-go-binary-search/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-binary-search/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-binary-search/ -&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//對有序數列進行二分查找
var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 0}

func bubble(x []int) {
	for j := 1; j &amp;lt; len(x); j++ {
		for i := 0; i &amp;lt; len(x)-1; i++ {
			if x[i] &amp;gt; x[i+1] {
				x[i], x[i+1] = x[i+1], x[i]
			}
		}
	}
}
func bi(x int, s []int, left int, right int) {
	middle := (right + left) / 2
	if left &amp;gt; right {
		fmt.Println(&amp;quot;找不到&amp;quot;)
		return
	}
	if x &amp;lt; s[middle] {
		//在左邊
		bi(x, s, left, middle-1)
	} else if x &amp;gt; s[middle] {
		//在右邊
		bi(x, s, middle+1, right)
	} else {
		fmt.Println(&amp;quot;找到下標=&amp;quot;, middle)
	}

}
func main() {
	s1 := arr1[:]
	bubble(s1)
	fmt.Println(s1)
	bi(9, s1, 0, len(s1)-1)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-binary-search/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>工廠模式</title>
        <link>https://yoziming.github.io/post/210810-agg-go-factory/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-factory/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-factory/ -&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//工廠模式
// 假如有些要公用的東西又不想用大寫讓人隨意改了 例如結構體、結構體內的字段等等
// 我就在那個包裏建一個方法，這個方法本身大寫，在方法中原地調用那些本來是大寫的玩意
// 返回一個相同的值過來，相當於那在那個包里把該封裝的都封好，拿出來的就是產品

import (
	&amp;quot;fmt&amp;quot;
)

type Student struct {
	Name  string
	Age   int
	Score float64
}

func (s *Student) Say() string {
	infoStr := fmt.Sprintf(&amp;quot;信息 name=[%v] age=[%v] score=[%v]&amp;quot;,
		s.Name, s.Age, s.Score)
	return infoStr
}

func main() {
	var s1 = Student{
		Name:  &amp;quot;tom&amp;quot;,
		Score: 98,
		Age:   18, //不依賴順序
	}
	res := s1.Say()
	fmt.Println(res)

	//其他創建結構變量同時指定值的方法:
	stu2 := Student{&amp;quot;Jack&amp;quot;, 20, 100} //項目順序都要有對應
	fmt.Println(stu2)
	//返回結構的指針
	var stu3 = &amp;amp;Student{&amp;quot;Mary&amp;quot;, 28, 5}
	fmt.Println(*stu3)

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-factory/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>拷貝檔案</title>
        <link>https://yoziming.github.io/post/210810-agg-go-io-copy/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-io-copy/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-io-copy/ -&lt;h1 id=&#34;拷貝一個檔案&#34;&gt;拷貝一個檔案&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//定義一個函數接收2個路徑
func CopyFile(dstFileName, srcFileName string) (written int64, err error) {
	srcFile, err := os.Open(srcFileName)
	if err != nil {
		fmt.Println(err)
	}
	defer srcFile.Close()
	//通過srcFile獲取到reader
	reader := bufio.NewReader(srcFile)

	//打開dstFileName
	dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		fmt.Println(err)
	}

	//通過dstFile獲取到writer
	writer := bufio.NewWriter(dstFile)
	defer dstFile.Close()
	return io.Copy(writer, reader)

}

func main() {
	src := &amp;quot;C:/01.mkv&amp;quot; //原始檔
	dst := &amp;quot;C:/food2.mkv&amp;quot;
	_, err := CopyFile(dst, src)
	if err == nil {
		fmt.Println(&amp;quot;拷貝完成&amp;quot;)
	} else {
		fmt.Println(&amp;quot;拷貝失敗&amp;quot;)
	}

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-io-copy/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>接口interface</title>
        <link>https://yoziming.github.io/post/210810-agg-go-interface/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-interface/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-interface/ -&lt;h1 id=&#34;接口interface&#34;&gt;接口interface&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;例如定義 只要滿足&amp;quot;會跑&amp;quot;且&amp;quot;會叫&amp;quot;的就是&amp;quot;動物&amp;quot;，&lt;/p&gt;
&lt;p&gt;那不管你是啥玩意只要實現會跑跟會叫，我就當你是動物，就能用動物的接口去調用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//接口內不能有變量，方法也不能實現
type Usb interface {
	//聲明兩個沒實現的方法
	Start()
	Stop()
}

type Usb2 interface {
	//接口是不需要顯示聲明，只要能實現就都能調用
	Start()
	Stop()
	//假如我多聲明一個沒實現的方法在接口內就不能調用
	Test() //有方法沒實現，導致Usb2這個接口不能用
}
type Phone struct {
}

//讓Phone實現USB接口的方法
func (p Phone) Start() {
	fmt.Println(&amp;quot;手機啟動&amp;quot;)
}
func (p Phone) Stop() {
	fmt.Println(&amp;quot;手機停止&amp;quot;)
}

type Camera struct {
}

func (c Camera) Start() {
	fmt.Println(&amp;quot;相機啟動~~&amp;quot;)
}
func (c Camera) Stop() {
	fmt.Println(&amp;quot;相機停止&amp;quot;)
}

//電腦
type Computer struct {
}

func (c Computer) Working(usb Usb) { //接受一個Usb的接口類型
	//通過usb變量來調用Start等方法
	fmt.Println(&amp;quot;電腦連接usb中...&amp;quot;)
	usb.Start()
	usb.Stop()

}
func main() {
	computer := Computer{}
	phone := Phone{}
	camera := Camera{}

	//關鍵
	computer.Working(phone)
	computer.Working(camera)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;接口繼承&#34;&gt;接口繼承&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;繼承主要在於復用性跟可維護性
接口價值在於擴展性(設計好規範(方法)，讓其他類型去實現&lt;/p&gt;
&lt;p&gt;繼承是 is a的關係 例如 學生是個人
接口是 like a的關係 例如 學生會說英語&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (m *Monkey) climb() {
	fmt.Println(m.Name, &amp;quot;生來會爬樹&amp;quot;)
}

//聲明接口
type BirdAble interface {
	Flying()
}

func (lm *LittleMonkey) Flying() {
	fmt.Println(lm.Name, &amp;quot;學會飛了&amp;quot;)
}

func main() {
	var monkey1 LittleMonkey
	monkey1.Name = &amp;quot;悟空&amp;quot;
	monkey1.climb()
	monkey1.Flying()

}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;接口實踐排序&#34;&gt;接口實踐排序&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Hero struct {
	Name string
	Age  int
}

//聲明一個Hero結構體的切片類型
type HeroSlice []Hero

//實現接口
func (hs HeroSlice) Len() int {
	return len(hs)
}

func (hs HeroSlice) Less(i, j int) bool {
	//return hs[i].Age &amp;lt; hs[j].Age //Less就是決定使用哪個字段來排序
	return hs[i].Name &amp;lt; hs[j].Name //Less就是決定使用哪個字段來排序
}

func (hs HeroSlice) Swap(i, j int) {
	hs[i], hs[j] = hs[j], hs[i]
}

func main() {
	//定義一個數組跟切片
	var intSlice = []int{5, 3, 1, 2, 4}
	//來排序
	sort.Ints(intSlice)
	fmt.Println(intSlice)

	//系統提供的方法
	
	//創建切片內容
	var heroes HeroSlice
	for i := 0; i &amp;lt; 10; i++ {
		hero := Hero{
			Name: fmt.Sprintf(&amp;quot;英雄%d&amp;quot;, rand.Intn(100)),
			Age:  rand.Intn(100),
		}
		//放進切片 隨機創建了十個hero放進heroes這個切片
		heroes = append(heroes, hero)
	}

	//排序前
	for _, v := range heroes {
		fmt.Println(v)
	}

	//調用sort.Sort
	sort.Sort(heroes)
	//因為我的結構體能實現接口，就可以享受這些方便
	fmt.Println(&amp;quot;---排序後---&amp;quot;)
	for _, v := range heroes {
		fmt.Println(v)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;類型斷言&#34;&gt;類型斷言&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TypeJudge(items ...interface{}) {
	for index, x := range items {
		switch x.(type) {
		case bool:
			fmt.Printf(&amp;quot;第%v個參數是bool類型,值是%v\n&amp;quot;, index+1, x)
		case int, int32, int64:
			fmt.Printf(&amp;quot;第%v個參數是int類型,值是%v\n&amp;quot;, index+1, x)
		case string:
			fmt.Printf(&amp;quot;第%v個參數是string類型,值是%v\n&amp;quot;, index+1, x)
		default:
			fmt.Printf(&amp;quot;第%v個參數是不明類型,值是%v\n&amp;quot;, index+1, x)
		}
	}
}

func main() {
	var n1 float64 = 2.3
	var n2 int = 30
	var name string = &amp;quot;tom&amp;quot;
	n4 := 300

	TypeJudge(n1, n2, name, n4)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-interface/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>數組</title>
        <link>https://yoziming.github.io/post/210810-agg-go-array1/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-array1/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-array1/ -&lt;h1 id=&#34;數組&#34;&gt;數組&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	var n1 [3]int = [3]int{1, 2, 3}
	var n2 = [3]int{4, 5, 6}
	//長度聲明後就不能變化
	var n3 = [...]int{7, 8, 9}
	//數組長度是類型的一部分 [3]int != [4]int
	var n4 = [...]string{0: &amp;quot;李四&amp;quot;, 1: &amp;quot;張三&amp;quot;, 5: &amp;quot;王武&amp;quot;}
	n5 := []int{5, 5, 5, 5, 5}
	//[]int 這樣定義其實是切片

	fmt.Println(n1)
	fmt.Println(n2)
	fmt.Println(n3)
	fmt.Println(n4)
	fmt.Println(n5)

	n9 := fmt.Sprintf(&amp;quot;%.2f&amp;quot;, 9.888888)
	fmt.Println(n9)

	var score [5]float64
	for i := 0; i &amp;lt; len(score); i++ {
		fmt.Println(&amp;quot;輸入成績&amp;quot;)
		fmt.Scanln(&amp;amp;score[i])
	}
	for i := 0; i &amp;lt; len(score); i++ {
		fmt.Printf(&amp;quot;score[%d]=%v\n&amp;quot;, i, score[i])

	}
	arr := [3]int{11, 22, 33}
	fmt.Println(arr)
	test(&amp;amp;arr)
	fmt.Println(arr)

}

func test(a *[3]int) {
	a[0] = 88
	var arr4 = [3]string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}
	b := 3
	arr4[b] = &amp;quot;tom&amp;quot;
	fmt.Println(arr4)
}

&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;遍歷數組&#34;&gt;遍歷數組&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	arr1 := []int{1, 2, 3, 4, 5, 6, 7}
	for index, value := range arr1 {
		fmt.Printf(&amp;quot;index=%v,value=%v\n&amp;quot;, index, value)
	}
	for _, v := range arr1 {
		fmt.Printf(&amp;quot;%v&amp;quot;, v)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;應用練習&#34;&gt;應用練習&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	var az [26]byte
	for i := 0; i &amp;lt; len(az); i++ {
		az[i] = &#39;A&#39; + byte(i)
		fmt.Printf(&amp;quot;%c &amp;quot;, az[i])

	}

	var n1 = [...]int{1, 2, 6, 8, -5, 99, 44, 3, 0}
	max := n1[0]
	for i := 1; i &amp;lt; len(n1); i++ {
		if max &amp;lt; n1[i] {
			max = n1[i]
		}

	}
	fmt.Printf(&amp;quot;%v\n&amp;quot;, max)

	var n2 = [...]int{1, 2, 6, 8, -5, 99, 44, 3, 0}
	var sum int
	for _, v := range n2 {
		sum = sum + v
	}
	fmt.Printf(&amp;quot;和=%v\n&amp;quot;, sum)
	fmt.Printf(&amp;quot;平均=%v\n&amp;quot;, sum/len(n2))
	//我要保留平均的小數點
	fmt.Printf(&amp;quot;平均=%.2f\n&amp;quot;, float64(sum)/float64(len(n2)))

	//要求:隨機生成5個數字，並反轉後打印
	//思路:隨機 rand.Init()，放進數組，把數組反轉，打印

	var arr3 [5]int
	rand.Seed(time.Now().UnixNano())
	for i := 0; i &amp;lt; len(arr3); i++ {
		arr3[i] = rand.Intn(100) //0&amp;lt;=n&amp;lt;100
	}
	fmt.Println(arr3)
	//順序翻轉
	for i := 0; i &amp;lt; len(arr3)/2; i++ {
		arr3[i], arr3[len(arr3)-i-1] = arr3[len(arr3)-i-1], arr3[i]
	}
	fmt.Println(arr3)
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-array1/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>文字檔案讀取寫入</title>
        <link>https://yoziming.github.io/post/210810-agg-go-io-reader/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-io-reader/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-io-reader/ -&lt;h2 id=&#34;讀取&#34;&gt;讀取&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	//打開一個文件
	file, err := os.Open(&amp;quot;c:/test.txt&amp;quot;)
	//有人叫file對象/指針/文件句柄
	if err != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err)
	}
	//看看文件是啥
	fmt.Printf(&amp;quot;file=%v\n&amp;quot;, file)
	//退出函數就關閉文件
	defer file.Close()

	//創建一個帶緩衝的reader，預設大小是4096
	reader := bufio.NewReader(file)
	for {
		str, err := reader.ReadString(&#39;\n&#39;) //讀到換行就結束
		fmt.Print(str)
		if err == io.EOF { //表示文件末尾
			break
		}
	}
	fmt.Println(&amp;quot;\n讀取結束&amp;quot;)

	//用ioutil.ReadFile一次讀完
	//這個包已經封裝了open跟close了，只適用在檔案大小不大的情境
	file2 := &amp;quot;c:/test.txt&amp;quot;
	str2, err2 := ioutil.ReadFile(file2)
	if err2 != nil {
		fmt.Println(err)
	}
	fmt.Printf(&amp;quot;%s&amp;quot;, str2) //原本輸出是[]byte,用%s轉

	//創建一個新檔案，寫入5句話
	filePath := &amp;quot;c:/abc.txt&amp;quot;
	file3, err3 := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
	if err3 != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err3)
		return
	}
	defer file3.Close() //及時關閉文件
	str3 := &amp;quot;hello\r\n&amp;quot;
	writer3 := bufio.NewWriter(file3)
	for i := 0; i &amp;lt; 5; i++ {
		writer3.WriteString(str3)
	}
	writer3.Flush() //因為本來是存在buf區要把它實際寫出來

	//覆蓋一個檔案，寫入3句話
	filePath4 := &amp;quot;c:/abc2.txt&amp;quot;
	file4, err4 := os.OpenFile(filePath4, os.O_WRONLY|os.O_TRUNC, 0666)
	if err3 != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err4)
		return
	}
	defer file4.Close() //及時關閉文件
	str4 := &amp;quot;覆蓋\r\n&amp;quot;
	writer4 := bufio.NewWriter(file4)
	for i := 0; i &amp;lt; 3; i++ {
		writer4.WriteString(str4)
	}
	writer4.Flush() //因為本來是存在buf區要把它實際寫出來

	//打開一個檔案abc，追加寫入3句話
	file5, err4 := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666)
	if err3 != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err4)
		return
	}
	defer file5.Close() //及時關閉文件
	str5 := &amp;quot;追加\r\n&amp;quot;
	writer5 := bufio.NewWriter(file5)
	for i := 0; i &amp;lt; 3; i++ {
		writer5.WriteString(str5)
	}
	writer5.Flush() //因為本來是存在buf區要把它實際寫出來

	//打開一個檔案abc，讀取打印出來並追加寫入5句話
	file6, err4 := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, 0666)
	if err3 != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err4)
		return
	}
	//先讀取
	reader6 := bufio.NewReader(file6)
	for {
		str, err := reader6.ReadString(&#39;\n&#39;)
		if err == io.EOF { //如果讀到末尾
			break
		}
		fmt.Print(str)
	}
	defer file6.Close() //及時關閉文件
	str6 := &amp;quot;追加2BBB\r\n&amp;quot;
	writer6 := bufio.NewWriter(file6)
	for i := 0; i &amp;lt; 5; i++ {
		writer6.WriteString(str6)
	}
	writer6.Flush() //因為本來是存在buf區要把它實際寫出來

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;寫入&#34;&gt;寫入&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
func main() {
	//打開一個文件
	file, err := os.Open(&amp;quot;c:/test.txt&amp;quot;)
	//有人叫file對象/指針/文件句柄
	if err != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err)
	}
	//看看文件是啥
	fmt.Printf(&amp;quot;file=%v\n&amp;quot;, file)
	//退出函數就關閉文件
	defer file.Close()

	//創建一個帶緩衝的reader，預設大小是4096
	reader := bufio.NewReader(file)
	for {
		str, err := reader.ReadString(&#39;\n&#39;) //讀到換行就結束
		fmt.Print(str)
		if err == io.EOF { //表示文件末尾
			break
		}
	}
	fmt.Println(&amp;quot;\n讀取結束&amp;quot;)

	//用ioutil.ReadFile一次讀完
	//這個包已經封裝了open跟close了，只適用在檔案大小不大的情境
	file2 := &amp;quot;c:/test.txt&amp;quot;
	str2, err2 := ioutil.ReadFile(file2)
	if err2 != nil {
		fmt.Println(err)
	}
	fmt.Printf(&amp;quot;%s&amp;quot;, str2) //原本輸出是[]byte,用%s轉

	//創建一個新檔案，寫入5句話
	filePath := &amp;quot;c:/abc.txt&amp;quot;
	file3, err3 := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
	if err3 != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err3)
		return
	}
	defer file3.Close() //及時關閉文件
	str3 := &amp;quot;hello\r\n&amp;quot;
	writer3 := bufio.NewWriter(file3)
	for i := 0; i &amp;lt; 5; i++ {
		writer3.WriteString(str3)
	}
	writer3.Flush() //因為本來是存在buf區要把它實際寫出來

	//覆蓋一個檔案，寫入3句話
	filePath4 := &amp;quot;c:/abc2.txt&amp;quot;
	file4, err4 := os.OpenFile(filePath4, os.O_WRONLY|os.O_TRUNC, 0666)
	if err3 != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err4)
		return
	}
	defer file4.Close() //及時關閉文件
	str4 := &amp;quot;覆蓋\r\n&amp;quot;
	writer4 := bufio.NewWriter(file4)
	for i := 0; i &amp;lt; 3; i++ {
		writer4.WriteString(str4)
	}
	writer4.Flush() //因為本來是存在buf區要把它實際寫出來

	//打開一個檔案abc，追加寫入3句話
	file5, err4 := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666)
	if err3 != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err4)
		return
	}
	defer file5.Close() //及時關閉文件
	str5 := &amp;quot;追加\r\n&amp;quot;
	writer5 := bufio.NewWriter(file5)
	for i := 0; i &amp;lt; 3; i++ {
		writer5.WriteString(str5)
	}
	writer5.Flush() //因為本來是存在buf區要把它實際寫出來

	//打開一個檔案abc，讀取打印出來並追加寫入5句話
	file6, err4 := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, 0666)
	if err3 != nil {
		fmt.Println(&amp;quot;open file err=&amp;quot;, err4)
		return
	}
	//先讀取
	reader6 := bufio.NewReader(file6)
	for {
		str, err := reader6.ReadString(&#39;\n&#39;)
		if err == io.EOF { //如果讀到末尾
			break
		}
		fmt.Print(str)
	}
	defer file6.Close() //及時關閉文件
	str6 := &amp;quot;追加2BBB\r\n&amp;quot;
	writer6 := bufio.NewWriter(file6)
	for i := 0; i &amp;lt; 5; i++ {
		writer6.WriteString(str6)
	}
	writer6.Flush() //因為本來是存在buf區要把它實際寫出來

	//將c:/abc的內容導入到c:abc2

	fileAPath := &amp;quot;c:/abc.txt&amp;quot;
	fileBPath := &amp;quot;c:/abc2.txt&amp;quot;

	data, err9 := ioutil.ReadFile(fileAPath)
	if err9 != nil {
		fmt.Println(&amp;quot;文件讀取錯誤&amp;quot;, err9)
		return
	}
	err = ioutil.WriteFile(fileBPath, data, 0666)
	if err != nil {
		fmt.Println(&amp;quot;文件讀取錯誤&amp;quot;, err)
		return
	}

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-io-reader/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>文檔字符統計</title>
        <link>https://yoziming.github.io/post/210810-agg-go-txt/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-txt/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-txt/ -&lt;h1 id=&#34;文檔字符統計&#34;&gt;文檔字符統計&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//保存結果用
type CharCount struct {
	ChCount    int //英文字數
	NumCount   int //
	SpaceCount int
	OtherCount int
}

func main() {
	//思路 打開一個文件 創一個reader每讀取一行就去統計，將結果保存到一個結構體
	fileName := &amp;quot;c:/abc.txt&amp;quot;
	file, err := os.Open(fileName)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()
	//來個實例
	var count CharCount
	reader := bufio.NewReader(file)

	//開始讀取
	for {
		str, err := reader.ReadString(&#39;\n&#39;)
		//這存在BUG 當行不換行做結尾就統計不到
		if err == io.EOF {
			break
		}
		for _, v := range str {
			switch {
			case v &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;z&#39;:
				fallthrough
			case v &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;Z&#39;:
				count.ChCount++
			case v == &#39; &#39; || v == &#39;\t&#39;:
				count.SpaceCount++
			case v &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; v &amp;lt;= &#39;9&#39;:
				count.NumCount++
			default:
				count.OtherCount++
			}
		}
	}
	fmt.Printf(&amp;quot;字符=%v 數字=%v 空格=%v 其他=%v&amp;quot;,
		count.ChCount, count.NumCount, count.SpaceCount, count.OtherCount)

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-txt/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>日期時間</title>
        <link>https://yoziming.github.io/post/210810-agg-go-datetime/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-datetime/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-datetime/ -&lt;h1 id=&#34;日期時間&#34;&gt;日期時間&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	//1.獲取當前本地時間
	now := time.Now()
	fmt.Printf(&amp;quot;now=%v,type=%T&amp;quot;, now, now) //返回的類型是struct
	//2.通過now獲取各種詳細
	fmt.Printf(&amp;quot;年=%v,type=%T\n&amp;quot;, now.Year(), now.Year())
	fmt.Printf(&amp;quot;月=%v,type=%T\n&amp;quot;, now.Month(), now.Month())
	fmt.Printf(&amp;quot;月=%v,type=%T\n&amp;quot;, int(now.Month()), int(now.Month()))
	fmt.Printf(&amp;quot;日=%v,type=%T\n&amp;quot;, now.Day(), now.Day())
	fmt.Printf(&amp;quot;時=%v,type=%T\n&amp;quot;, now.Hour(), now.Hour())
	fmt.Printf(&amp;quot;分=%v,type=%T\n&amp;quot;, now.Minute(), now.Minute())
	fmt.Printf(&amp;quot;秒=%v,type=%T\n&amp;quot;, now.Second(), now.Second())
	fmt.Printf(&amp;quot;星期=%v,type=%T\n&amp;quot;, now.Weekday(), now.Weekday())
	fmt.Printf(&amp;quot;星期=%v\n&amp;quot;, int(now.Weekday()))
	//3.格式化日期時間
	dateStr := fmt.Sprintf(&amp;quot;年月日時分=%d-%d-%d %d:%d\n&amp;quot;, now.Year(), now.Month(),
		now.Day(), now.Minute(), now.Second())
	fmt.Println(dateStr)
	//4.蛋疼的指定格式
	fmt.Println(now.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;))
	fmt.Println(now.Format(&amp;quot;2006-01-02&amp;quot;))
	fmt.Println(now.Format(&amp;quot;06&amp;quot;))
	fmt.Println(now.Format(&amp;quot;01&amp;quot;))
	fmt.Println(now.Format(&amp;quot;03&amp;quot;))
	fmt.Println(now.Format(&amp;quot;01-02-06 03 04 05&amp;quot;))
	//123456=月日時分秒年
	//5.時間常量&amp;amp;休眠
	//每隔固定時間打印數字，打到100退出
	for i := 0; i &amp;lt;= 100; i++ {
		fmt.Println(i)
		time.Sleep(time.Millisecond)
	}
	//6.獲取時間戳unix unixNano
	fmt.Println(now.Unix())
	fmt.Println(now.UnixNano())

	//跑之前的時間
	start := now.Unix()
	test()
	end := now.Unix()
	fmt.Printf(&amp;quot;耗時%v&amp;quot;, end-start)
}

//7.統計函數執行時間
func test() {
	str := &amp;quot;&amp;quot;
	for i := 0; i &amp;lt; 100000; i++ {
		str = str + &amp;quot;hello&amp;quot; + strconv.Itoa(i)
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-datetime/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>結構體</title>
        <link>https://yoziming.github.io/post/210810-agg-go-struct/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-struct/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-struct/ -&lt;h1 id=&#34;結構體&#34;&gt;結構體&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Cat struct {
	Name  string
	Age   int
	Color string
	// S1    []int //可以是切片 但是預設值為nil(沒分配空間，一樣要先make後才能用)
}

//結構體是一個值類型，預設是值拷貝，比如cat1跟cat2是獨立存在兩個空間

func main() {
	//創建Cat的變量
	var cat1 Cat
	cat1.Name = &amp;quot;小花&amp;quot;
	cat1.Age = 18
	cat1.Color = &amp;quot;花&amp;quot;
	fmt.Println(&amp;quot;cat1=&amp;quot;, cat1)
	// cat1.S1 = make([]int, 10)
	// cat1.S1[0] = 100
	// fmt.Println(&amp;quot;cat1=&amp;quot;, cat1)

	//推薦方式
	cat2 := Cat{&amp;quot;小黑&amp;quot;, 5, &amp;quot;black&amp;quot;}
	fmt.Println(cat2)

	//方法3
	//var c *C=new(C)
	var cat3 *Cat = new(Cat)
	//因為cat3是一個指針
	(*cat3).Name = &amp;quot;小白&amp;quot;
	//語法糖 cat3.Age也可以 ，不建議
	cat3.Age = 6
	fmt.Println(*cat3)

	//方法4
	//var c *C=&amp;amp;C{}
	//因為c是一個指針 本來應該要用*...但是不用也行 草
	var cat4 *Cat = &amp;amp;Cat{&amp;quot;阿皇&amp;quot;, 0, &amp;quot;Yellow&amp;quot;}
	cat4.Name = &amp;quot;阿煌&amp;quot;
	(*cat4).Age = 1
	fmt.Println(*cat4)

	type Person struct {
		Name string `json:&amp;quot;name&amp;quot;`
		Age  int    `json:&amp;quot;age&amp;quot;`
	}

	p1 := Person{&amp;quot;aaa&amp;quot;, 10}
	fmt.Println(p1)
	var p2 *Person = &amp;amp;p1
	// fmt.Println(*p2.Age) //這樣寫會報錯。因為.的優先級比*高
	fmt.Println(p2.Age) //語法糖

	//用type重定義(類似於取別名)但是他會認為是2種類型
	type Per Person
	// var p3 Person = Person{&amp;quot;tommy&amp;quot;, 5}
	// var p4 Per
	// //p3=p4 //這樣會報錯
	// p4 = Per(p3) //這樣強轉
	// fmt.Println(p3, p4)
	fmt.Println(&amp;quot;--------------&amp;quot;)
	//struct的每個字段上可以寫一個tag，該tag可以通過反射機制獲取，常用於序列化
	pj := Per{&amp;quot;李四&amp;quot;, 44}
	jsonStr, err := json.Marshal(pj) //返回的是byte
	if err != nil {
		fmt.Println(&amp;quot;錯誤&amp;quot;)
	}
	fmt.Println(string(jsonStr)) //返回的是byte所以加一個string

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-struct/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>繼承</title>
        <link>https://yoziming.github.io/post/210810-agg-go-inherit/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-inherit/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-inherit/ -&lt;h1 id=&#34;繼承&#34;&gt;繼承&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Student struct {
	Name  string
	Age   int
	Score int
	//共有的字段
}

type Pupil struct {
	Student //套入
	Covid19 bool
}

type College struct {
	Student //套入指針效率更好
	SexExp  bool
}

func (stu *Student) ShowInfo() {
	fmt.Printf(&amp;quot;姓名=%v 年齡=%v 成績=%v\n&amp;quot;, stu.Name, stu.Age, stu.Score)
}

func (stu *Student) SetScore(s int) {
	stu.Score = s
}

func (p *Pupil) Test() {
	fmt.Println(&amp;quot;小學生考試&amp;quot;)
}

func main() {
	pupilA := &amp;amp;Pupil{}
	pupilA.Student.Name = &amp;quot;tome&amp;quot;
	pupilA.Student.Age = 8
	pupilA.Covid19 = true

	pupilA.Test()
	pupilA.Student.SetScore(66)
	pupilA.Student.ShowInfo()
	fmt.Println(&amp;quot;是否得肺炎&amp;quot;, pupilA.Covid19)

	C1 := College{}
	C1.Student.Name = &amp;quot;John&amp;quot;
	C1.Age = 23 //其實可以省略.Student
	C1.SexExp = false

	C1.Student.SetScore(39)
	C1.ShowInfo() //其實可以省略.Student
	fmt.Println(&amp;quot;是否破處&amp;quot;, C1.SexExp)

	//如果有低能把結構體跟匿名結構體用了相同的字段或方法，會採取就近訪問原則
	// 如果在一個結構中嵌入多個匿名結構，且匿名結構有同名的字段，那就必須指明匿名結構否則報錯

	//組合
	var d D
	d.a.Name = &amp;quot;xxxx&amp;quot; //有名字的結構體訪問時就要上完整名字
}

//組合
type D struct {
	a Student //有名字的結構體
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-inherit/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>錯誤處理</title>
        <link>https://yoziming.github.io/post/210810-agg-go-err/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-err/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-err/ -&lt;h1 id=&#34;錯誤處理&#34;&gt;錯誤處理&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;test&lt;/span&gt;() {
	&lt;span style=&#34;color:#228b22&#34;&gt;//捕捉異常
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;func&lt;/span&gt;() {
		&lt;span style=&#34;color:#228b22&#34;&gt;//內置函數recover就是找是否異常
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; err := &lt;span style=&#34;color:#658b00&#34;&gt;recover&lt;/span&gt;(); err != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt; { &lt;span style=&#34;color:#228b22&#34;&gt;//err不為空=有錯
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			fmt.&lt;span style=&#34;color:#008b45&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;錯誤&amp;#34;&lt;/span&gt;, err)
		}
	}()
	n1 := &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;
	n2 := &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
	res := n1 / n2
	fmt.&lt;span style=&#34;color:#008b45&#34;&gt;Println&lt;/span&gt;(res)
}

&lt;span style=&#34;color:#228b22&#34;&gt;//讀取文件名稱，錯誤就報錯
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;readConf&lt;/span&gt;(name &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt;) (err &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;error&lt;/span&gt;) {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; name == &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;config.ini&amp;#34;&lt;/span&gt; {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt;
	} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
		&lt;span style=&#34;color:#228b22&#34;&gt;//返回自訂錯誤
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; errors.&lt;span style=&#34;color:#008b45&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;文件錯誤&amp;#34;&lt;/span&gt;)
	}
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;test02&lt;/span&gt;() {
	err := &lt;span style=&#34;color:#008b45&#34;&gt;readConf&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;config.in564&amp;#34;&lt;/span&gt;)
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
		&lt;span style=&#34;color:#658b00&#34;&gt;panic&lt;/span&gt;(err)
	}
	fmt.&lt;span style=&#34;color:#008b45&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;02繼續執行...&amp;#34;&lt;/span&gt;)
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;() {
	&lt;span style=&#34;color:#008b45&#34;&gt;test&lt;/span&gt;()
	fmt.&lt;span style=&#34;color:#008b45&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;01繼續執行...&amp;#34;&lt;/span&gt;)
	&lt;span style=&#34;color:#008b45&#34;&gt;test02&lt;/span&gt;()
	fmt.&lt;span style=&#34;color:#008b45&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;03繼續執行...&amp;#34;&lt;/span&gt;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://yoziming.github.io/post/210810-agg-go-err/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>順序查找</title>
        <link>https://yoziming.github.io/post/210810-agg-go-sequential-search/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-sequential-search/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-sequential-search/ -&lt;h1 id=&#34;順序查找&#34;&gt;順序查找&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	names := [4]string{&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;}
	var input = &amp;quot;&amp;quot;
	fmt.Println(&amp;quot;輸入...&amp;quot;)
	fmt.Scanln(&amp;amp;input)
	//順序查找
	// for i := 0; i &amp;lt; len(names); i++ {
	// 	if input == names[i] {
	// 		fmt.Printf(&amp;quot;找到%v,下標=%v \n&amp;quot;, input, i)
	// 		break
	// 	} else if i == len(names)-1 {
	// 		fmt.Println(&amp;quot;比對失敗...&amp;quot;)
	// 	}

	//順序查找2
	index := -1
	for i := 0; i &amp;lt; len(names); i++ {
		if input == names[i] {
			index = i
			break
		}
	}
	if index != -1 {
		fmt.Printf(&amp;quot;找到%v,下標=%v \n&amp;quot;, input, index)
	} else {
		fmt.Println(&amp;quot;比對失敗...&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-sequential-search/ - yoziming</description>
        </item>
    
    
    
    
  </channel>
</rss> 