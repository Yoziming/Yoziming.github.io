<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>柚子茶室</title>
    <link>https://yoziming.github.io/</link>
    <description>Recent content on 柚子茶室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>yoziming</copyright>
    <lastBuildDate>Wed, 29 Dec 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yoziming.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>迷宮遞迴</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/ -&lt;h1 id=&#34;迷宮遞迴&#34;&gt;迷宮遞迴&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func SetWay(myMap *[8][7]int, a int, b int) bool {
	//a,b 表示對地圖的那個點測試

	//找到出口
	if myMap[6][5] == 2 {
		return true
	} else {
		//繼續找
		if myMap[a][b] == 0 { //可探測的點
			myMap[a][b] = 2            //踩上去了，再探上下左右，但是我知道要往下往右探
			if SetWay(myMap, a+1, b) { //下
				return true
			} else if SetWay(myMap, a, b+1) { //右
				return true
			} else if SetWay(myMap, a-1, b) { //上
				return true
			} else if SetWay(myMap, a, b-1) { //左
				return true
			} else { //死路
				myMap[a][b] = 3
				return false
			}
		} else { //不可探測的點
			return false
		}
	}
}
func main() {
	//定義地圖 1=牆壁 0=沒走過的點 2=通路 3=走過的死路
	var myMap [8][7]int

	//四周設置圍牆
	for i := 0; i &amp;lt; 7; i++ {
		myMap[0][i] = 1
		myMap[7][i] = 1
	}
	for i := 0; i &amp;lt; 8; i++ {
		myMap[i][0] = 1
		myMap[i][6] = 1
	}
	myMap[3][1] = 1
	myMap[3][2] = 1

	//看樣子
	for i := 0; i &amp;lt; 8; i++ {
		for j := 0; j &amp;lt; 7; j++ {
			fmt.Print(myMap[i][j], &amp;quot; &amp;quot;)
		}
		fmt.Println()
	}

	SetWay(&amp;amp;myMap, 1, 1)
	fmt.Println(&amp;quot;已探完&amp;quot;)

	for i := 0; i &amp;lt; 8; i++ {
		for j := 0; j &amp;lt; 7; j++ {
			fmt.Print(myMap[i][j], &amp;quot; &amp;quot;)
		}
		fmt.Println()
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-%E8%BF%B7%E5%AE%AE%E9%81%9E%E8%BF%B4/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>雙向鏈表</title>
        <link>https://yoziming.github.io/post/210815-agg-go-al-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-agg-go-al-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210815-agg-go-al-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/ -&lt;h1 id=&#34;雙向鏈表&#34;&gt;雙向鏈表&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type HeroNode struct {
	no   int
	name string
	pre  *HeroNode //表示指向前一個節點
	next *HeroNode //表示指向下一個節點
}

//給鏈表插入節點
func Insert(head *HeroNode, newHeroNode *HeroNode) {
	//先找到最後的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		}
		temp = temp.next //不斷往下找
	}
	//把newHeroNode加到屁股
	temp.next = newHeroNode
	newHeroNode.pre = temp
}

//根據No從小到大插入
func InsertNo(head *HeroNode, newHeroNode *HeroNode) {
	//想找到適當的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		} else if temp.next.no &amp;gt; newHeroNode.no {
			//表示new要插到temp後
			break
		} else if temp.next.no == newHeroNode.no {
			//表示new這個編號已存在
			fmt.Println(newHeroNode.no, &amp;quot;該編號已存在&amp;quot;)
			return
		}
		temp = temp.next //不斷往下找

	}
	//把newHeroNode加到找到的地方
	newHeroNode.next = temp.next
	newHeroNode.pre = temp
	if temp.next != nil {
		temp.next.pre = newHeroNode //temp的下一個的前一個=新
	}
	temp.next = newHeroNode
}

//根據no刪除一個節點
func DelHeroNode(head *HeroNode, id int) {
	//想找到適當的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		} else if temp.next.no == id {
			//表示找到了
			fmt.Println(id, &amp;quot;該編號已刪除&amp;quot;)
			temp.next = temp.next.next
			if temp.next != nil {
				temp.next.pre = temp
			}
			return
		}
		temp = temp.next //不斷往下找
	}

}

//顯示
func List(head *HeroNode) {
	//創建一個輔助
	temp := head
	if temp.next == nil { //空鏈表?
		fmt.Println(&amp;quot;空&amp;quot;)
		return
	}
	for {
		fmt.Printf(&amp;quot;[%d,%s]==&amp;gt;&amp;quot;, temp.next.no, temp.next.name)
		temp = temp.next      //不斷往下找
		if temp.next == nil { //到尾了
			fmt.Println(&amp;quot;完畢&amp;quot;)
			break
		}
	}
}

func main() {
	//創建一個頭節點(空的)
	head := &amp;amp;HeroNode{}
	hero1 := &amp;amp;HeroNode{
		no:   1,
		name: &amp;quot;宋江&amp;quot;,
	}
	hero2 := &amp;amp;HeroNode{
		no:   2,
		name: &amp;quot;李奎&amp;quot;,
	}
	hero3 := &amp;amp;HeroNode{
		no:   3,
		name: &amp;quot;李軌&amp;quot;,
	}
	InsertNo(head, hero3)
	InsertNo(head, hero1)
	InsertNo(head, hero2)

	List(head)
	DelHeroNode(head, 3)
	List(head)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-agg-go-al-%E9%9B%99%E5%90%91%E9%8F%88%E8%A1%A8/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>channel通道</title>
        <link>https://yoziming.github.io/post/210810-agg-go-channel/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-channel/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-channel/ -&lt;h1 id=&#34;channel通道&#34;&gt;channel通道&lt;/h1&gt;
&lt;h2 id=&#34;lock-sync與chan基本認識&#34;&gt;lock sync與chan基本認識&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//階乘1-n 把各個數放到map中 用goroutine完成
var (
	myMap = make(map[int]int, 10)
	//聲明一個全局的互斥鎖
	lock sync.Mutex
	//來點管道 記得要make初始化才能用
	intChan chan int = make(chan int, 3)

	//聲明類型為空接口可以接收任意類型
	allChan chan interface{} = make(chan interface{}, 5)
	//注意後面沒聲明容量則不給用
)

type Cat struct {
	Name string
	Age  int
}

func test(n int) {
	res := 1
	for i := 1; i &amp;lt;= n; i++ {
		res = res * i
	}
	//把res放進mayMap
	//加鎖
	lock.Lock()
	myMap[n] = res
	//解鎖
	lock.Unlock()
}

func main() {
	//啟用多個協程
	for i := 1; i &amp;lt;= 1; i++ {
		go test(i)
	}
	//如果不加鎖concurrent map iteration and map write
	lock.Lock()
	for i, v := range myMap {
		fmt.Printf(&amp;quot;map[%d]=%v\n&amp;quot;, i, v)
	}
	lock.Unlock()

	//看看管道
	fmt.Println(intChan)
	//出來是一個地址，表示誰要經過這 (當然本身也有一個地址但不重要)
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))

	//向管道寫入數據
	intChan &amp;lt;- 10
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))
	num1 := 5
	intChan &amp;lt;- num1
	intChan &amp;lt;- 1
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))
	//intChan &amp;lt;- 12 //超過3個太長報錯

	//從管道取數據
	var num2 int = &amp;lt;-intChan
	fmt.Println(num2)
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))
	//先進先出，取完超過一樣報錯
	num3 := &amp;lt;-intChan
	fmt.Println(num3)
	fmt.Printf(&amp;quot;長度=%v 容量=%v\n&amp;quot;, len(intChan), cap(intChan))

	//關於allChan
	allChan &amp;lt;- 10
	allChan &amp;lt;- &amp;quot;ABC&amp;quot;
	cat1 := Cat{&amp;quot;小花&amp;quot;, 3}
	allChan &amp;lt;- cat1
	//可以亂塞一通

	//想拿到第三個元素 先把兩個推出來
	&amp;lt;-allChan
	&amp;lt;-allChan

	newCat := &amp;lt;-allChan //從管道中取出來的cat1
	fmt.Printf(&amp;quot;類型=%T 值=%v\n&amp;quot;, newCat, newCat)
	// fmt.Printf(&amp;quot;%v\n&amp;quot;, newCat.Name) //雖然類型一樣但這樣用不通過
	//必須類型斷言
	a := newCat.(Cat)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, a.Name)

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;只讀或寫&#34;&gt;只讀或寫&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	//chan可以只讀或只寫
	// chan1 chan int //可讀可寫
	var chan2 chan&amp;lt;- int = make(chan int, 3) //只寫
	chan2 &amp;lt;- 20
	// num:=&amp;lt;-chan2//報錯
	fmt.Println(chan2)

	var chan3 &amp;lt;-chan int = make(chan int, 3)
	num2 := &amp;lt;-chan3
	fmt.Println(num2)
	chan3 &amp;lt;- 10 //報錯
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;遍歷chan&#34;&gt;遍歷chan&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	//用close關掉channel就不能往內加(但是可以拿出)
	var intChan chan int = make(chan int, 3)
	intChan &amp;lt;- 100
	intChan &amp;lt;- 200
	close(intChan)
	// intChan &amp;lt;- 300 //錯誤
	n1 := &amp;lt;-intChan
	fmt.Println(n1)

	//遍歷
	intChan2 := make(chan int, 100)
	for i := 0; i &amp;lt; 100; i++ {
		intChan2 &amp;lt;- i * 2 //放100個數據(2,4,6...進去)
	}
	//得用for:=range用一般for遍歷會報錯
	//如果已經close遍歷完就會自動停止，如果沒有先關掉會deadlock
	close(intChan2)
	for v := range intChan2 {
		fmt.Println(v)
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;阻塞&#34;&gt;阻塞&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func writeData(intChan chan int) {
	for i := 1; i &amp;lt;= 50; i++ {
		intChan &amp;lt;- i
		fmt.Printf(&amp;quot;writeData=%v\n&amp;quot;, i)
		// time.Sleep(time.Second / 1000)
	}
	close(intChan) //寫完就關
}
func readData(intChan chan int, exitChan chan bool) {
	for {
		v, ok := &amp;lt;-intChan
		// time.Sleep(time.Second / 1000)
		if !ok {
			break
		}
		fmt.Printf(&amp;quot;readData讀取到數據=%v\n&amp;quot;, v)
	}
	//讀取完=任務完成 其實這裡不管對exitChan做啥都無所謂，重點是有調用他就能阻塞main
	exitChan &amp;lt;- true
	close(exitChan)
}

func main() {

	intChan := make(chan int, 5)
	//即使管道小 寫的慢讀得快或相反，他會排隊，重點不要阻塞死鎖就能繼續
	exitChan := make(chan bool, 1)

	go writeData(intChan)
	go readData(intChan, exitChan)
	if &amp;lt;-exitChan { //重點就是這個判斷調用到一個管道有跨到子函數的就能阻塞住main
		fmt.Println(&amp;quot;任務完成&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;用select解決阻塞&#34;&gt;用select解決阻塞&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func sayH() {
	for i := 0; i &amp;lt; 10; i++ {
		time.Sleep(time.Second / 10)
		fmt.Println(&amp;quot;hello&amp;quot;)
	}
}

func test() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(&amp;quot;test錯誤&amp;quot;, err)
		}
	}()
	myMap := make(map[int]string)
	myMap[0] = &amp;quot;我家&amp;quot;
	fmt.Println(myMap)
}

func main() {

	go sayH()
	go test()
	fmt.Println(&amp;quot;hellom&amp;quot;)

	intChan := make(chan int, 10)
	for i := 0; i &amp;lt; 10; i++ {
		intChan &amp;lt;- i
	}

	stringChan := make(chan string, 5)
	for i := 0; i &amp;lt; 5; i++ {
		stringChan &amp;lt;- &amp;quot;hello&amp;quot; + fmt.Sprintf(&amp;quot;%d&amp;quot;, i)
	}
	//傳統方法遍歷，如果不關閉會阻塞 就導致deadlock
	//實際開發不好確定哪時候關閉，就用select解決
	for {
		select {
		//就算沒關閉，只要阻塞他就往其他case移動
		case v := &amp;lt;-intChan:
			fmt.Printf(&amp;quot;intChan取出%d\n&amp;quot;, v)
		case v := &amp;lt;-stringChan:
			fmt.Printf(&amp;quot;stringChan取出%s\n&amp;quot;, v)
		default:
			fmt.Println(&amp;quot;取完了&amp;quot;)
			return
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-channel/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>const常量</title>
        <link>https://yoziming.github.io/post/210810-agg-go-const/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-const/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-const/ -&lt;h1 id=&#34;const常量&#34;&gt;const常量&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;常量 聲明時必須賦值、不能修改、只能是bool、數值、string，賦值需是一個確定的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	const tax int = 10
	const x = 9 / 3
	// const c = 9 / a //因為a可能是一個變量所以這樣不行
	// var a int = 3
	fmt.Println(tax, x)

	const (
		a = iota //表示a=0
		b        //b=a+1
		c        //c=b+1
	)
	fmt.Println(a, b, c)

	const (
		d = iota
		e
		f, g = iota, iota
	)
	fmt.Println(d, e, f, g)

	//其他程式語言常量會用全大寫，go中沒限制，且一樣用首字母大小來控制使用範圍
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-const/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>defer臨走前啟用</title>
        <link>https://yoziming.github.io/post/210810-agg-go-defer/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-defer/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-defer/ -&lt;h1 id=&#34;defer臨走前啟用&#34;&gt;defer臨走前啟用&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;退出函數前才執行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func sum(n1, n2 int) int {
	defer fmt.Println(&amp;quot;ok1&amp;quot;, n1)
	defer fmt.Println(&amp;quot;ok2&amp;quot;, n2)
	//defer棧先入後出
	n1++
	n2++
	res := n1 + n2
	fmt.Println(&amp;quot;ok3 res=&amp;quot;, res)
	return res

}
func main() {
	res := sum(10, 20)
	fmt.Println(&amp;quot;res=&amp;quot;, res)

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-defer/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>goroutine</title>
        <link>https://yoziming.github.io/post/210810-agg-go-goroutine/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-goroutine/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-goroutine/ -&lt;h1 id=&#34;goroutine&#34;&gt;goroutine&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;進程=程序在操作系統中的一次進行過程&lt;/p&gt;
&lt;p&gt;線程=執行實例的最小單位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一個進程可以創建多個線程且併發執行&lt;/li&gt;
&lt;li&gt;一個程序至少包含一個進程，一個進程至少包含一個線程&lt;/li&gt;
&lt;li&gt;併發=多線程程序在單核上運行&lt;/li&gt;
&lt;li&gt;併行=多線程程序在多核上運行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GO的主線程(可以理解為進程)，一個GO進程上可以起很多協程，協程可以理解為輕量級的線程，協程特點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有獨立的棧空間&lt;/li&gt;
&lt;li&gt;共享程序堆空間&lt;/li&gt;
&lt;li&gt;調度由用戶控制&lt;/li&gt;
&lt;li&gt;為輕量級的線程&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func test() {
	for i := 0; i &amp;lt; 10; i++ {
		fmt.Println(&amp;quot;test()Hello,world&amp;quot; + strconv.Itoa(i))
		time.Sleep(time.Second / 10)
	}
}

func main() {
	go test() //開啟一個協程
	//如果主線程退出了，即使協程還沒執行完，也會退出
	//協程可以自己先結束
	for i := 0; i &amp;lt; 10; i++ {
		fmt.Println(&amp;quot;main()Hello,go&amp;quot; + strconv.Itoa(i))
		time.Sleep(time.Second / 10)
	}
	go test() //開啟一個協程，主線程退出了，即使協程還沒執行完，也會退出

	//查邏輯CPU數量
	cpuNum := runtime.NumCPU()
	fmt.Println(cpuNum)
	//設置最大線程數量
	runtime.GOMAXPROCS(cpuNum)

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-goroutine/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>Go使用mysql與事務操作</title>
        <link>https://yoziming.github.io/post/210810-agg-go-mysql/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-mysql/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-mysql/ -&lt;h1 id=&#34;go使用mysql與事務操作&#34;&gt;Go使用mysql與事務操作&lt;/h1&gt;
&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;fmt&amp;quot;

	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

var db *sql.DB // 是一個連接池對象

// user 接收數據
type user struct {
	id   int
	name string
	age  int
}

func initDB() (err error) {
	dsn := &amp;quot;root:root@tcp(127.0.0.1:3306)/sql_test&amp;quot;
	db, err = sql.Open(&amp;quot;mysql&amp;quot;, dsn) // 這個db要用全局的，重要!
	if err != nil {
		return
	}
	err = db.Ping()
	if err != nil {
		return
	} else {
		fmt.Println(&amp;quot;連接成功&amp;quot;)
	}
	return
}

// 查詢一個
func find1() {
	var u1 user
	sqlStr := `select id, name, age from user where id=?;`
	rowObj := db.QueryRow(sqlStr, 1)
	err := rowObj.Scan(&amp;amp;u1.id, &amp;amp;u1.name, &amp;amp;u1.age)
	if err != nil {
		fmt.Println(&amp;quot;Scan failed!&amp;quot;, err)
		return
	}
	fmt.Println(u1)
}

// findMore 查詢多個
func findMore() {
	sqlStr := `select id, name, age from user where id &amp;gt; ?;`
	rows, _ := db.Query(sqlStr, 0)
	defer rows.Close()

	for rows.Next() {
		var u user
		err := rows.Scan(&amp;amp;u.id, &amp;amp;u.name, &amp;amp;u.age)
		if err != nil {
			return
		}
		fmt.Println(u)
	}
}

func update(newAge int, id int) {
	sqlStr := &amp;quot;update user set age=? where id = ?&amp;quot;
	ret, err := db.Exec(sqlStr, newAge, id)
	if err != nil {
		fmt.Println(err)
		return
	}
	n, err := ret.RowsAffected()
	if err != nil {
		return
	}
	fmt.Println(&amp;quot;更新了&amp;quot;, n, &amp;quot;行數據&amp;quot;)
}

func delete(id int) {
	sqlStr := &amp;quot;delete from user where id = ?&amp;quot;
	ret, err := db.Exec(sqlStr, id)
	if err != nil {
		fmt.Println(err)
		return
	}
	n, err := ret.RowsAffected()
	if err != nil {
		return
	}
	fmt.Println(&amp;quot;更新了&amp;quot;, n, &amp;quot;行數據&amp;quot;)
}

func main() {
	err := initDB()
	if err != nil {
		fmt.Println(&amp;quot;init DB failed&amp;quot;, err)
	}

	preInsert()
	// findMore()
	// update(90, 2)
	// delete(2)
	findMore()
}

func insert() {
	sqlStr := `insert into user(name, age) values(&amp;quot;AAC&amp;quot;, 18)`
	ret, err := db.Exec(sqlStr)
	if err != nil {
		fmt.Println(&amp;quot;insert failed!&amp;quot;, err)
		return
	}
	// 插入後能拿到對應的ID
	id, _ := ret.LastInsertId()
	fmt.Println(&amp;quot;id=&amp;quot;, id)
}

func preInsert() {
	sqlStr := &amp;quot;insert into user(name, age) values(?,?)&amp;quot;
	stmt, err := db.Prepare(sqlStr)
	if err != nil {
		return
	}
	defer stmt.Close()
	for i := 1; i &amp;lt; 10; i++ {
		_, _ = stmt.Exec(&amp;quot;人物&amp;quot;, i)

	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;mysql事務操作&#34;&gt;mysql事務操作&lt;/h3&gt;
&lt;p&gt;事務：一個最小的不可再分的工作單元；通常一個事務對應一個完整的業務(例如銀行帳戶轉帳業務，該業務就是一個最小的工作單元)，同時這個完整的業務需要執行多次的DML(insert、update、delete)語句共同聯合完成。A轉帳給B，這裡面就需要執行兩次update操作。在MySQL中只有使用了Innodb資料庫引擎的資料庫或表才支援事務。交易處理可以用來維護資料庫的完整性，保證成批的SQL語句要麼全部執行，要麼全部不執行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事務的ACID&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常事務必須滿足4個條件（ACID）：原子性（Atomicity，或稱不可分割性）、一致性（Consistency）、隔離性（Isolation，又稱獨立性）、持久性（Durability）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原子性 一個事務（transaction）中的所有操作，要麼全部完成，要麼全部不完成，不會結束在中間某個環節。事務在執行過程中發生錯誤，會被回滾（Rollback）到事務開始前的狀態，就像這個事務從來沒有執行過一樣。&lt;/li&gt;
&lt;li&gt;一致性 在事務開始之前和事務結束以後，資料庫的完整性沒有被破壞。這表示寫入的資料必須完全符合所有的預設規則，這包含資料的精確度、串聯性以及後續資料庫可以自發性地完成預定的工作。&lt;/li&gt;
&lt;li&gt;隔離性 資料庫允許多個併發事務同時對其資料進行讀寫和修改的能力，隔離性可以防止多個事務併發執行時由於交叉執行而導致資料的不一致。事務隔離分為不同級別，包括讀未提交（Read uncommitted）、讀提交（read committed）、可重複讀（repeatable read）和序列化（Serializable）。&lt;/li&gt;
&lt;li&gt;持久性 交易處理結束後，對資料的修改就是永久的，即便系統故障也不會丟失。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;fmt&amp;quot;

	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

var db *sql.DB // 是一個連接池對象

// user 接收數據
type user struct {
	id   int
	name string
	age  int
}

func initDB() (err error) {
	dsn := &amp;quot;root:root@tcp(127.0.0.1:3306)/sql_test&amp;quot;
	db, err = sql.Open(&amp;quot;mysql&amp;quot;, dsn) // 這個db要用全局的，重要!
	if err != nil {
		return
	}
	err = db.Ping()
	if err != nil {
		return
	} else {
		fmt.Println(&amp;quot;連接成功&amp;quot;)
	}
	return
}

func transaction() {
	tx, err := db.Begin()
	if err != nil {
		fmt.Println(&amp;quot;begin failed!&amp;quot;, err)
		return
	}

	sqlStr1 := &amp;quot;update user set age=age-2 where id=1&amp;quot;
	sqlStr2 := &amp;quot;update user set age=age+2 where id=3&amp;quot;
	ret1, err := tx.Exec(sqlStr1)
	if err != nil {
		tx.Rollback()
		return
	}
	affRow1, err := ret1.RowsAffected()
	if err != nil {
		tx.Rollback()
		return
	}
	ret2, err := tx.Exec(sqlStr2)
	if err != nil {
		tx.Rollback()
		return
	}
	affRow2, err := ret2.RowsAffected()
	if err != nil {
		tx.Rollback()
		return
	}
	fmt.Println(affRow1, affRow2)
	if affRow1 == 1 &amp;amp;&amp;amp; affRow2 == 1 {
		tx.Commit()
		fmt.Println(&amp;quot;已提交&amp;quot;)
	} else {
		tx.Rollback()
	}

}

func findMore() {
	sqlStr := `select id, name, age from user where id &amp;gt; ?;`
	rows, _ := db.Query(sqlStr, 0)
	defer rows.Close()

	for rows.Next() {
		var u user
		err := rows.Scan(&amp;amp;u.id, &amp;amp;u.name, &amp;amp;u.age)
		if err != nil {
			return
		}
		fmt.Println(u)
	}
}

func main() {

	initDB()
	findMore()
	transaction()
	findMore()
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-mysql/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>JSON序列化</title>
        <link>https://yoziming.github.io/post/210810-agg-go-json/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-json/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-json/ -&lt;h1 id=&#34;json序列化&#34;&gt;JSON序列化&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;JSON 格式 {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;}  {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:&amp;ldquo;值2&amp;rdquo;} {&amp;ldquo;鍵&amp;rdquo;:&amp;ldquo;值&amp;rdquo;,&amp;ldquo;鍵2&amp;rdquo;:[&amp;ldquo;值2數組&amp;rdquo;,值2數組]}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Monster struct {
	Name string  `json:&amp;quot;name&amp;quot;` //反射機制
	Age  int     `json:&amp;quot;age&amp;quot;`
	Sal  float64 `json:&amp;quot;sal&amp;quot;`
}

func test1() {
	monster1 := Monster{
		Name: &amp;quot;牛魔王&amp;quot;,
		Age:  50,
		Sal:  8000.0,
	}
	data, err := json.Marshal(&amp;amp;monster1)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(data))
}

//把map序列化
func testMap() {
	var mapA map[string]interface{} = make(map[string]interface{})
	mapA[&amp;quot;name&amp;quot;] = &amp;quot;紅孩兒&amp;quot;
	mapA[&amp;quot;age&amp;quot;] = 18
	data, err := json.Marshal(&amp;amp;mapA)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(data))

}

//切片序列化
func testSlice() {
	var slice1 []map[string]interface{}
	var m1 map[string]interface{} = make(map[string]interface{})
	m1[&amp;quot;name&amp;quot;] = &amp;quot;珍娜&amp;quot;
	m1[&amp;quot;age&amp;quot;] = 40
	slice1 = append(slice1, m1)
	var m2 map[string]interface{} = make(map[string]interface{})
	m2[&amp;quot;name&amp;quot;] = &amp;quot;索爾&amp;quot;
	m2[&amp;quot;age&amp;quot;] = 25
	slice1 = append(slice1, m2)
	data, err := json.Marshal(slice1)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(data))

}

//基本數據類型序列化，沒啥意義 因為他沒有key 就只會轉出一個string
func testFloat64() {
	var num1 float64 = 123.45
	data, err := json.Marshal(num1)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(data))

}

//反序列化
func unmarshal() {
	str := `{&amp;quot;name&amp;quot;:&amp;quot;牛魔王&amp;quot;,&amp;quot;age&amp;quot;:50,&amp;quot;sal&amp;quot;:8000}`
	//用`...`包起來保留原格式

	//定義一個實例來接收 這個接收的格式一定要能符合對應
	var heroes Monster
	err := json.Unmarshal([]byte(str), &amp;amp;heroes)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(heroes)
}
func unmarshalMap() {
	str := `{&amp;quot;age&amp;quot;:18,&amp;quot;name&amp;quot;:&amp;quot;紅孩兒&amp;quot;}`
	var a map[string]interface{}
	//不用make因為unmarshal函數內封裝了
	err := json.Unmarshal([]byte(str), &amp;amp;a)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(a)
}

func main() {
	test1()
	testMap()
	testSlice()
	testFloat64()
	unmarshal()
	unmarshalMap()
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-json/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>Map集合</title>
        <link>https://yoziming.github.io/post/210810-agg-go-map/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-map/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-map/ -&lt;h1 id=&#34;map集合&#34;&gt;Map集合&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	// map[key類型] value類型
	var m1 map[int]int = make(map[int]int)

	//key類型通常是int or string
	//value 通常是數字 or string or map or struct
	//只聲明不會給內存，要make才初始化才能用(跟切片一樣)
	m1[1] = 100
	m1[2] = 200
	m1[3] = 300
	m1[1] = 1000
	//key不能重複，後賦予的頂掉前面
	fmt.Println(m1)

	var m2 = make(map[string]string)
	m2[&amp;quot;AV&amp;quot;] = &amp;quot;sss&amp;quot;
	fmt.Println(m2)

	//推薦寫法
	m3 := make(map[string]string)
	m3[&amp;quot;一號&amp;quot;] = &amp;quot;台北&amp;quot;
	m3[&amp;quot;二奧&amp;quot;] = &amp;quot;桃園&amp;quot;
	fmt.Println(m3)

	m4 := map[int]int{1: 10, 2: 20, 3: 30}
	fmt.Println(m4)

	//學生姓名+性別
	m5 := make(map[string](map[string]string))
	m5[&amp;quot;stu01&amp;quot;] = make(map[string]string) //不能少
	m5[&amp;quot;stu01&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;tom&amp;quot;
	m5[&amp;quot;stu01&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;男&amp;quot;
	m5[&amp;quot;stu02&amp;quot;] = make(map[string]string) //不能少
	m5[&amp;quot;stu02&amp;quot;][&amp;quot;name&amp;quot;] = &amp;quot;mary&amp;quot;
	m5[&amp;quot;stu02&amp;quot;][&amp;quot;sex&amp;quot;] = &amp;quot;女&amp;quot;
	fmt.Println(m5)
	fmt.Println(m5[&amp;quot;stu01&amp;quot;])
	fmt.Println(m5[&amp;quot;stu01&amp;quot;][&amp;quot;sex&amp;quot;])

	var m6 = make(map[int]int)
	m6[1] = 10
	m6[2] = 20
	delete(m6, 1) //delete=刪除key
	delete(m6, 3) //delete空的東西也不會報錯
	//沒有辦法把key全刪除，要就用遍歷
	fmt.Println(m6)
	//重新分配一次=清空，但是格式要跟本來一樣
	m6 = make(map[int]int)
	fmt.Println(m6)

	//查找
	var m7 = make(map[int]int)
	m7[1] = 111
	m7[2] = 222
	val, ok := m7[2] //把一個map中的一個key賦給a,b 其中a=value b=bool(是否存在)
	fmt.Println(val, ok)
	if ok {
		fmt.Printf(&amp;quot;m7存在key&#39;1&#39;且值為%v\n&amp;quot;, val)
	} else {
		fmt.Printf(&amp;quot;m7不存在key&#39;n&#39;\n&amp;quot;)
	}

	//遍歷
	//因為map裡面的key-value不一定是連續的數字，所以不能用for而要用for:=range
	//m5 := make(map[string](map[string]string))

	for k, v := range m5 {
		fmt.Printf(&amp;quot;k=%v \n&amp;quot;, k)
		for k2, v2 := range v {
			fmt.Printf(&amp;quot;	k2=%v v=%v \n&amp;quot;, k2, v2)
		}

	}

	//長度=有幾對
	m8 := map[int]int{1: 10, 2: 20, 3: 30}
	fmt.Println(len(m8))

	//map切片
	//使用一個map來記錄monster的name跟age，且monster數量可以動態變化

	var mon []map[string]string = make([]map[string]string, 2)
	if mon[0] == nil {
		mon[0] = make(map[string]string, 2)
		mon[0][&amp;quot;name&amp;quot;] = &amp;quot;牛魔王&amp;quot;
		mon[0][&amp;quot;age&amp;quot;] = &amp;quot;500&amp;quot;
	}
	if mon[1] == nil {
		mon[1] = make(map[string]string, 2)
		mon[1][&amp;quot;name&amp;quot;] = &amp;quot;玉兔&amp;quot;
		mon[1][&amp;quot;age&amp;quot;] = &amp;quot;300&amp;quot;
	}

	// if mon[2] == nil {
	// 	mon[2] = make(map[string]string, 2)
	// 	mon[2][&amp;quot;name&amp;quot;] = &amp;quot;111&amp;quot;
	// 	mon[2][&amp;quot;age&amp;quot;] = &amp;quot;3440&amp;quot;
	// } //這樣寫越界
	//用append 先定義monster信息
	newMon := map[string]string{
		&amp;quot;name&amp;quot;: &amp;quot;新妖怪&amp;quot;,
		&amp;quot;age&amp;quot;:  &amp;quot;200&amp;quot;,
	}
	mon = append(mon, newMon)

	fmt.Println(mon)

	//用結構體更好，例如學號是唯一
	type Stu struct {
		Name    string
		Age     int
		Address string
	}
	stumaps := make(map[string]Stu)
	//創建學生
	stu1 := Stu{&amp;quot;tom&amp;quot;, 18, &amp;quot;經&amp;quot;}
	stu2 := Stu{&amp;quot;mary&amp;quot;, 50, &amp;quot;KJH&amp;quot;}
	stumaps[&amp;quot;no1&amp;quot;] = stu1
	stumaps[&amp;quot;no2&amp;quot;] = stu2
	fmt.Println(stumaps)
	//遍歷
	for k, v := range stumaps {
		fmt.Printf(&amp;quot;學號=%v\n&amp;quot;, k)
		fmt.Printf(&amp;quot;	姓名=%v\n&amp;quot;, v.Name)
		fmt.Printf(&amp;quot;	年紀=%v\n&amp;quot;, v.Age)
		fmt.Printf(&amp;quot;	住址=%v\n&amp;quot;, v.Address)
	}

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-map/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>new與make的區別</title>
        <link>https://yoziming.github.io/post/210810-agg-go-newmake/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-newmake/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-newmake/ -&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	num1 := 100
	fmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num1, num1, &amp;amp;num1)
	num2 := new(int) //*int
	fmt.Printf(&amp;quot;類型=%T,值=%v,地址=%v\n&amp;quot;, num2, num2, &amp;amp;num2)

	//new用來分配類型
	//make用來分配內存
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-newmake/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>Redis基本操作</title>
        <link>https://yoziming.github.io/post/210810-agg-go-redis/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-redis/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-redis/ -&lt;h1 id=&#34;redis基本操作&#34;&gt;Redis基本操作&lt;/h1&gt;
&lt;p&gt;0.啟動cmd&amp;gt;redis-cli&lt;/p&gt;
&lt;p&gt;1.數據結構類似JSON都是Key-Value&lt;/p&gt;
&lt;p&gt;2.五大數據類型String、Hash、List、Set、Zset&lt;/p&gt;
&lt;p&gt;2-1.String:最基本的字串，value最大值=512M&lt;/p&gt;
&lt;p&gt;指令:set(如果存在就相當於修改)、get、del (很多指令可以用tab協助完成)&lt;/p&gt;
&lt;p&gt;setex(幾秒後自毀)&lt;/p&gt;
&lt;p&gt;2-2.Hash:類似於Map&lt;/p&gt;
&lt;p&gt;指令:hset key field value、hget、hdel&lt;/p&gt;
&lt;p&gt;一次設多項(空格隔開)hmset、hmget&lt;/p&gt;
&lt;p&gt;hlen:統計有幾個元素&lt;/p&gt;
&lt;p&gt;hexists:看field是否存在&lt;/p&gt;
&lt;p&gt;2-3.List:是個有序的鏈表，元素的值可以重複，可以把東西加在頭或尾&lt;/p&gt;
&lt;p&gt;指令:lpush 從左往管子裡塞東西，一直推擠過去&lt;/p&gt;
&lt;p&gt;lrange 0 end (最左是0 1 2 3&amp;hellip;，也可以用負數 -1表示最後一個 -2表示倒數第2&lt;/p&gt;
&lt;p&gt;比如說lrange 0 -1 =從左開始全顯示&lt;/p&gt;
&lt;p&gt;rpush 從右邊加東西 (就順序上來說比較習慣)&lt;/p&gt;
&lt;p&gt;lpop / rpop 從左或右取出數據(彈走了)&lt;/p&gt;
&lt;p&gt;del key 刪掉就沒了&lt;/p&gt;
&lt;p&gt;lindex 按照索引下標獲得元素(從左到右0開始)&lt;/p&gt;
&lt;p&gt;llen 長度&lt;/p&gt;
&lt;p&gt;2-4.Set:String類型的無序集合(元素的值不能重複)&lt;/p&gt;
&lt;p&gt;舉例 存放email不該重複 (重複加了無效)&lt;/p&gt;
&lt;p&gt;指令saad&lt;/p&gt;
&lt;p&gt;smembers 印出所有值&lt;/p&gt;
&lt;p&gt;sismember 判斷值是否成員&lt;/p&gt;
&lt;p&gt;srem 刪除指定值&lt;/p&gt;
- https://yoziming.github.io/post/210810-agg-go-redis/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>Reflect反射</title>
        <link>https://yoziming.github.io/post/210810-agg-go-reflect/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-reflect/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-reflect/ -&lt;h1 id=&#34;reflect反射&#34;&gt;reflect反射&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func reflectTest01(b interface{}) {
	//通過反射獲取傳入的各種訊息
	//先拿reflect.Type
	rType := reflect.TypeOf(b)
	fmt.Println(&amp;quot;rType=&amp;quot;, rType)

	rVal := reflect.ValueOf(b)
	fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)
	// n1:=10+rVal //rVal他看起來是int但其實是type reflect.Value
	n1 := 10 + rVal.Int() //用.Int()轉換後就可以了
	// n3 := rVal.Float()//像這樣也不行的，一定要確認類型
	fmt.Println(&amp;quot;n1=&amp;quot;, n1)
	// fmt.Println(&amp;quot;n3=&amp;quot;, n3)

	//把rVal轉回interface{}
	iV := rVal.Interface()
	n2 := iV.(int)
	fmt.Println(&amp;quot;n2=&amp;quot;, n2)
}

func reflectTest02(b interface{}) {
	//通過反射獲取傳入的各種訊息
	//先拿reflect.Type
	rType := reflect.TypeOf(b)
	fmt.Println(&amp;quot;rType=&amp;quot;, rType)

	rVal := reflect.ValueOf(b)
	fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)

	//把rVal轉回interface{}
	iV := rVal.Interface()
	//斷言回來
	n2, ok := iV.(Student)
	if !ok {
		fmt.Println(&amp;quot;從interface{}轉換回Student失敗&amp;quot;)
	}
	fmt.Println(&amp;quot;n2=&amp;quot;, n2)
	fmt.Println(&amp;quot;n2.Name=&amp;quot;, n2.Name)

	//獲取變量對應的kind，可以從Type也能從val拿。
	//比如這個type是包名.Student，kind是stuct，可以說定義上kind包含type
	fmt.Println(&amp;quot;kind=&amp;quot;, rType.Kind())
	fmt.Println(&amp;quot;kind=&amp;quot;, rVal.Kind())

}

type Student struct {
	Name string
	Age  int
}

func main() {
	var num int = 100
	reflectTest01(num)
	fmt.Println(&amp;quot;===============================&amp;quot;)
	stu := Student{
		Name: &amp;quot;tom&amp;quot;,
		Age:  20,
	}
	reflectTest02(stu)

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;修改變量&#34;&gt;修改變量&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func reflect01(b interface{}) {
	rVal := reflect.ValueOf(b)
	fmt.Println(&amp;quot;rVal=&amp;quot;, rVal)
	rType := reflect.TypeOf(b)
	fmt.Println(&amp;quot;rType=&amp;quot;, rType)

	iV := rVal.Interface()
	vNew, ok := iV.(float64)
	if ok {
		fmt.Println(&amp;quot;轉換成功 vNew=&amp;quot;, vNew)
	} else {
		fmt.Println(&amp;quot;err&amp;quot;)
	}
}
func main() {
	var v float64 = 1.2
	reflect01(v)

	// var str string = &amp;quot;tom&amp;quot;  //錯誤示範
	// fs := reflect.ValueOf(str)
	// fs.SetString(&amp;quot;jack&amp;quot;)
	// fmt.Println(str)

	var str string = &amp;quot;tom&amp;quot;
	fs := reflect.ValueOf(&amp;amp;str)
	fs.Elem().SetString(&amp;quot;jack&amp;quot;)
	fmt.Println(str)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;實踐&#34;&gt;實踐&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Monster struct {
	Name  string `json:&amp;quot;name&amp;quot;`
	Age   int    `json:&amp;quot;age&amp;quot;`
	Score float64
}

//方法打印m值
func (m Monster) Print() {
	fmt.Println(m)
}

//方法 求2和
func (m Monster) GetSum(n1, n2 int) int {
	return n1 + n2
}

//方法 接收4值給Monster
func (m Monster) Set(n string, a int, s float64) {
	m.Name = n
	m.Age = a
	m.Score = s
}

//反射實例
func TestStruct(a interface{}) {
	typ := reflect.TypeOf(a)
	val := reflect.ValueOf(a)
	kd := val.Kind()
	if kd != reflect.Struct {
		fmt.Println(&amp;quot;傳入的不是結構體&amp;quot;)
		return
	}
	//獲取該結構有幾字段
	num := val.NumField()
	fmt.Println(&amp;quot;struct有幾個字段=&amp;quot;, num)

	//遍歷所有字段
	for i := 0; i &amp;lt; num; i++ {
		fmt.Printf(&amp;quot;Field%d 值為%v\n&amp;quot;, i, val.Field(i))
		//獲取struct標籤
		tagVal := typ.Field(i).Tag.Get(&amp;quot;json&amp;quot;)
		if tagVal != &amp;quot;&amp;quot; {
			fmt.Printf(&amp;quot;Field%d tag為%v\n&amp;quot;, i, tagVal)
		}
	}
	//獲取結構體有幾個方法
	numOfMethod := val.NumMethod()
	fmt.Println(&amp;quot;方法有&amp;quot;, numOfMethod)
	//調用第[]個方法且call調用他(傳入參數值)
	//但他這個是方法的首字(asc碼)當排序的 我們的方法是G P S開頭 (1)=第2個
	val.Method(1).Call(nil)
	//試著調用getsum 他call傳入的是要[]reflect.Value
	var params []reflect.Value
	params = append(params, reflect.ValueOf(10))
	params = append(params, reflect.ValueOf(20))
	res := val.MethodByName(&amp;quot;GetSum&amp;quot;).Call(params)
	fmt.Println(&amp;quot;res=&amp;quot;, res[0].Int())
}

func main() {

	var a Monster = Monster{
		Name:  &amp;quot;牛梅王&amp;quot;,
		Age:   500,
		Score: 87,
	}
	TestStruct(a)

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-reflect/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>RPC</title>
        <link>https://yoziming.github.io/post/210927-rpc/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210927-rpc/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210927-rpc/ -&lt;h3 id=&#34;server&#34;&gt;server&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/ 用接口，讓服務端註冊RPC的時候，就能確保他合法

type World struct{}

func (w *World) HelloWorld(name string, resp *string) error {
	*resp = name + &amp;quot;你好&amp;quot;
	return nil
	// 如果這個return的返回值不為空，
	// 那無論傳出的參數是否有值，服務端都不會給東西
	// (就你給你error)
}

// 用接口，讓服務端註冊RPC的時候，就能確保他合法
type MyInerface interface {
	HelloWorld(string *string) error
}

// 調用方法時，給i傳參，參數是實現HelloWorld方法的對象
func RegsiterService(i MyInerface) {
	rpc.RegisterName(&amp;quot;hello&amp;quot;, i)
}
func main() {
	// 1.註冊RPC服務 綁定對象方法
	err := rpc.RegisterName(&amp;quot;hello&amp;quot;, new(World))
	if err != nil {
		fmt.Println(&amp;quot;註冊RPC服務失敗&amp;quot;, err)
	}

	// 2.開始監聽
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8899&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;listener failed&amp;quot;, err)
		return
	}
	fmt.Println(&amp;quot;server開始監聽...&amp;quot;)
	defer listener.Close()
	// 3.建立連接
	conn, err := listener.Accept()
	if err != nil {
		fmt.Println(&amp;quot;Accept failed&amp;quot;, err)
		return
	}
	fmt.Println(&amp;quot;連接成功&amp;quot;)
	defer conn.Close()
	// 4.綁訂服務
	jsonrpc.ServeConn(conn)
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;client&#34;&gt;client&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/rpc&amp;quot;
	&amp;quot;net/rpc/jsonrpc&amp;quot;
)

func main01() {
	// 1.用RPC連接服務器
	// conn, err := rpc.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8899&amp;quot;)
	conn, err := jsonrpc.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8899&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;Accept failed&amp;quot;, err)
		return
	}
	defer conn.Close()
	// 2.遠程調用函數
	var reply = &amp;quot;&amp;quot;
	err = conn.Call(&amp;quot;hello.HelloWorld&amp;quot;, &amp;quot;張三&amp;quot;, &amp;amp;reply)
	if err != nil {
		fmt.Println(&amp;quot;Call failed&amp;quot;, err)
		return
	}
	fmt.Println(reply)
}

func main() {
	// myClient := InitClient(&amp;quot;127.0.0.1:8899&amp;quot;)
	// var resp string
	// err := myClient.HelloWorld(&amp;quot;李四&amp;quot;, &amp;amp;resp)
	// if err != nil {
	// 	fmt.Println(&amp;quot;HelloWorld failed&amp;quot;, err)
	// 	return
	// }
	// fmt.Println(resp, err)
}

type MyClient struct {
	c *rpc.Client
}

// 把c初始化下面才能調用
// func InitClient(addr string) {
// 	conn, _ := jsonrpc.Dial(&amp;quot;tcp&amp;quot;, addr)
// 	return MyClient{c: conn}
// }

func (m *MyClient) HelloWorld(a string, b *string) error {
	return m.c.Call(&amp;quot;hello.HelloWorld&amp;quot;, a, b)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210927-rpc/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>Split切分字串</title>
        <link>https://yoziming.github.io/post/210810-agg-go-split/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-split/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-split/ -&lt;h1 id=&#34;split切分字串&#34;&gt;Split切分字串&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// abc,b=&amp;gt;[a c]
func Split(str, sep string) []string {
	// str=&amp;quot;bsfcvjkhbafs&amp;quot; sep=&amp;quot;b&amp;quot;
	var ret = make([]string, 0, strings.Count(str, sep)+1)
	index := strings.Index(str, sep)
	for index &amp;gt;= 0 {
		ret = append(ret, str[:index])
		str = str[index+len(sep):]
		index = strings.Index(str, sep)
	}
	ret = append(ret, str)
	return ret
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-split/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>Test單元測試</title>
        <link>https://yoziming.github.io/post/210810-agg-go-test/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-test/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-test/ -&lt;h1 id=&#34;test單元測試&#34;&gt;Test單元測試&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;單元測試目的是驗證程式碼(例如一個方法)本身的邏輯是否正確&lt;/li&gt;
&lt;li&gt;單元測試應排除外部依賴（Database、File System IO）&lt;/li&gt;
&lt;li&gt;單元測試應該是隨時隨地都要能正確執行&lt;/li&gt;
&lt;li&gt;單元測試的標題需要具備好的可讀性、明確、標題與測試的內容精確吻合
例：「public void GetTest_帶入會員ID＿應回該ID搜尋到的會員資料DTO」，盡量符合：受測方法＿傳入參數意義＿期望得到的結果&lt;/li&gt;
&lt;li&gt;一個測試只應該關注一件事情，如果受測目標有多種狀況，應該分成好幾個測試去涵蓋所有邏輯&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;3A原則&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Arrange = 準備受測物件、參數、預期結果&lt;/li&gt;
&lt;li&gt;Act = 執行受測方法&lt;/li&gt;
&lt;li&gt;Assert = 驗證執行結果與預測結果是否一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;calgo&#34;&gt;cal.go&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func addUpper(n int) int {
	res := 0
	for i := 0; i &amp;lt;= n; i++ {
		res = +i
	}
	return res
}

func getSub(n1, n2 int) int {
	return n1 - n2
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;cal_testgo&#34;&gt;cal_test.go&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestAddUpper(t *testing.T) {
	//調用
	res := addUpper(10)
	if res != 55 {
		t.Fatalf(&amp;quot;AddUpper(10)執行錯誤 期望=%v 實際=%v&amp;quot;, 55, res)
	}
	t.Logf(&amp;quot;執行正確&amp;quot;)
}

func TestHello(t *testing.T) {
	fmt.Println(&amp;quot;hello&amp;quot;)
}

func TestGetSub(t *testing.T) {
	res2 := getSub(5, 10)
	if res2 != 10 {
		t.Fatalf(&amp;quot;getSub(5, 10)執行錯誤 期望=%v 實際=%v&amp;quot;, 10, res2)
	}
	t.Logf(&amp;quot;執行正確&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;測性能&#34;&gt;測性能&lt;/h2&gt;
&lt;h4 id=&#34;splitgo&#34;&gt;Split.go&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// abc,b=&amp;gt;[a c]
func Split(str, sep string) []string {
	// str=&amp;quot;bsfcvjkhbafs&amp;quot; sep=&amp;quot;b&amp;quot;
	var ret = make([]string, 0, strings.Count(str, sep)+1)
	index := strings.Index(str, sep)
	for index &amp;gt;= 0 {
		ret = append(ret, str[:index])
		str = str[index+len(sep):]
		index = strings.Index(str, sep)
	}
	ret = append(ret, str)
	return ret
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;split_testgo&#34;&gt;Split_test.go&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func BenchmarkSplit(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		Split(&amp;quot;a:b:c&amp;quot;, &amp;quot;:&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-test/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>WaitGroup鎖</title>
        <link>https://yoziming.github.io/post/210810-agg-go-waitgroup/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-waitgroup/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-waitgroup/ -&lt;h1 id=&#34;waitgroup鎖&#34;&gt;WaitGroup鎖&lt;/h1&gt;
&lt;h3 id=&#34;讀寫鎖&#34;&gt;讀寫鎖&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var x = 0
var wg sync.WaitGroup
var rwlock sync.RWMutex

func write() {
	rwlock.Lock()
	x = x + 1
	time.Sleep(time.Millisecond * 10)
	rwlock.Unlock()
	wg.Done()
}

func read() {
	// lock.Lock()
	rwlock.RLock() //鎖讀
	time.Sleep(time.Millisecond)
	rwlock.RUnlock()
	// lock.Unlock()
	wg.Done()
}

func main() {
	start := time.Now()
	for i := 0; i &amp;lt; 10; i++ {
		wg.Add(1)
		go write()
	}
	for i := 0; i &amp;lt; 1000; i++ {
		wg.Add(1)
		go read()
	}
	wg.Wait()
	end := time.Now()
	fmt.Println(end.Sub(start))
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;互斥鎖&#34;&gt;互斥鎖&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var x = 0
var wg sync.WaitGroup
var lock sync.Mutex

func add() {
	for i := 0; i &amp;lt; 50000; i++ {
		lock.Lock()
		x = x + 1
		lock.Unlock()
	}
	wg.Done()
}

func main() {
	wg.Add(2)
	go add()
	go add()
	wg.Wait()
	fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-waitgroup/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>二維數組</title>
        <link>https://yoziming.github.io/post/210810-agg-go-array/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-array/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-array/ -&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// 000000
// 001000
// 020300
// 000000
func main() {
	var arr [4][6]int
	arr[1][2] = 1
	arr[2][1] = 2
	arr[2][3] = 3
	//遍歷
	for i := 0; i &amp;lt; len(arr); i++ {
		for j := 0; j &amp;lt; len(arr[i]); j++ {
			fmt.Print(arr[i][j], &amp;quot; &amp;quot;)
		}
		fmt.Println()
	}
	//遍歷range
	for i, v := range arr {
		for j, v2 := range v {
			fmt.Printf(&amp;quot;arr[%v][%v]=%v \t&amp;quot;, i, j, v2)
		}

		fmt.Println()
	}
	//三班五學生
	var score [3][5]float64
	for i := 0; i &amp;lt; len(score); i++ {
		for j := 0; j &amp;lt; len(score[i]); j++ {
			fmt.Printf(&amp;quot;輸入第%v班第%v位成績&amp;quot;, i+1, j+1)
			fmt.Scanln(&amp;amp;score[i][j])
		}

	}
	cal(score)

}
func cal(score [3][5]float64) {
	total := 0.0
	for i := 0; i &amp;lt; len(score); i++ {
		sum := 0.0
		for j := 0; j &amp;lt; len(score[i]); j++ {
			sum = sum + score[i][j]
		}
		total += sum
		fmt.Printf(&amp;quot;第%d班的總分為%v 平均分%v \n&amp;quot;, i+1, sum, sum/5)
	}
	fmt.Printf(&amp;quot;總分為%v 平均分%v \n&amp;quot;, total, total/15)

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-array/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>冒泡排序</title>
        <link>https://yoziming.github.io/post/210810-agg-go-bubble-sort/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-bubble-sort/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-bubble-sort/ -&lt;h1 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var arr1 = [...]int{5, 9, 6, 8, 7, 3, 4, 2, 1, 6}

func main() {
	s1 := arr1[:]
	bubbleSort(s1)
	fmt.Println(arr1)
}

func bubbleSort(x []int) {
	for j := 1; j &amp;lt; len(x); j++ {
		for i := 0; i &amp;lt; len(x)-1; i++ {
			if x[i] &amp;gt; x[i+1] {
				x[i], x[i+1] = x[i+1], x[i]
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-bubble-sort/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>函數封裝的金字塔</title>
        <link>https://yoziming.github.io/post/210810-agg-go-pyramid/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-pyramid/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-pyramid/ -&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

var input int

func jin(input int) {

	for i := 1; i &amp;lt;= input; i++ {
		for k := 1; k &amp;lt;= input-i; k++ {
			fmt.Print(&amp;quot; &amp;quot;)
		}
		for j := 1; j &amp;lt;= 2*i-1; j++ {
			if j == 1 || j == 2*i-1 || i == input {
				fmt.Print(&amp;quot;*&amp;quot;)
			} else {
				fmt.Print(&amp;quot; &amp;quot;)
			}
		}
		fmt.Println()
	}
}

func main() {
	fmt.Println(&amp;quot;層數=?&amp;quot;)
	fmt.Scanln(&amp;amp;input)
	jin(input)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-pyramid/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>函數綁定方法</title>
        <link>https://yoziming.github.io/post/210810-agg-go-method/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-method/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-method/ -&lt;h1 id=&#34;函數綁定方法&#34;&gt;函數綁定方法&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;方法:結構體的行為，自訂義的結構都可以有方法，方法是作用在指定類型上(綁定的)&lt;/p&gt;
&lt;p&gt;方法就是跟一種類型綁定的函數，因為綁定數據類型了就可以偷雞，具體表現在省指針&lt;/p&gt;
&lt;p&gt;定義方法時候寫的是func(a ABC) //後面怎樣調用都是值拷貝&lt;/p&gt;
&lt;p&gt;定義方法時候寫的是func(a *ABC)//後面怎樣調用都是真實地址&lt;/p&gt;
&lt;p&gt;要調用方法，只能透過那種類型的的數據變量 例如a1.ABC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Person struct {
	Name string
}

//給Person類型綁定一個方法
func (p Person) test() {
	p.Name = &amp;quot;jack&amp;quot;
	fmt.Println(&amp;quot;test()=&amp;quot;, p.Name)
}

//給Person類型添加一個speak方法，輸出xxx是好人
func (p Person) speak() {
	fmt.Println(p.Name, &amp;quot;是一個好人&amp;quot;)
}

//添加一個計算方法算+1...+100
func (p Person) count() {
	res := 0
	for i := 1; i &amp;lt;= 100; i++ {
		res += i
	}
	fmt.Println(p.Name, &amp;quot;計算的結果是&amp;quot;, res)
}

//添加一個計算方法算+1...+n
func (p Person) count2(n int) {
	res := 0
	for i := 1; i &amp;lt;= n; i++ {
		res += i
	}
	fmt.Println(p.Name, &amp;quot;計算的結果是&amp;quot;, res)
}

//添加一個方法計算2個值的和並返回
func (p Person) getSum(n1, n2 int) int {
	return n1 + n2
}

//為了提高效率，通常把方法跟結構的指針綁定
type Circle struct {
	radius float64
}

func (c *Circle) area() float64 {
	c.radius = 10.0                   //因為傳來的是指針，如果在函數裡改他就等於改真實地址了
	return 3.14 * c.radius * c.radius //語法糖 本來應該是要寫(*c)來計算的
}

//給某方法實現方法String()
type Student struct {
	Name string
	Age  int
}

func (stu *Student) String() string {
	str := fmt.Sprintf(&amp;quot;Name=%v Age=%v&amp;quot;, stu.Name, stu.Age)
	return str
}

//練習題
type MeUtils struct {
	//123
}

func (mu MeUtils) Print(m int, n int) {
	for i := 1; i &amp;lt;= m; i++ {
		for j := 1; j &amp;lt;= n; j++ {
			fmt.Print(&amp;quot;*&amp;quot;)
		}
		fmt.Println()
	}

}

func main() {
	var p Person
	p.Name = &amp;quot;tom&amp;quot;
	p.test() //調用方法
	fmt.Println(&amp;quot;main=&amp;quot;, p.Name)
	//test()//報錯的
	//總的來說就是把test方法跟Person類型綁定，而這個test只能用Person類型調用
	//傳的是形參 (函數裡的是一個副本)
	//---------------------------------------------以下開始應用練習
	p.speak()
	p.count()
	p.count2(1000)
	res := p.getSum(10, 20)
	fmt.Println(res)

	//創建變量嘗試調用area
	var c Circle
	c.radius = 5.0
	res2 := c.area() //語法糖 本來應該是要寫(&amp;amp;c).area()的
	fmt.Println(res2)

	//調用Student
	stu1 := Student{
		Name: &amp;quot;tom&amp;quot;,
		Age:  18,
	}
	//如果實現了*Student類型的String方法就會自動調用
	fmt.Println(&amp;amp;stu1)

	//練習題
	var mu MeUtils
	mu.Print(5, 10)

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-method/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>切片</title>
        <link>https://yoziming.github.io/post/210810-agg-go-slice/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-slice/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-slice/ -&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	//切片的類型是引用(傳遞的時候也是引用地址)
	//切片長度可變(不像數組)
	var arr1 = [5]int{1, 2, 3, 4, 5}
	s1 := arr1[1:3] //表示切arr的[1 2] 左開右閉(含左不含右)
	//var slice=arr[0:end]簡寫[:end]
	//[start:len(arr)]=[start:]
	//[0:len(arr)]=[:]
	fmt.Println(&amp;quot;s1內容是&amp;quot;, s1)
	fmt.Println(&amp;quot;s1長度是&amp;quot;, len(s1))
	fmt.Println(&amp;quot;s1容量是&amp;quot;, cap(s1))
	fmt.Printf(&amp;quot;s1第一個地址是%p\n&amp;quot;, &amp;amp;s1[0])
	fmt.Printf(&amp;quot;arr1[1]地址是%p\n&amp;quot;, &amp;amp;arr1[1])
	s1[0] = 33
	fmt.Println(&amp;quot;arr1內容是&amp;quot;, arr1)

	//var 切片名[]type=make([]type,len,cap)
	var s2 []float64 = make([]float64, 5, 10)
	fmt.Println(s2)
	//var 變量=make(類型)
	var s22 = make([]float64, 5, 10)
	fmt.Println(s22)
	var s3 []int = []int{1, 2, 3, 4, 5}
	fmt.Println(s3)
	//用append動態追加
	s3 = append(s3, 6, 7, 8, 9)
	fmt.Println(s3)
	s3 = append(s3, s3...) //...表示擴展
	//用append的時候 其實是創建一個新的arr，值拷貝過去，然後重新指向
	s3[10] = 600
	fmt.Println(s3)

	//用copy 要求2者都是切片類型
	//短的賦給長的 後面沒東西就保持原樣(0)
	//長的賦給短的 不會自動擴容 依照短的
	var s4 = make([]int, 20)
	fmt.Println(s4)
	copy(s4, s3)
	fmt.Println(s4)

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;切string&#34;&gt;切string&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	str := &amp;quot;hello@yozimingfight!&amp;quot;
	//string是一個byte數組，所以可以切片擷取
	s1 := str[6:]
	fmt.Println(s1)
	//但是string是不可變的，不能用s1[0]=&#39;z&#39;這樣想改變一個字
	//看做一個read only的切片

	//可以轉[]byte或[]rune 修改 後轉回去
	arr1 := []byte(str)
	arr1[0] = &#39;z&#39;
	str = string(arr1)
	fmt.Println(str)
	//byte不能處理中文字(3字節)
	arr2 := []rune(str)
	arr2[0] = &#39;我&#39;
	str = string(arr2)
	fmt.Println(str)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;切片練習-費波納數列&#34;&gt;切片練習-費波納數列&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func fbn(n int) []uint64 {
	var s1 []uint64 = make([]uint64, n)
	if n &amp;lt; 2 {
		s1[0] = 1
		return s1
	} else {
		s1[0] = 1
		s1[1] = 1
		for i := 2; i &amp;lt; n; i++ {
			s1[i] = s1[i-1] + s1[i-2]
		}
		return s1
	}
}

func main() {
	a := fbn(1)
	fmt.Println(a)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-slice/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>匿名函數與閉包</title>
        <link>https://yoziming.github.io/post/210810-agg-go-closure/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-closure/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-closure/ -&lt;h1 id=&#34;匿名函數&#34;&gt;匿名函數&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	res := func(n1, n2 int) int {
		return n1 + n2
	}(10, 20)
	fmt.Println(res)
	a := func(n1, n2 int) int {
		return n1 - n2
	}
	res = a(10, 5)
	fmt.Println(res)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;閉包&#34;&gt;閉包&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//累加器
func Add() func(int) int { //Add是一個函數，返回的數據類型是func(int) int

	var n int = 10 //返回的是一個匿名函數，那這個函數用到函數外的n，因此形成一個整體稱為閉包
	return func(x int) int {
		n = n + x
		return n
		//閉包是類，函數是操作，n是字段，函數+使用n構成閉包
		//n只初始化一次
	}
}
func main() {
	a := Add()
	fmt.Println(a(1))
	fmt.Println(a(2))
	fmt.Println(a(3))

}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;案例2&#34;&gt;案例2&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func makeSuffix(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}
func main() {
	f := makeSuffix(&amp;quot;.jpg&amp;quot;)
	fmt.Println(f(&amp;quot;654&amp;quot;))
	fmt.Println(f(&amp;quot;123.jpg&amp;quot;))

}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-closure/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>命令行參數Args&amp;Flag</title>
        <link>https://yoziming.github.io/post/210810-agg-go-argsflag/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-argsflag/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-argsflag/ -&lt;h1 id=&#34;命令行參數argsflag&#34;&gt;命令行參數Args&amp;amp;Flag&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	fmt.Println(&amp;quot;命令行參數有&amp;quot;, len(os.Args))
	//遍歷os.Args切片 得到所有輸入的參數值
	for i, v := range os.Args {
		fmt.Printf(&amp;quot;args[%v]=%v\n&amp;quot;, i, v)
	}
	fmt.Println(&amp;quot;=====================&amp;quot;)

	//flag方法 先定義幾個變量用於接收參數值
	var user string
	var pwd string
	var host string
	var port int

	flag.StringVar(&amp;amp;user, &amp;quot;u&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;帳號 預設為空&amp;quot;)
	flag.StringVar(&amp;amp;pwd, &amp;quot;pwd&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;密碼 預設為空&amp;quot;)
	flag.StringVar(&amp;amp;host, &amp;quot;h&amp;quot;, &amp;quot;localhost&amp;quot;, &amp;quot;主機 預設為localhost&amp;quot;)
	flag.IntVar(&amp;amp;port, &amp;quot;port&amp;quot;, 3306, &amp;quot;端口 預設為3306&amp;quot;)
	//前面有亂打的字就不行 比如...exe 12354 -u tom會調用預設

	flag.Parse() //這個一定要調用

	//輸出結果
	fmt.Printf(&amp;quot;user=%v pwd=%v host=%v port=%v&amp;quot;,
		user, pwd, host, port)
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-argsflag/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>字串轉換常用函數</title>
        <link>https://yoziming.github.io/post/210810-agg-go-string-conver/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210810-agg-go-string-conver/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210810-agg-go-string-conver/ -&lt;h1 id=&#34;字串轉換常用函數&#34;&gt;字串轉換常用函數&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
var str string = &amp;quot;abc123中文&amp;quot;

func main() {
	fmt.Println(&amp;quot;長度=&amp;quot;, len(str))
	r := []rune(str)
	for i := 0; i &amp;lt; len(r); i++ {
		fmt.Printf(&amp;quot;遍歷=%q\n&amp;quot;, r[i])
	}
	//轉成整數 Atoi
	n, err := strconv.Atoi(&amp;quot;5421&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;錯誤,err&amp;quot;)
	} else {
		fmt.Println(&amp;quot;轉換成&amp;quot;, n)
		//整數轉字串
		str2 := strconv.Itoa(654231)
		fmt.Printf(&amp;quot;類型是%T\n&amp;quot;, str2)
		//轉byte
		var bytes = []byte(&amp;quot;hello&amp;quot;)
		fmt.Printf(&amp;quot;bytes=%v \n&amp;quot;, bytes)
		//byte轉回字串
		str3 := string([]byte{97, 98, 99})
		fmt.Printf(&amp;quot;str3=%v \n&amp;quot;, str3)
		//10進制轉2,8,16返回字串
		str4 := strconv.FormatInt(123, 2)
		fmt.Printf(&amp;quot;str4類型是%T,值=%v \n&amp;quot;, str4, str4)
		//查找子串
		b := strings.Contains(&amp;quot;seafood&amp;quot;, &amp;quot;foo&amp;quot;)
		fmt.Printf(&amp;quot;b類型是%T,值=%v \n&amp;quot;, b, b)
		//統計符合數量
		c := strings.Count(&amp;quot;sgfjklewshfrrrrrr&amp;quot;, &amp;quot;r&amp;quot;)
		fmt.Printf(&amp;quot;c類型是%T,值=%v \n&amp;quot;, c, c)
		//不分大小寫 (因為==是分的)
		d := strings.EqualFold(&amp;quot;ABCd&amp;quot;, &amp;quot;aBcD&amp;quot;)
		fmt.Printf(&amp;quot;d類型是%T,值=%v \n&amp;quot;, d, d)
		//查找第一次出現的子串位置
		i := strings.Index(&amp;quot;sdaf654abc&amp;quot;, &amp;quot;a&amp;quot;)
		fmt.Printf(&amp;quot;i類型是%T,值=%v \n&amp;quot;, i, i)
		//查找最後出現的子串位置
		l := strings.LastIndex(&amp;quot;sdaf654abc&amp;quot;, &amp;quot;a&amp;quot;)
		fmt.Printf(&amp;quot;l類型是%T,值=%v \n&amp;quot;, l, l)
		//替換文字
		str5 := &amp;quot;瘟疫之地有瘟疫,瘟疫病人身上有瘟疫&amp;quot;
		r := strings.Replace(str5, &amp;quot;瘟疫&amp;quot;, &amp;quot;痔瘡&amp;quot;, 2)
		fmt.Println(&amp;quot;原句&amp;quot;, str5)
		fmt.Printf(&amp;quot;r類型是%T,值=%v \n&amp;quot;, r, r)
		//依照指定的字串分割成切片
		s := strings.Split(&amp;quot;hello,world,ok&amp;quot;, &amp;quot;,&amp;quot;)
		fmt.Printf(&amp;quot;s類型是%T,值=%v \n&amp;quot;, s, s)
		//大小寫轉換
		cap := &amp;quot;DDDDssss&amp;quot;
		cap = strings.ToLower(cap)
		fmt.Println(cap)
		cap = strings.ToUpper(cap)
		fmt.Println(cap)
		//去掉左右兩邊空格
		sp := strings.TrimSpace(&amp;quot;  KJHF JKLH LKJ  ..   &amp;quot;)
		fmt.Println(sp)
		//去掉左右指定 //TrimLeft // TrimRight
		lr := strings.Trim(&amp;quot;!!KJHFJHG!!!&amp;quot;, &amp;quot;!&amp;quot;)
		fmt.Println(lr)
		//判斷開頭或結束  //HasSuffix
		s6 := strings.HasPrefix(&amp;quot;ftp://192.164.2.1&amp;quot;, &amp;quot;ftp&amp;quot;)
		fmt.Printf(&amp;quot;s6類型是%T,值=%v \n&amp;quot;, s6, s6)
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210810-agg-go-string-conver/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>實作練習-ini解析器</title>
        <link>https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</link>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/</guid>
        <description>柚子茶室 https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/ -&lt;h1 id=&#34;heading&#34;&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;用來解析.ini文檔格式是否有問題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;reflect&amp;quot;
	&amp;quot;strings&amp;quot;
)

type RedisConfig struct {
	Host     string `ini:&amp;quot;host&amp;quot;`
	Port     int    `ini:&amp;quot;port&amp;quot;`
	Password string `ini:&amp;quot;password&amp;quot;`
	Database int    `ini:&amp;quot;database&amp;quot;`
}
type MysqlConfig struct {
	Address  string `ini:&amp;quot;address&amp;quot;`
	Port     int    `ini:&amp;quot;port&amp;quot;`
	Password string `ini:&amp;quot;password&amp;quot;`
	Username string `ini:&amp;quot;username&amp;quot;`
}

type Config struct {
	MysqlConfig `ini:&amp;quot;mysql&amp;quot;`
	RedisConfig `ini:&amp;quot;redis&amp;quot;`
}

func loadIni(fileName string, data interface{}) (err error) {
	// 0. 參數校驗
	// 0.1 傳來的data必須是結構體類型指針
	t := reflect.TypeOf(data)
	// fmt.Println(t.Kind())
	if t.Kind() != reflect.Ptr {
		err = fmt.Errorf(&amp;quot;傳來的data必須是指針&amp;quot;)
		return
	}
	if t.Elem().Kind() != reflect.Struct {
		err = fmt.Errorf(&amp;quot;傳來的data必須是結構體類型指針&amp;quot;)
		return
	}
	// 1. 讀取文件~&amp;gt;Byte類型
	b, err := ioutil.ReadFile(fileName)
	if err != nil {
		return
	}
	//轉成字符串
	lineSlice := strings.Split(string(b), &amp;quot;\r\n&amp;quot;)
	// fmt.Println(lineSlice)
	// 2. 一行一行讀取數據
	var structName string
	for idx, line := range lineSlice {
		line = strings.TrimSpace(line) //去除多餘空格
		// 2.1 如果是註釋就跳過
		if strings.HasPrefix(line, &amp;quot;;&amp;quot;) || strings.HasPrefix(line, &amp;quot;#&amp;quot;) {
			continue
		}
		//純空行就跳過
		if len(line) == 0 {
			continue
		}
		// 2.2 如果是[]開頭表示是節
		if strings.HasPrefix(line, &amp;quot;[&amp;quot;) {
			if line[0] != &#39;[&#39; || line[len(line)-1] != &#39;]&#39; {
				err = fmt.Errorf(&amp;quot;line:%d syntax error&amp;quot;, idx+1)
				return
			}
			//去掉這行的首尾跟空格拿到內容
			section := strings.TrimSpace(line[1 : len(line)-1])
			if len(section) == 0 {
				err = fmt.Errorf(&amp;quot;line:%d syntax error&amp;quot;, idx+1)
				return
			}
			//根據section去data反射對應的結構體
			for i := 0; i &amp;lt; t.Elem().NumField(); i++ {
				field := t.Elem().Field(i)
				if section == field.Tag.Get(&amp;quot;ini&amp;quot;) {
					//說明找到了，把字段名記下
					structName = field.Name
					fmt.Println(section, structName)
				}

			}

		} else {
			// 2.3 剩下的就是分割的鍵值對
			//先排除異常的行
			if strings.Index(line, &amp;quot;=&amp;quot;) == -1 || strings.HasPrefix(line, &amp;quot;=&amp;quot;) {
				err = fmt.Errorf(&amp;quot;line:%d syntax error&amp;quot;, idx+1)
				return
			}
			index := strings.Index(line, &amp;quot;=&amp;quot;)
			key := strings.TrimSpace(line[:index])
			// value := strings.TrimSpace(line[:index+1])
			v := reflect.ValueOf(data)
			sValue := v.Elem().FieldByName(structName) //拿到嵌套結構體的值信息
			sType := sValue.Type()                     //拿到嵌套結構體的類型信息
			if sType.Kind() != reflect.Struct {
				err = fmt.Errorf(&amp;quot;%s應該為一個結構體&amp;quot;, structName)
				return
			}
			var fieldName string
			//遍歷嵌套結構體每一個字段 判斷tag是否=key
			for i := 0; i &amp;lt; sValue.NumField(); i++ {
				field := sType.Field(i)
				if field.Tag.Get(&amp;quot;ini&amp;quot;) == key {
					fieldName = field.Name
					break
				}
			}
			//根據fieldName取出字段賦值
			fileObj := sValue.FieldByName(fieldName)
			fmt.Println(fieldName, fileObj)
		}

	}
	return
}

func main() {
	var cfg Config
	err := loadIni(&amp;quot;C:/config.ini&amp;quot;, &amp;amp;cfg)
	if err != nil {
		panic(err)
	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210820-agg-go-proj-ini%E8%A7%A3%E6%9E%90%E5%99%A8/ - yoziming</description>
        </item>
    
    
  </channel>
</rss> 