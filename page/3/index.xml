<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yoziming&#39; Blog</title>
    <link>https://yoziming.github.io/</link>
    <description>Recent content on yoziming&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>yoziming</copyright>
    <lastBuildDate>Tue, 23 Nov 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yoziming.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>consul基礎使用練習</title>
        <link>https://yoziming.github.io/post/210928-consul%E4%BD%BF%E7%94%A8%E7%B7%B4%E7%BF%92/</link>
        <pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210928-consul%E4%BD%BF%E7%94%A8%E7%B7%B4%E7%BF%92/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210928-consul%E4%BD%BF%E7%94%A8%E7%B7%B4%E7%BF%92/ -&lt;h1 id=&#34;consul基礎使用練習&#34;&gt;consul基礎使用練習&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;想像去郵局辦事，consul類似於發號碼牌的那個機器&lt;/p&gt;
&lt;p&gt;伺服端(櫃台人員)去找consul註冊服務，比如說櫃台1~3提供儲蓄，櫃台4~6提供郵寄服務&lt;/p&gt;
&lt;p&gt;客戶進來透過服務發現，把要辦的事丟給consul，它查看哪個櫃台健康，幫你匹配對應的服務或叫號&lt;/p&gt;
&lt;p&gt;(感覺這例子不太完善，就&amp;hellip;類似的理解啦，實際用了才會懂)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下載&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 官網:
https://www.consul.io/downloads
# ubuntu shell: (下載&amp;gt;解壓縮&amp;gt;把二進位執行檔丟進去)
wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zip
unzip consul_1.10.3_linux_amd64.zip
sudo mv consul /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;consul -h
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;啟動server&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=192.168.234.128 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個IP=192.168.234.128=ubuntu的ip&lt;/p&gt;
&lt;p&gt;*若/etc/consul.d/不存在要先自己創&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看服務&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://192.168.234.128:8500/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;註冊自訂的健康檢查服務，範例:&lt;/p&gt;
&lt;p&gt;剛剛自訂的配置檔路徑/etc/consul.d/下新增一個web.json&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{&amp;quot;service&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;web&amp;quot;,
    &amp;quot;tags&amp;quot;: [&amp;quot;extract&amp;quot;, &amp;quot;verify&amp;quot;, &amp;quot;compare&amp;quot;, &amp;quot;idcard&amp;quot;],
    &amp;quot;address&amp;quot;: &amp;quot;192.168.234.128&amp;quot;,
    &amp;quot;port&amp;quot;: 9000,
    &amp;quot;check&amp;quot;: {
        &amp;quot;id&amp;quot;: &amp;quot;api&amp;quot;,
        &amp;quot;name&amp;quot;: &amp;quot;HTTP API on port 9000&amp;quot;,
        &amp;quot;http&amp;quot;: &amp;quot;http://localhost:9000&amp;quot;,
        &amp;quot;interval&amp;quot;: &amp;quot;10s&amp;quot;,
        &amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;
        }
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重啟server並查看服務&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-20210929143815247.png&#34; alt=&#34;image-20210929143815247&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;結果是不健康，因為沒有東西回應它&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;透過consul來傳遞一個簡單服務案例&#34;&gt;透過consul來傳遞一個簡單服務案例:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;person.proto&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;syntax=&amp;quot;proto3&amp;quot;;
package pb;
option go_package=&amp;quot;/.;pb&amp;quot;;
message Person{
    string name=1;
    int32 age=2;
}

service hello{
    rpc sayHello(Person) returns(Person);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;server&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/hashicorp/consul/api&amp;quot;
	&amp;quot;github.com/my/repo/consul/pb&amp;quot;
)

type Children struct {
}

// 綁定方法實現接口
func (c *Children) SayHello(ctx context.Context, p *pb.Person) (*pb.Person, error) {
	p.Name = &amp;quot;hello&amp;quot; + p.Name
	return p, nil
}

func main() {
	// 1. 把grpc註冊到consul，初始化
	consulConfig := api.DefaultConfig()

	// 2. 創建consul對象
	consulClient, err := api.NewClient(consulConfig)
	if err != nil {
		fmt.Println(&amp;quot;api.NewClient err&amp;quot;, err)
		return
	}

	// 3. 告訴consul將要註冊的服務消息
	reg := api.AgentServiceRegistration{
		ID:      &amp;quot;bj38&amp;quot;,
		Tags:    []string{&amp;quot;grpc&amp;quot;, &amp;quot;consul&amp;quot;},
		Name:    &amp;quot;grpc And Consul&amp;quot;,
		Address: &amp;quot;127.0.0.1&amp;quot;,
		Port:    8800,
		Check: &amp;amp;api.AgentServiceCheck{
			CheckID:  &amp;quot;consul grpc test&amp;quot;,
			TCP:      &amp;quot;127.0.0.1:8800&amp;quot;,
			Timeout:  &amp;quot;1s&amp;quot;,
			Interval: &amp;quot;5s&amp;quot;,
		},
	}
	// 4. 註冊到consul上
	consulClient.Agent().ServiceRegister(&amp;amp;reg)
	fmt.Println(&amp;quot;服務啟動...&amp;quot;)

}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;client&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;

	&amp;quot;github.com/hashicorp/consul/api&amp;quot;
	&amp;quot;github.com/my/repo/consul/pb&amp;quot;
	&amp;quot;google.golang.org/grpc&amp;quot;
)

func main() {
	// 初始化consul
	consulConfig := api.DefaultConfig()
	consulClient, err := api.NewClient(consulConfig)
	if err != nil {
		fmt.Println(&amp;quot;api.NewClient err&amp;quot;, err)
	}

	// 服務發現，從consul上獲取健康的服務
	services, _, err := consulClient.Health().Service(&amp;quot;grpc And Consul&amp;quot;, &amp;quot;grpc&amp;quot;, true, nil)
	if err != nil {
		fmt.Println(&amp;quot;consulClient.Health().Service err&amp;quot;, err)
		return
	}
	// 拼接出服務的IP跟端口
	fmt.Println(services[0].Service.Address)
	fmt.Println(services[0].Service.Port)
	addr := services[0].Service.Address + &amp;quot;:&amp;quot; + strconv.Itoa(services[0].Service.Port)

	grpcConn, _ := grpc.Dial(addr, grpc.WithInsecure())

	grpcClient := pb.NewHelloClient(grpcConn)
	var person pb.Person
	person.Name = &amp;quot;Tom~&amp;quot;
	person.Age = 18

	p, err := grpcClient.SayHello(context.TODO(), &amp;amp;person)
	fmt.Println(p, err)

}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;記得隨便用個cmd 開啟consul當橋梁&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ consul agent -dev
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210928-consul%E4%BD%BF%E7%94%A8%E7%B7%B4%E7%BF%92/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>Golang下透過grpc調用服務案例</title>
        <link>https://yoziming.github.io/post/210927-grpc/</link>
        <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210927-grpc/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210927-grpc/ -&lt;h2 id=&#34;golang下透過grpc調用服務案例&#34;&gt;Golang下透過grpc調用服務案例&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;grpc簡單說就是跨平台(跨語言)調用各種服務的通用轉接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;對.proto文件使用轉譯指令:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc --go_out=plugins=grpc:. *.proto
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;案例:透過grpc遠程傳遞一個調用teacher資料類型的服務&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;.proto:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;syntax=&amp;quot;proto3&amp;quot;;

option go_package=&amp;quot;/.;pb&amp;quot;;

message Teacher{
    int32 age=1;
    string name=2;
}

service SayName{
    rpc SayHello(Teacher) returns(Teacher);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;server:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Children struct{}

// 綁定類方法
func (c *Children) SayHello(ctx context.Context, t *pb.Teacher) (*pb.Teacher, error) {
	t.Name += &amp;quot;is sleeping&amp;quot;
	return t, nil
}

func main() {
	// 初始一個grpc對象
	grpcServer := grpc.NewServer()

	// 註冊服務
	pb.RegisterSayNameServer(grpcServer, new(Children))

	// 監聽
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8899&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;listen err&amp;quot;, err)
		return
	}
	fmt.Println(&amp;quot;server監聽中...&amp;quot;)
	defer listener.Close()

	// 啟動服務
	grpcServer.Serve(listener)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;client:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	// 連接grpc服務
	grpcConn, err := grpc.Dial(&amp;quot;127.0.0.1:8899&amp;quot;, grpc.WithInsecure())
	if err != nil {
		fmt.Println(&amp;quot;conn err&amp;quot;, err)
		return
	}
	defer grpcConn.Close()

	// 初起化客戶端
	gprcClient := pb.NewSayNameClient(grpcConn)

	// 創建並初始化接收對象
	var teacher pb.Teacher
	teacher.Age = 18
	teacher.Name = &amp;quot;Mary&amp;quot;

	// 調用遠程服務
	t, err := gprcClient.SayHello(context.TODO(), &amp;amp;teacher)
	fmt.Println(t, err)
}
&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210927-grpc/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>Golang中使用ProtoBuf</title>
        <link>https://yoziming.github.io/post/210926-golang%E4%B8%8B%E4%BD%BF%E7%94%A8protobuf/</link>
        <pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210926-golang%E4%B8%8B%E4%BD%BF%E7%94%A8protobuf/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210926-golang%E4%B8%8B%E4%BD%BF%E7%94%A8protobuf/ -&lt;h2 id=&#34;golang中使用protobuf&#34;&gt;Golang中使用ProtoBuf&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;protobuf類似json，它體積更小效率更高，規範統一(沒有大小寫等困擾)。&lt;/p&gt;
&lt;p&gt;缺點是改動協議就要重新生成、數據本身是二進位沒有可讀性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下載，window系統選.exe，解壓縮放到$GOPATH/bin&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://github.com/protocolbuffers/protobuf/releases
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝golang對應的庫跟插件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go get github.com/golang/protobuf/proto
go get github.com/golang/protobuf/protoc-gen-go
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc -h 或 protoc --version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;沒報錯就是成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息體舉例，xxx.proto&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 指定版本，不打3就會是2
syntax=&amp;quot;proto3&amp;quot;;

// 指定輸出位置&amp;amp;go包名，沒寫轉換不了
// option go_package =&amp;quot;path;name&amp;quot;;
option go_package =&amp;quot;/.&amp;quot;;  // 放在同一目錄下包名為__(空)

// 定義消息體，分配唯一編號 (不能用19000~19999)
message Student{
     int32 age = 1; // 可以不從1開始，但不可重複
     string name = 2;
     People p=3;
     repeated int32 score=4; // 數組
     Week w=5;
     // 聯合體
     oneof data{
         string teacher=6;
         string class=7;
     }
 }

// 消息體可以嵌套
message People{
    int32 weight=1;
}

// 定義枚舉類型
enum Week{
    Monday=0; // 必須從0開始
    Turesday=1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成go文件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc --go_out=. *.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成功轉換出來的就會是一個xxx.pb.go的文件，可以點開看一下，它就是轉換成go語言的版本，記住不要修改這個檔案(他第一行就叫你不要修改)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;添加rpc服務&#34;&gt;添加rpc服務&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;語法:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;service 服務名{
	rpc 函數名(參數:消息體) returns (返回值:消息)
}
舉例:
service bj{
    rpc Say(People) returns (Student);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是rpc用的很廣，他不知道你要轉成給誰用的，於是要調用另一個生成的指令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc --go_out=plugins=grpc:. *.proto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這就是grpc了，到下章繼續&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://yoziming.github.io/post/210926-golang%E4%B8%8B%E4%BD%BF%E7%94%A8protobuf/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>GitHub&#43;Hugo自建簡單Blog流程</title>
        <link>https://yoziming.github.io/post/210926-bulidblogwithhugo/</link>
        <pubDate>Sun, 26 Sep 2021 02:01:58 +0530</pubDate>
        
        <guid>https://yoziming.github.io/post/210926-bulidblogwithhugo/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210926-bulidblogwithhugo/ -&lt;h1 id=&#34;githubhugo自建簡單blog流程&#34;&gt;GitHub+Hugo自建簡單Blog流程&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;看了很多教學有各種高級的自動部署、netlify後台等等，照做卻老是在一些關鍵點卡住。我這個土路雖然蠢笨但確實能做出東西，同樣新手可以試試。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝Chocolatey //程式安裝器，讓你從終端裝各種東西很方便&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://chocolatey.org/install
到這個網址，官方提供很多方法安裝，非常簡單快速一行搞定
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安裝hugo，有些佈景主題要用到加強版(extended)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;choco install hugo -confirm
choco install hugo-extended -confirm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hugo new site &amp;lt;資料夾名稱&amp;gt; //建立一個root，相當於你個人網站的原始資料母巢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挑主題，到https://themes.gohugo.io/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套用主題，範例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; cd &amp;lt;資料夾名稱&amp;gt;
 git init
 git submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依照主題的說明文件修改根目錄下的config.toml
注意，config.toml中的第一項baseURL網址不要有&amp;quot;https://www.ooxx&amp;quot;，否則會造成一些未知的BUG。正確網址應為&amp;quot;https://你的username.github.io/&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到content/post/下開始寫一篇blog&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;開啟本地預覽，指令hugo server -F   //防止時差問題用-F&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隨意一個地方開啟網址http://localhost:1313/ 看看網站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;網站沒問題就打包，指令hugo，會在root資料夾下多出一個public資料夾，裡面就是一個完整的網站準備丟去網路上發布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去gitHub建一個Repository(倉庫)，名稱強制為 你的username.github.io&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下載GitHub Desktop客戶端，可以把他理解成一個雲端，我要把本地public資料夾的內容透過它丟去gitHub上剛剛建的那個Repository(倉庫)裡，之後就能透過網站提供的gitPage功能實現個人網站的搭建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在gitHub網頁點進創建的username.github.io專案，右上角綠色&amp;quot;Code&amp;quot;點開，用桌面程式開啟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式開啟後他會要你選擇一個本地的位置去連結該倉庫，直接連結到root/public下看似方便但會導致一些麻煩&amp;amp;錯誤，菜雞如我是放在根目錄同級的位置，姑且稱這個資料夾叫雲端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把根目錄下public/裡面的內容copy一份到剛剛建立的雲端資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此時回到GitHub Desktop客戶端它會說檢測到本地有新東西準備要上傳，左下角Summary填一個描述(隨意填但必要，他就是讓你描述一下這批上傳的動作，以後冤有頭債有主)，然後點Commit to main，至此一切準備就緒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到右邊點第一次叫publish之類，後面那個按鍵會變成push origin，即是把資料正式上傳到網路上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等個幾秒後到&amp;quot;https://username.github.io/&amp;ldquo;看看成果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之後要更新就是content/post/下建立新的.md，寫完內容然後hugo打包之後push&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
- https://yoziming.github.io/post/210926-bulidblogwithhugo/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>圖片測試</title>
        <link>https://yoziming.github.io/post/210925-imagetest/</link>
        <pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210925-imagetest/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210925-imagetest/ -&lt;ul&gt;
&lt;li&gt;圖片1 使用建立新資料夾後的相對路徑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;400.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;圖片2  使用\static\images\之下的資源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://yoziming.github.io/images/dark-abstract-1877-hd-wallpapers.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;圖片3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image-20210927145513469.png&#34; alt=&#34;image-20210927145513469&#34;&gt;&lt;/p&gt;
- https://yoziming.github.io/post/210925-imagetest/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>MVC &amp; Microservices</title>
        <link>https://yoziming.github.io/post/210910-mvc-microservices/</link>
        <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210910-mvc-microservices/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210910-mvc-microservices/ -&lt;h2 id=&#34;mvc架構&#34;&gt;MVC架構&lt;/h2&gt;
&lt;p&gt;Model:模型，管理資料庫(增刪改查)、業務邏輯、物件結構定義&lt;/p&gt;
&lt;p&gt;View:視圖，使用者實際在看、操作的介面(UI)，前端&lt;/p&gt;
&lt;p&gt;Controller:控制，接收請求、回覆結果，決定工作流程，算是Model跟View的中間人&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-20211012085838544.png&#34; alt=&#34;image-20211012085838544&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;微服務架構microservices&#34;&gt;微服務架構（Microservices）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;單一職責:把業務邏輯拆分成無數個小區塊(Blocks)，負責單一任務，服務之間透過管道來通訊。&lt;/li&gt;
&lt;li&gt;輕量級通訊:使用不依賴語言或平台的格式，例如XML、JSON、protobuf。通常基於HTTP協議、符合REST風格來達成標準化、無狀態化。&lt;/li&gt;
&lt;li&gt;獨立開發、測試、部屬:顧名思義，都拆開了就可以分開做，不像傳統架構牽一髮而動全身。&lt;/li&gt;
&lt;li&gt;容器化:微服務既然能獨立作業了，就可以放到容器(Container)中，互相隔離互不干擾，達成快速部署、節省資源。Docker是目前最普遍的容器技術，Kubernetes(K8s)是常用來管理容器、協調整合的平台。&lt;/li&gt;
&lt;/ol&gt;
- https://yoziming.github.io/post/210910-mvc-microservices/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>一次性隊列</title>
        <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/ -&lt;h1 id=&#34;一次性隊列&#34;&gt;一次性隊列&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//用結構體管理隊列
type Queue struct {
	maxSize int
	array   [3]int
	front   int //隊列首(不包含)
	rear    int //隊尾(含)
}

//添加數據val到隊列
func (q *Queue) AddQueue(val int) (err error) {
	//先判斷是否已滿
	if q.rear == q.maxSize-1 {
		return errors.New(&amp;quot;queue full&amp;quot;)
	}
	q.rear++
	q.array[q.rear] = val
	return
}

//取出數據
func (q *Queue) GetQueue() (val int, err error) {
	//先判斷是否為空
	if q.rear == q.front {
		return -1, errors.New(&amp;quot;queue empty&amp;quot;)
	}
	q.front++
	val = q.array[q.front]
	return val, err

}

//顯示隊列
func (q *Queue) ShowQueue() {
	fmt.Println(&amp;quot;當前隊列=&amp;quot;)
	for i := q.front + 1; i &amp;lt;= q.rear; i++ {
		fmt.Printf(&amp;quot;array[%d]=%d\t&amp;quot;, i, q.array[i])
	}
	fmt.Println(&amp;quot;隊列顯示完畢&amp;quot;)
}

func main() {
	//創建一個隊列
	queue1 := Queue{
		maxSize: 3,
		front:   -1,
		rear:    -1,
	}
	var key string
	var val int
	for {
		fmt.Println(&amp;quot;\n等待操作中...&amp;quot;)
		fmt.Println(&amp;quot;輸入add 添加&amp;quot;)
		fmt.Println(&amp;quot;輸入get 取出&amp;quot;)
		fmt.Println(&amp;quot;輸入show 顯示&amp;quot;)
		fmt.Println(&amp;quot;輸入exit 離開&amp;quot;)

		fmt.Scanln(&amp;amp;key)
		switch key {
		case &amp;quot;add&amp;quot;:
			fmt.Println(&amp;quot;輸入要加入的數值...&amp;quot;)
			fmt.Scanln(&amp;amp;val)
			err := queue1.AddQueue(val)
			if err != nil {
				fmt.Println(err.Error())
			} else {
				fmt.Println(&amp;quot;加入成功&amp;quot;)
			}
		case &amp;quot;get&amp;quot;:
			val, err := queue1.GetQueue()
			if err != nil {
				fmt.Println(err.Error())
			} else {
				fmt.Println(&amp;quot;取出成功&amp;quot;, val)
			}

		case &amp;quot;show&amp;quot;:
			queue1.ShowQueue()
		case &amp;quot;exit&amp;quot;:
			os.Exit(0)
		}

	}
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%B8%80%E6%AC%A1%E6%80%A7%E9%9A%8A%E5%88%97/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>二分樹的3種遍歷</title>
        <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/ -&lt;h1 id=&#34;二分樹的3種遍歷&#34;&gt;二分樹的3種遍歷&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Hero struct {
	No    int
	Name  string
	Left  *Hero
	Right *Hero
}

//前序遍歷 先輸出root 再輸出左子樹 再輸出右子樹，會中左右一層層往下
func PreOrder(node *Hero) {
	if node != nil {
		fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)
		PreOrder(node.Left)
		PreOrder(node.Right)
	}
}

//中序遍歷 左子樹 root 右子樹
func InfixOrder(node *Hero) {
	if node != nil {
		InfixOrder(node.Left)
		fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)
		InfixOrder(node.Right)
	}
}

//後序遍歷 左子樹  右子樹 root，會一路到最左最下開始打
func PostOrder(node *Hero) {
	if node != nil {
		PostOrder(node.Left)
		PostOrder(node.Right)
		fmt.Printf(&amp;quot;no=%d name=%s\n&amp;quot;, node.No, node.Name)

	}
}

func main() {
	//建一個二分樹
	root := &amp;amp;Hero{
		No:   1,
		Name: &amp;quot;宋江&amp;quot;,
	}

	left1 := &amp;amp;Hero{
		No:   2,
		Name: &amp;quot;無用&amp;quot;,
	}

	right1 := &amp;amp;Hero{
		No:   3,
		Name: &amp;quot;你軌&amp;quot;,
	}
	root.Left = left1
	root.Right = right1
	right2 := &amp;amp;Hero{
		No:   4,
		Name: &amp;quot;林沖&amp;quot;,
	}
	right1.Right = right2
	node21 := &amp;amp;Hero{
		No:   21,
		Name: &amp;quot;無用-下左&amp;quot;,
	}
	node22 := &amp;amp;Hero{
		No:   22,
		Name: &amp;quot;無用-下右&amp;quot;,
	}
	left1.Left = node21
	left1.Right = node22

	PreOrder(root)
	fmt.Println(&amp;quot;==========&amp;quot;)
	InfixOrder(root)
	fmt.Println(&amp;quot;==========&amp;quot;)
	PostOrder(root)

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E4%BA%8C%E5%88%86%E6%A8%B9%E7%9A%843%E7%A8%AE%E9%81%8D%E6%AD%B7/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>哈希表數據結構</title>
        <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/ -&lt;h1 id=&#34;哈希表數據結構&#34;&gt;哈希表數據結構&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

type Emp struct {
	Id   int
	Name string
	Next *Emp
}

func (e *Emp) ShowMe() {
	fmt.Printf(&amp;quot;链表%d 找到该雇员 %d\n&amp;quot;, e.Id%7, e.Id)
}

//不帶表頭，即第一個節點就放雇員資料
type EmpLink struct {
	Head *Emp
}

func (e *EmpLink) FindByIdEmpLink(id int) *Emp {
	cur := e.Head
	for {
		if cur != nil &amp;amp;&amp;amp; cur.Id == id {
			return cur
		} else if cur == nil {
			break
		}
		cur = cur.Next
	}
	return nil
}

//給EmpLink寫增加雇員方法，編號從小到大
func (e *EmpLink) AddEmpLink(emp *Emp) {
	cur := e.Head      //輔助指針
	var pre *Emp = nil //輔助指針pre在cur前面
	//如果當前EmpLink是空的
	if cur == nil {
		e.Head = emp
		return
	}
	//給emp找位置並插入
	for {
		if cur != nil {
			if cur.Id &amp;gt; emp.Id { //找到
				break
			}
			pre = cur
			cur = cur.Next
		} else {
			break
		}
	}
	pre.Next = emp
	emp.Next = cur
}

func (e *EmpLink) ShowLink() {
	//如果當前EmpLink是空的
	if e.Head == nil {
		fmt.Println(&amp;quot;當前鏈表為空&amp;quot;)
		return
	}
	cur := e.Head
	for {
		if cur != nil {
			fmt.Printf(&amp;quot;雇員ID=%d 名字=%s ~&amp;gt;&amp;quot;, cur.Id, cur.Name)
			cur = cur.Next
		} else {
			break
		}
	}
	fmt.Println()
}

//鏈表數組
type HashTable struct {
	LinkArr [7]EmpLink
}

//給HashTable寫增加雇員方法
func (h *HashTable) Add(emp *Emp) {
	//使用散列函數，確定雇員添到哪個鏈表
	linkNo := h.HashFun(emp.Id)
	//添加
	h.LinkArr[linkNo].AddEmpLink(emp)
}

//顯示所有HashTable雇員方法
func (h *HashTable) ShowAll() {
	for i := 0; i &amp;lt; len(h.LinkArr); i++ {
		h.LinkArr[i].ShowLink()
	}
}

//查找
func (h *HashTable) FindById(id int) *Emp {
	linkNo := h.HashFun(id)
	return h.LinkArr[linkNo].FindByIdEmpLink(id)
}

//散列函數
func (h *HashTable) HashFun(id int) int {
	return id % 7 //得到一個值，就是鏈表的下標
}

func main() {
	key := 0
	id := 0
	name := &amp;quot;&amp;quot;
	var hashTable HashTable
	for {
		fmt.Println(&amp;quot;===雇員系統===&amp;quot;)
		fmt.Println(&amp;quot;\t1.添加&amp;quot;)
		fmt.Println(&amp;quot;\t2.顯示&amp;quot;)
		fmt.Println(&amp;quot;\t3.查找&amp;quot;)
		fmt.Println(&amp;quot;\t4.退出&amp;quot;)
		fmt.Scanln(&amp;amp;key)
		switch key {
		case 1:
			fmt.Println(&amp;quot;輸入雇員ID&amp;quot;)
			fmt.Scanln(&amp;amp;id)
			fmt.Println(&amp;quot;輸入雇員 name&amp;quot;)
			fmt.Scanln(&amp;amp;name)
			emp := &amp;amp;Emp{
				Id:   id,
				Name: name,
			}
			hashTable.Add(emp)
		case 2:
			hashTable.ShowAll()
		case 3:
			fmt.Println(&amp;quot;輸入欲查雇員ID&amp;quot;)
			fmt.Scanln(&amp;amp;id)
			emp := hashTable.FindById(id)
			if emp == nil {
				fmt.Println(&amp;quot;不存在&amp;quot;)
			} else {
				emp.ShowMe()
			}
		case 4:
			os.Exit(0)
		default:
			fmt.Println(&amp;quot;輸入錯誤&amp;quot;)
		}
	}

}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/ - yoziming</description>
        </item>
    
    
    
        <item>
        <title>單向鏈表</title>
        <link>https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/</guid>
        <description>yoziming&#39; Blog https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/ -&lt;h1 id=&#34;單向鏈表&#34;&gt;單向鏈表&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type HeroNode struct {
	no   int
	name string
	next *HeroNode //表示指向下一個節點
}

//給鏈表插入節點
func Insert(head *HeroNode, newHeroNode *HeroNode) {
	//先找到最後的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		}
		temp = temp.next //不斷往下找
	}
	//把newHeroNode加到屁股
	temp.next = newHeroNode
}

//根據No從小到大插入
func InsertNo(head *HeroNode, newHeroNode *HeroNode) {
	//想找到適當的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		} else if temp.next.no &amp;gt; newHeroNode.no {
			//表示new要插到temp後
			break
		} else if temp.next.no == newHeroNode.no {
			//表示new這個編號已存在
			fmt.Println(newHeroNode.no, &amp;quot;該編號已存在&amp;quot;)
			return
		}
		temp = temp.next //不斷往下找

	}
	//把newHeroNode加到找到的地方
	newHeroNode.next = temp.next
	temp.next = newHeroNode 
}

//根據no刪除一個節點
func DelHeroNode(head *HeroNode, id int) {
	//想找到適當的節點，創建一個輔助
	temp := head
	for {
		if temp.next == nil { //表示找到最後
			break
		} else if temp.next.no == id {
			//表示找到了
			fmt.Println(id, &amp;quot;該編號已刪除&amp;quot;)
			temp.next = temp.next.next
			return
		}
		temp = temp.next //不斷往下找
	}

}

//顯示
func List(head *HeroNode) {
	//創建一個輔助
	temp := head
	if temp.next == nil { //空鏈表?
		fmt.Println(&amp;quot;空&amp;quot;)
		return
	}
	for {
		fmt.Printf(&amp;quot;[%d,%s]==&amp;gt;&amp;quot;, temp.next.no, temp.next.name)
		temp = temp.next      //不斷往下找
		if temp.next == nil { //到尾了
			fmt.Println(&amp;quot;完畢&amp;quot;)
			break
		}
	}
}

func main() {
	//創建一個頭節點(空的)
	head := &amp;amp;HeroNode{}
	hero1 := &amp;amp;HeroNode{
		no:   1,
		name: &amp;quot;宋江&amp;quot;,
	}
	hero2 := &amp;amp;HeroNode{
		no:   2,
		name: &amp;quot;李奎&amp;quot;,
	}
	hero3 := &amp;amp;HeroNode{
		no:   3,
		name: &amp;quot;李軌&amp;quot;,
	}
	hero4 := &amp;amp;HeroNode{
		no:   3,
		name: &amp;quot;321&amp;quot;,
	}
	InsertNo(head, hero3)
	InsertNo(head, hero1)
	InsertNo(head, hero2)
	InsertNo(head, hero4)
	List(head)
	DelHeroNode(head, 2)
	List(head)
}

&lt;/code&gt;&lt;/pre&gt;- https://yoziming.github.io/post/210815-%E5%B0%9A%E8%AA%B2go-%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B-%E5%96%AE%E5%90%91%E9%8F%88%E8%A1%A8/ - yoziming</description>
        </item>
    
    
  </channel>
</rss> 